<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter [
<!ENTITY % entities SYSTEM "generic-entities.ent">
%entities;
]>
<chapter xmlns:its="http://www.w3.org/2005/11/its" xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" role="General" xml:id="cha-apparmor-commandline">
 <title>コマンドラインからのプロファイル構築</title>
 <info>
    <meta name="description" its:translate="yes">Manage system security with AppArmor by configuring and monitoring its profiles using command-line tools</meta>
      <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
        <dm:bugtracker>
        </dm:bugtracker>
	<dm:translation>yes</dm:translation>
      </dm:docmanager>
    <revhistory xml:id="rh-cha-apparmor-commandline">
   <revision>
     <date>2024-05-10</date>
     <revdescription>
       <para/>
     </revdescription>
   </revision>
 </revhistory>
</info>
    <para>&aareg; には、システムのセキュリティを管理するにあたって、グラフィカルなインターフェイスだけでなく、コマンドラインインターフェイスも用意されています。 &aa; のコマンドラインツールでは、 &aa; の状態確認のほか、プロファイルの作成や削除、修正などを行うことができます。</para>
 <tip>
  <title>背景となる情報について</title>
  <para>&aa; のコマンドラインツールでプロファイルを管理し始める前に、まずは <xref linkend="cha-apparmor-concept"/> と <xref linkend="cha-apparmor-profiles"/> にある &aa; の一般的な情報をお読みください。</para>
 </tip>
 <sect1 xml:id="sec-apparmor-commandline-status">
  <title>&aa; の状態確認</title>

  <para>&aa; は下記に示す 3 種類の状態のいずれかになります:</para>

  <variablelist>
   <varlistentry>
    <term>未読み込み (Unloaded)</term>
    <listitem>
     <para>&aa; がカーネル内に読み込まれていない状態です。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>動作中 (Running)</term>
    <listitem>
     <para>&aa; がカーネル内に読み込まれていて、 &aa; がプログラムポリシーを強制している状態です。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>停止済み (Stopped)</term>
    <listitem>
     <para>&aa; がカーネル内に読み込まれていますが、何もポリシーを適用していない状態です。</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para><filename>/sys/kernel/security/apparmor/profiles</filename> ファイルに書かれた内容を読むことで、 &aa; の状態を検知することができます。 <command>cat /sys/kernel/security/apparmor/profiles</command> を実行すると、プロファイルの一覧と &aa; の動作状態が表示されます。中身が空であった場合、 &aa; は停止していることになります。また、ファイルが存在していない場合は、未読み込みの状態であることを示しています。</para>

  <para>&aa; は <command>systemctl</command> コマンドで管理することができます。下記のとおり入力して実行することで、それぞれの処理を実行することができます:</para>

  <variablelist>
   <varlistentry>
    <term><command>sudo systemctl start apparmor</command></term>
    <listitem>
     <para>その時点での &aa; の状態に応じて動作が変わります。未読み込みの状態であった場合、 <option>start</option> コマンドを実行すると &aa; を読み込んで起動し、動作中の状態にします。停止済みの状態であった場合は、 <filename>/etc/apparmor.d</filename> ディレクトリ内にある &aa; プロファイルを読み込み直して、動作中の状態にします。既に &aa; が動作中であった場合は、警告メッセージを表示して何もしません。</para>
     <note>
      <title>既に動作中のプロセスについて</title>
      <para>既に動作中のプロセスに対して &aa; のプロファイルを適用するには、それらを再起動する必要があります。</para>
     </note>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>sudo systemctl stop apparmor</command></term>
    <listitem>
     <para>&aa; が動作中であった場合は、すべてのプロファイルをカーネルのメモリから削除して、すべてのアクセス制御を無効化したあと、停止状態に移行します。 &aa; が既に停止していた場合も同様の処理を行おうとしますが、特に何も起こりません。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>sudo systemctl reload apparmor</command></term>
    <listitem>
     <para>既に動作中で制限を設定しているプロセスに影響を与えることなく、 &aa; のモジュールに対してプロファイルの再スキャンを求めます。 <remark>sknorr, 2014-08-26: "unconfining?" Sounds terrible. Would "freeing" be an option? tbazant, 2014-09-08: No, it's a used term, related to 'unconfined' state </remark> これにより、 <filename>/etc/apparmor.d</filename> ディレクトリ内にある新しいプロファイルが適用されるほか、削除されたプロファイルがあればメモリ内からも削除されます。</para>
    </listitem>
   </varlistentry>
  </variablelist>
</sect1>
 <sect1 xml:id="sec-apparmor-commandline-build">
  <title>&aa; プロファイルの構築</title>

  <para>&aa; のプロファイル定義は <filename>/etc/apparmor.d</filename> ディレクトリ内に存在していて、プロファイル自身はテキストファイルで記述されています。これらのファイルの書式について、詳しくは <xref linkend="cha-apparmor-profiles"/> をお読みください。</para>

  <para><filename>/etc/apparmor.d</filename> ディレクトリ内にあるすべてのファイルはプロファイルとして扱われ、読み込まれます。ディレクトリ内でのファイル名の変更は、プロファイルを削除するにあたっては不適切です。特定のプロファイルを読み込まれないように設定したい場合は、このディレクトリからファイルを削除するか、プロファイルに対して <command>aa-disable</command> を実行してください。これにより、 <filename>/etc/apparmor.d/disabled/</filename> 内にシンボリックリンクが作成されます。</para>

  <para>プロファイルを読み書きしたい場合は、 <command>vi</command> のようなテキストエディタをお使いください。下記の章には、プロファイルを作成するための説明が書かれています:</para>

  <variablelist>
   <varlistentry>
    <term>&aa; プロファイルの追加と作成</term>
    <listitem>
     <para><xref linkend="sec-apparmor-commandline-add"/> をお読みください</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>&aa; プロファイルの編集</term>
    <listitem>
     <para><xref linkend="sec-apparmor-commandline-edit"/> をお読みください</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>&aa; プロファイルの削除</term>
    <listitem>
     <para><xref linkend="sec-apparmor-commandline-del"/> をお読みください</para>
    </listitem>
   </varlistentry>
  </variablelist>

<!-- Code 10 doesn't have apparmor.vim. Maybe next release ...
   <para>
   Use vim to view and edit your profile by typing <command>vim</command> in a
   terminal window. To enable syntax highlighting when you edit an &aa;
  profile in
   vim, use the commands <command>:syntax on</command> then <command>:set
   syntax=apparmor</command>. For more information about vim and syntax
   coloring, refer to <xref
   linkend="sec-apparmor-commandline-profiling-summary-vim"/>.
  </para>
   -->
 </sect1>
 <sect1 xml:id="sec-apparmor-commandline-add">
  <title>&aa; プロファイルの追加と作成</title>

  <para>特定のアプリケーションに対して &aa; のプロファイルを追加もしくは作成するにあたっては、一括プロファイル作成と単独プロファイル作成のいずれかの方式をとることができます。この 2 種類の方式について、詳しい説明は <xref linkend="sec-apparmor-commandline-profiling"/> をお読みください。</para>
 </sect1>
 <sect1 xml:id="sec-apparmor-commandline-edit">
  <title>&aa; プロファイルの編集</title>

  <para>&aa; のプロファイルを編集するには、下記の手順を実施します:</para>

  <procedure>
   <step>
    <para>&rootuser; でログインしていない場合は、端末ウインドウ内で <command>su</command> と入力して実行します。</para>
   </step>
   <step>
    <para>&rootuser; のパスワード入力を求められた場合は、そのパスワードを入力します。</para>
   </step>
   <step>
    <para><command>cd /etc/apparmor.d/</command> と入力して実行し、プロファイルのディレクトリに移動します。</para>
   </step>
   <step>
    <para><command>ls</command> と入力して実行すると、現在インストールされているすべてのプロファイルの一覧を表示することができます。</para>
   </step>
   <step>
    <para>編集したいプロファイルをテキストエディタ (例: vim) で開きます。</para>
   </step>
   <step>
    <para>必要な変更を行ったあと、ファイルを保存して終了します。</para>
   </step>
   <step>
    <para>端末ウインドウ内で <command>systemctl reload apparmor</command> と入力して実行し、 &aa; を再起動します。</para>
   </step>
  </procedure>
 </sect1>
 <sect1 xml:id="sec-apparmor-commandline-unload">
  <title>未知の &aa; プロファイルの読み込み解除</title>
  <warning>
   <title>読み込み解除の危険性について</title>
   <para><command>aa-remove-unknown</command> を実行すると、 <filename>/etc/apparmor.d</filename> ディレクトリ内に存在しないすべてのプロファイル (たとえば自動生成された LXD プロファイルなど) の読み込みが解除されます。これにより、システムのセキュリティが危険にさらされる場合があります。読み込みを解除する前に <option>-n</option> パラメータを付けて実行し、どのプロファイルの読み込みが解除されるのかを調べてから実行しておくことをお勧めします。</para>
  </warning>
  <para><filename>/etc/apparmor.d/</filename> ディレクトリ内に存在していないすべての &aa; プロファイルについて、それらの読み込みを解除したい場合は、下記のように入力して実行します:</para>
  <screen>&prompt.sudo;<command>aa-remove-unknown</command></screen>
  <para>読み込みが解除されるプロファイルの一覧を表示したい場合は、下記のようにします:</para>
  <screen>&prompt.sudo;<command>aa-remove-unknown -n</command></screen>
 </sect1>
 <sect1 xml:id="sec-apparmor-commandline-del">
  <title>&aa; プロファイルの削除</title>
  <para>&aa; のプロファイルを削除するには、下記の手順を実施します:</para>
  <procedure>
   <step>
    <para>まずはカーネルから &aa; の定義を削除します:</para>
    <screen>&prompt.sudo;<command>apparmor_parser -R /etc/apparmor.d/<replaceable>プロファイルのファイル名</replaceable></command></screen>
   </step>
   <step>
    <para>プロファイルのファイルそのものを削除します:</para>
    <screen>&prompt.sudo;<command>rm /etc/apparmor.d/<replaceable>プロファイルのファイル名</replaceable></command>
    &prompt.sudo;<command>rm /var/lib/apparmor/cache/<replaceable>プロファイルのファイル名</replaceable></command></screen>
   </step>
  </procedure>
 </sect1>
 <sect1 xml:id="sec-apparmor-commandline-profiling">
  <title>2 種類のプロファイル作成方法</title>

  <para><xref linkend="cha-apparmor-profiles"/> に &aa; のプロファイル文法に関する説明があるとおり、 &aa; ツールを使用せずにプロファイルを作成することもできます。しかしながら、何もない状態からプロファイルを作成するのは手間がかかります。そのため、 &aa; の各種ツールを利用して、プロファイルを自動作成したり、自動的に調整したりする機能を利用することをお勧めします。</para>

  <para>&aa; のプロファイルを作成するにあたっては、下記に示す 2 種類の方法があります。いずれの方法であっても、ツールを利用して行うことができます。</para>

  <variablelist>
   <varlistentry>
    <term>単独プロファイル作成</term>
    <listitem>
     <para>電子メールクライアントなど、アプリケーション自体が比較的小規模で、かつ必要に応じて起動したり終了したりするようなものにお勧めです。詳しくは <xref linkend="sec-apparmor-commandline-profiling-stand-alone"/> をお読みください。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>一括プロファイル作成</term>
    <listitem>
     <para>多数のプログラムに対してプロファイルを一括作成するような場合に適切であるほか、 Web サーバやメールサーバなどのように、常に動作し続け、システムを再起動した後にも、すぐに動作させる必要があるもののような場合にも適切です。詳しくは <xref linkend="sec-apparmor-commandline-profiling-systemic"/> をお読みください。</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>プロファイルを自動生成することで、 &aa; のツールによる管理がよりやりやすくなります:</para>

  <procedure>
   <step>
    <para>まずは要件にあったプロファイル方法を選びます。</para>
   </step>
   <step>
    <para>静的な分析を行います。選択した方法にあわせて、 <command>aa-genprof</command> もしくは <command>aa-autodep</command> のいずれかを実行します。</para>
   </step>
   <step>
    <para>動的な学習を有効化します。プロファイルを作成したすべてのプログラムに対して、学習モードを有効化します。</para>
   </step>
  </procedure>

  <sect2 xml:id="sec-apparmor-commandline-profiling-stand-alone">
   <title>単独プロファイル作成</title>
   <para>単独でプロファイルを作成して改善していく場合は、 <command>aa-genprof</command> と呼ばれるプログラムを利用します。この方法では、 <command>aa-genprof</command> が様々な作業を代行してもらえるため、作業が簡単になる一方、プログラムを起動してから終了するまでの間、 <command>aa-genprof</command> を実行し続けなければならない、という制限が発生します (つまり、プロファイルの作成中はマシンの再起動を行うこともできなくなります) 。</para>
   <para>単独プロファイル作成で <command>aa-genprof</command> を使用する場合は、 <xref linkend="sec-apparmor-commandline-profiling-summary-genprof"/> をお読みください。</para>
  </sect2>

  <sect2 xml:id="sec-apparmor-commandline-profiling-systemic">
   <title>一括プロファイル作成</title>
   <para>この方法は、 <command>aa-genprof</command> で行う単独 (もしくは少数) のプロファイル作成とは異なり、システム内にある複数のプロファイルを一括で更新することから、 <emphasis>一括プロファイル作成</emphasis> と呼ばれています。一括プロファイル作成ではプロファイルの構築と改善を自動化することができず、手作業が発生しますが、より柔軟に対応することができます。この方法は、システムが再起動しても動作し続ける長期稼働型のアプリケーションや、多数のプログラムに対して一括でプロファイルを作成したい場合に便利です。</para>
   <para>一括で &aa; のプロファイルを作成するには、下記の手順で行います:</para>
   <procedure>
    <step>
     <para>まずはお使いのアプリケーションの各プログラムに対して、プロファイルを作成します。</para>
     <para>この方式を使用する際には、あらかじめプログラムに対する &aa; のプロファイルを作成しておかなければなりません。これは、 &aa; がプロファイルのあるプログラムのみを監視するためです。これに対応させるために、 <command>aa-autodep</command> を利用して、プログラムに対する近似プロファイルを作成してください。詳しくは <xref linkend="sec-apparmor-commandline-profiling-summary-autodep"/> をお読みください。</para>
    </step>
    <step>
     <para>対応するプロファイルを学習 (不平) モードに設定します。</para>
     <para>プロファイルの存在するすべてのプログラムに対して、プロファイルを学習 (不平) モードに切り替えたい場合は、 <!-- NOTE: this sentence is from next paragraph -->端末内で &rootuser; になり、 <!-- NOTE: end --> 下記のように実行します:</para>
<screen>&prompt.sudo;aa-complain /etc/apparmor.d/*</screen>
     <para>この機能は、 &yast; のプロファイルモジュールでも設定することができます。詳しくは <xref linkend="sec-apparmor-yast-manage-profmodes"/> をお読みください。</para>
     <para>学習モードの場合、プロファイル側で明示的に禁止されている場合であっても、実際にアクセス制限が発動されることはありません。これにより、<xref linkend="st-apparmor-commandline-profiling-systemic-exec"/> で示しているとおり、様々なテストを実施して、プログラムにとって必要なアクセス権を正しく検出することができるようになります。また、この情報を利用することで、プロファイル内でどこまでの許可を与えればよいのかがわかるようにもなります。</para>
     <para>学習 (不平) モードへの切り替えについて、詳しくは <xref linkend="sec-apparmor-commandline-profiling-summary-complain"/> をお読みください。</para>
    </step>
    <step xml:id="st-apparmor-commandline-profiling-systemic-exec">
     <para>対象のアプリケーションを様々にテストします。</para>
     <para>アプリケーション内にある様々な機能を動作させて試します。どれだけプログラムを試せばよいのかはプログラム次第ですが、少なくともプログラム側からアクセスする必要のあるファイルに対して、一通りアクセスするようにしてください。なお、処理は <command>aa-genprof</command> の監視下で動作しているわけではありませんので、何日も何週間も動作させたままでかまいませんし、システムを再起動してもかまいません。</para>
    </step>
    <step xml:id="st-apparmor-commandline-profiling-systemic-log">
     <para>ログを分析します。</para>
     <para>一括プロファイル作成では、単独プロファイル時のように <command>aa-genprof</command> から <command>aa-logprof</command> を実行するのではなく、 <command>aa-logprof</command> を直接実行します。 <command>aa-logprof</command> は下記のように入力して実行します:</para>
<screen>&prompt.sudo;aa-logprof [ -d <replaceable>プロファイルのパス</replaceable> ] [ -f <replaceable>/ログファイルのパス</replaceable> ]</screen>
     <para><command>aa-logprof</command> の使用方法について、詳しくは <xref linkend="sec-apparmor-commandline-profiling-summary-logprof"/> をお読みください。</para>
    </step>
    <step>
     <para><xref linkend="st-apparmor-commandline-profiling-systemic-exec"/> と <xref linkend="st-apparmor-commandline-profiling-systemic-log"/> を繰り返し実施します。</para>
     <para>これにより、最適なプロファイルを作成することができるようになります。このように繰り返し実施することで、分析対象のログファイルを小さくすることができますので、より素早くプロファイルに反映できるようになります。また、繰り返すたびにログの出力も減るはずですので、処理も高速化されます。</para>
    </step>
    <step>
     <para>プロファイルを編集します。</para>
     <para>生成されたプロファイルの内容を確認します。具体的には、テキストエディタなどで <filename>/etc/apparmor.d/</filename> ディレクトリ内のファイルを開いて、必要であれば編集を行います。</para>
    </step>
    <step>
     <para>強制モードに戻します。</para>
     <para>強制モードに戻すことで、プロファイルのルールに対して、その違反を記録するだけでなく、違反を明示的に禁止することができるようになります。この作業は、プロファイルをテキストエディタなどで開いて、 <literal>flags=(complain)</literal> と書かれた箇所を削除して保存するか、もしくは <command>aa-enforce</command> コマンドを使用することで行うことができます (<command>aa-enforce</command> コマンドは、<command>aa-complain</command> と同じように使用することができるもので、強制モードに移行させることができます) 。また、この作業は &yast; のプロファイルモジュールでも実施することができます。詳しくは <xref linkend="sec-apparmor-yast-manage-profmodes"/> をお読みください。</para>
     <para>すべてのプロファイルを不平モードから強制モードに移行させたい場合は、 <command>aa-enforce /etc/apparmor.d/*</command> と入力して実行します。</para>
    </step>
    <step>
     <para>再度すべてのプロファイルをスキャンします。</para>
     <para>&aa; に対してすべてのプロファイルを再スキャンさせ、カーネル内を強制モードに変更するには、 <command>systemctl reload apparmor</command> と入力して実行します。</para>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec-apparmor-commandline-profiling-summary">
   <title>プロファイル作成ツールの概要</title>
   <para>&aa; におけるプロファイルユーティリティは、 <systemitem>apparmor-utils</systemitem> パッケージ内にすべて含まれていて、 <filename>/usr/sbin</filename> 内にインストールされます。それぞれのツールの概要は下記のとおりです。</para>
   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-autodep">
    <title>aa-autodep: 近似プロファイルの作成</title>
    <para>このプログラムは、選択したプログラムやアプリケーションに対応する、近似プロファイルを作成するツールです。バイナリ実行ファイルやインタプリタ型のスクリプトプログラムに対応しています。生成されたプロファイルは、 &aa; で適切に制限を設定するにあたって、完全なものではないことから、 <quote>近似</quote> プロファイルと呼ばれます。 <command>aa-autodep</command> で生成される近似プロファイルには、ほとんどのプログラムで必要な項目を列挙した、基本的な include ディレクティブのみが含まれる最小限のプロファイルとなります。また、特定の種類のプログラムであれば、 <command>aa-autodep</command> はさらに詳しいプロファイルを生成します。コマンドラインで指定したプログラムに対して <command>ldd(1)</command> を再帰的に呼び出し、プロファイルを生成しようとします。</para>
    <para>近似プロファイルを生成するには <command>aa-autodep</command> プログラムを使用します。パラメータとしてプログラム名を単純に指定した場合は、 <command>aa-autodep</command> がシェルの PATH 環境変数を展開してプログラムを探します。フルパスを指定してもかまいません。また、プログラムそれ自身は任意のものでかまいません (ELF バイナリであっても、シェルや Perl のスクリプトであってもかまいません) 。 <command>aa-autodep</command> は、後続の動的プロファイル作成で改善を行うための、ベースとなる近似プロファイルを生成します。</para>
    <para>生成された近似プロファイルは、 <filename>/etc/apparmor.d</filename> ディレクトリ内に、 &aa; のプロファイル命名規約に従って出力されます。具体的には、スラッシュ ( <literal>/</literal> ) をピリオド  ( <literal>.</literal> ) に置き換えたファイル名になります。 <command>aa-autodep</command> のコマンドの書式は下記のとおりです:</para>
<screen>&prompt.sudo;aa-autodep [ -d <replaceable>プロファイルのパス</replaceable> ] [<replaceable>プログラム_1</replaceable> <replaceable>プログラム_2</replaceable>...]</screen>
    <para>プログラム名を入力しない場合は、入力を求められます。また、 <replaceable>プロファイルのパス</replaceable> を指定した場合は、既定のプロファイル保存先である <filename>/etc/apparmor.d</filename> を変更し、既定の場所以外にプロファイルを保存することができます。</para>
    <para>プロファイル作成を開始するにあたっては、まずお使いのアプリケーションを構成するメインの実行ファイル (プロファイルが存在しておらず、他のプログラムから呼び出されることのない実行ファイル) に対して、プロファイルを作成しなければなりません。このような条件に該当するプログラムを、お使いのアプリケーション内ですべて見つけてから、プロファイルを作成してください。このようなプログラムを見つける方法には、下記のような方法があります:</para>
    <variablelist>
     <varlistentry>
      <term>ディレクトリ</term>
      <listitem>
       <para>プロファイルを作成すべきプログラムが特定の 1 つのディレクトリ内にのみ存在し、それ以外には存在しない場合であれば、 <command>aa-autodep</command> <replaceable>プログラムのパス/*</replaceable> のように実行することで、そのディレクトリ内にあるすべてのプログラムに対して、近似プロファイルを作成することができます。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>pstree -p</term>
      <listitem>
       <para>アプリケーションを起動したあと、標準的な Linux コマンドである <command>pstree</command> を使用することで、動作中のすべてのプロセスを取得することができます。あとはプログラムがどこに配置されているのかを突き止めて、それぞれに対して <command>aa-autodep</command> を実行します。なお、プログラムがお使いのパス内に存在している状態であれば、 <command>aa-autodep</command> を実行するだけで、実際のコマンドパスを自動的に検索させることができます。パス内に存在していない場合は、標準的な Linux コマンドである <command>find</command> を使用して、プログラムパスを探してください。たとえば <command>find / -name '</command> <replaceable>アプリケーション名</replaceable> ' -print のように実行することで、アプリケーションのパスを取得することができます。また、必要であればワイルドカードを使用してもかまいません。</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-complain">
    <title>aa-complain: 不平モード (学習モード) への突入</title>
    <para>不平モード (学習モード) ツール ( <command>aa-complain</command> ) は、指定した &aa; のプロファイルルールのモードを変更するツールです。不平モードに設定したプロファイルに対しては、ルールへの違反が許容されるものの、ログに記録されるようになります。これはプロファイルを改善していくための仕組みで、いったん不平モードを設定した後、さまざまなプログラム処理を実施して、プログラムのアクセス要件をログに記録させて、そのログを元にプロファイルを改善する流れを取ります。</para>
    <para>コマンドラインから不平モードを手作業で有効化すると、プロファイルの冒頭にフラグを設定し、 <literal>/bin/foo</literal> のような項目が <literal>/bin/foo flags=(complain)</literal> のようになります。不平モードを使用するには、 <!-- or create a symbolic link in force-complain --> 端末ウインドウを開いて、 &rootuser; で下記のように入力して実行します:</para>
    <itemizedlist mark="bullet" spacing="normal">
     <listitem>
      <para>プログラム ( <replaceable>プログラム_1</replaceable> ) がパス内に存在する場合は、下記のように実行します:</para>
<screen>&prompt.sudo;aa-complain [<replaceable>プログラム_1</replaceable> <replaceable>プログラム_2</replaceable> ...]</screen>
     </listitem>
     <listitem>
      <para>プログラムがパス内に存在しない場合は、下記のようにフルパスで指定します:</para>
<screen>&prompt.sudo;aa-complain /sbin/<replaceable>プログラム_1</replaceable></screen>
     </listitem>
     <listitem>
      <para>また、プロファイルが <filename>/etc/apparmor.d</filename> 内に存在しない場合は、下記のように配置場所を指定します:</para>
<screen>&prompt.sudo;aa-complain <replaceable>プロファイルのパス</replaceable><replaceable>プログラム_1</replaceable></screen>
     </listitem>
     <listitem>
      <para><replaceable>/sbin/program1</replaceable> のプロファイルを指定したい場合は、下記のように入力して実行します:</para>
<screen>&prompt.sudo;aa-complain /etc/apparmor.d/sbin.<replaceable>プログラム_1</replaceable></screen>
     </listitem>
    </itemizedlist>
    <para>上述のコマンドはいずれも、指定したプロファイルやプログラムを不平モードに切り替える処理を行います。プログラムの指定の際、これをフルパスで指定しないと、 <command>aa-complain</command> は <envar>$PATH</envar> 内を検索して、プログラムの場所を判断します。たとえば <command>aa-complain /usr/sbin/*</command> のように入力して実行すると、 <filename>/usr/sbin</filename> 内に存在するすべてのプログラムに対して、対応するプロファイルを検索し、それらすべてを不平モードに設定します。また、 <command>aa-complain /etc/apparmor.d/*</command> のように入力して実行すると、 <filename>/etc/apparmor.d</filename> 内にあるすべてのプロファイルを不平モードに切り替えます。</para>
    <tip>
     <title>&yast; を利用したプロファイルの切り替えについて</title>
     <para>&yast; には、不平モードと強制モードを切り替えることのできるグラフィカルなフロントエンドが用意されています。詳しくは <xref linkend="sec-apparmor-yast-manage-profmodes"/> をお読みください。</para>
    </tip>
   </sect3>
   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-decode">
    <title>aa-decode: &aa; ログファイル内にある 16 進数にエンコードされた文字列のデコード</title>
    <para><command>aa-decode</command> は、 &aa; のログ出力内に存在する 16 進数で書かれた文字列をデコードすることができます。標準入力から監査ログを入力させることもできますし、 &aa; のログ内にある 16 進数の文字列をデコードして、標準出力に書き出すこともできます。</para>
   </sect3>
   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-disable">
    <title>aa-disable: &aa; セキュリティプロファイルの無効化</title>
    <para><command>aa-disable</command> コマンドは、 1 つもしくは複数の &aa; プロファイルの強制モードを無効化するために使用します。このコマンドを実行すると、カーネルからプロファイルの読み込みを解除して開放し、 &aa; の起動時にもプロファイルが読み込まれないようにします。この動作を変更したい場合は、 <command>aa-enforce</command> もしくは <command>aa-complain</command> の各ツールをお使いください。</para>
   </sect3>
   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-easyprof">
    <title>aa-easyprof: 簡易プロファイル生成</title>
    <para><command>aa-easyprof</command> は &aa; のプロファイル生成に対して、簡易的なインターフェイスを提供する仕組みです。 <command>aa-easyprof</command> ではテンプレート (雛形) やグループ化の仕組みを使用して、アプリケーションのプロファイルを素早く作成することができます。 <command>aa-easyprof</command> はプロファイル生成の支援を行いますが、これは使用するテンプレートの品質とプロファイルのグループ、および抽象に依存しています。また、このツールは手作業でプロファイルを作成する場合や、 <command>aa-genprof</command> と <command>aa-logprof</command> を利用してプロファイルを作成する場合に比べると、制限の緩いプロファイルを作成することになります。</para>
    <para>詳しくは <command>aa-easyprof</command> (8) のマニュアルページをお読みください。</para>
   </sect3>
   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-enforce">
    <title>aa-enforce: 強制モードへの突入</title>
    <para>強制モードでは、プロファイルで許可されていないファイルへのアクセスが禁止されるなど、 &aa; のプロファイルルールへの違反を検知することができます。このモードでは、違反はログに記録されるだけでなく、許可もされません。そのため、普段使用する場合は強制モードの適用を推奨します。違反を記録するのみで禁止したくない場合は、不平モードに設定してください。</para>
    <para>コマンドラインから強制モードを手作業で設定すると、プロファイルの冒頭にあるフラグを削除し、 <literal>/bin/foo flags=(complain)</literal> のような項目が <literal>/bin/foo</literal> のようになります。強制モードを使用するには、端末ウインドウを開いて、 &rootuser; で下記のいずれかのように入力して実行します:</para>
    <itemizedlist mark="bullet" spacing="normal">
     <listitem>
      <para>プログラム ( <replaceable>プログラム_1</replaceable> ) がパス内に存在する場合は、下記のように実行します:</para>
<screen>&prompt.sudo;aa-enforce [<replaceable>プログラム_1</replaceable> <replaceable>プログラム_2</replaceable> ...]</screen>
     </listitem>
     <listitem>
      <para>プログラムがパス内に存在しない場合は、下記のようにフルパスで指定します:</para>
<screen>&prompt.sudo;aa-enforce /sbin/<replaceable>プログラム_1</replaceable></screen>
     </listitem>
     <listitem>
      <para>また、プロファイルが <replaceable>/etc/apparmor.d</replaceable> 内に存在しない場合は、下記のように配置場所を指定します:</para>
<screen>&prompt.sudo;aa-enforce -d <replaceable>プロファイルのパス     プログラム_1</replaceable></screen>
     </listitem>
     <listitem>
      <para><replaceable>/sbin/program1</replaceable> のプロファイルを指定したい場合は、下記のように入力して実行します:</para>
<screen>&prompt.sudo;aa-enforce /etc/apparmor.d/sbin.<replaceable>プログラム_1</replaceable></screen>
     </listitem>
    </itemizedlist>
    <para>上述のコマンドはいずれも、指定したプロファイルやプログラムを強制モードに切り替える処理を行います。</para>
    <para>プログラム名やプロファイル名を入力しない場合は、入力を求められます。また、 <replaceable>プロファイルのパス</replaceable> を指定した場合は、既定のプロファイル保存先である <filename>/etc/apparmor.d</filename> を変更し、既定の場所以外にあるプロファイルを使用することができます。</para>
    <para>パラメータには、複数のプログラムやプロファイルを指定することができます。また、プログラムの指定の際、これをフルパスで指定しないと、 <command>aa-complain</command> は <envar>$PATH</envar> 内を検索して、プログラムの場所を判断します。</para>
    <tip>
     <title>&yast; を利用したプロファイルの切り替えについて</title>
     <para>&yast; には、不平モードと強制モードを切り替えることのできるグラフィカルなフロントエンドが用意されています。詳しくは <xref linkend="sec-apparmor-yast-manage-profmodes"/> をお読みください。</para>
    </tip>
   </sect3>
   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-exec">
    <title>aa-exec: 指定したプロファイルによるプログラムの制限</title>
    <para><command>aa-exec</command> は指定したプロファイルやプロファイルネームスペースで、特定のプログラムを起動するためのツールです。プロファイルとネームスペースの両方を指定した場合、プログラムは新しいネームスペース内のプロファイルで制限を受けることになります。ネームスペースのみを指定した場合は、現在の制限内にあるプロファイル名を使用します。いずれも指定しない場合は、コマンドは標準的なプロファイル適用をそのまま使用します (つまり、 <command>aa-exec</command> コマンドを使用せずに起動した場合と同じ動作になります) 。</para>
    <para>子マントのオプションについて、詳しくは <command>man 8 aa-exec</command> にあるマニュアルページをお読みください。</para>
   </sect3>
   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-genprof">
    <title>aa-genprof: プロファイルの生成</title>
    <para><command>aa-genprof</command> は &aa; におけるプロファイル生成ユーティリティです。プロファイルが存在しない場合は、指定したプログラムに対して <command>aa-autodep</command> を実行して近似プロファイルを作成したあと、プロファイルを不平モードに設定して &aa; を再読み込みさせ、ログに印を付けます。その後、ユーザに対してプログラムを実行し、その機能を一通り試すように依頼します。コマンドの書式は下記のとおりです:</para>
<screen>&prompt.sudo;aa-genprof [ -d <replaceable>プロファイルのパス</replaceable> ]  <replaceable>プログラム</replaceable></screen>
    <para>Apache Web サーバである httpd2-prefork に対してプロファイルを作成したい場合は、 &rootuser; で下記のように実行します:</para>
    <procedure>
     <step>
      <para><command>systemctl stop apache2</command> と入力して実行します。</para>
     </step>
     <step>
      <para>続けて <command>aa-genprof httpd2-prefork</command> と入力して実行します。</para>
      <para>すると、 <command>aa-genprof</command> は下記のような処理を行います:</para>
      <orderedlist spacing="normal">
       <listitem>
        <para>お使いのシェルの PATH 環境変数を利用して httpd2-prefork のフルパスを取得します。もちろん最初からフルパスで指定してもかまいません。 &productname; では、このプログラムのフルパスは <phrase><filename>/usr/sbin/httpd2-prefork</filename></phrase> であるはずです。</para>
       </listitem>
       <listitem>
        <para>まずは httpd-prefork に対して、既存のプロファイルが存在していないかどうかを確認します。プロファイルが存在した場合はそれを更新しようとします。存在しない場合は、 <xref linkend="sec-apparmor-commandline-profiling-summary"/> で説明している <command>aa-autodep</command> を使用して、プロファイルを作成します。</para>
       </listitem>
       <listitem>
        <para>指定したプログラムに対するプロファイルを学習 (不平) モードに設定し、プロファイルへの違反を記録するだけで、禁止を行わないようにします。違反の記録は、たとえば下記のようになります (<filename>/var/log/audit/audit.log</filename> 内に記録されます):</para>
<screen>type=APPARMOR_ALLOWED msg=audit(1189682639.184:20816): \
apparmor="DENIED" operation="file_mmap" parent=2692 \
profile="/usr/sbin/httpd2-prefork//HANDLING_UNTRUSTED_INPUT" \
name="/var/log/apache2/access_log-20140116" pid=28730 comm="httpd2-prefork" \
requested_mask="::r" denied_mask="::r" fsuid=30 ouid=0</screen>
        <para>監査デーモンを動作させていない場合、 &aa; のイベントは &systemd; ジャーナルに直接記録されます (詳しくは <xref linkend="cha-journalctl"/> をお読みください):</para>
<screen>Sep 13 13:20:30 K23 kernel: audit(1189682430.672:20810): \
apparmor="DENIED" operation="file_mmap" parent=2692 \
profile="/usr/sbin/httpd2-prefork//HANDLING_UNTRUSTED_INPUT" \
name="/var/log/apache2/access_log-20140116" pid=28730 comm="httpd2-prefork" \
requested_mask="::r" denied_mask="::r" fsuid=30 ouid=0</screen>
        <para><command>dmesg</command> コマンドを利用して表示することもできます:</para>
<screen>audit(1189682430.672:20810): apparmor="DENIED" \
operation="file_mmap" parent=2692 \
profile="/usr/sbin/httpd2-prefork//HANDLING_UNTRUSTED_INPUT" \
name="/var/log/apache2/access_log-20140116" pid=28730 comm="httpd2-prefork" \
requested_mask="::r" denied_mask="::r" fsuid=30 ouid=0</screen>
       </listitem>
       <listitem>
        <para>ログ内に印を付けて、作業の開始位置判断とします。たとえば下記のように出力されます:</para>
<screen>
Sep 13 17:48:52 figwit root: GenProf: e2ff78636296f16d0b5301209a04430d</screen>
       </listitem>
      </orderedlist>
     </step>
     <step>
      <para>ツール側から問い合わせメッセージが表示されたら、もう 1 つの端末ウインドウを開いてプロファイルを作成するアプリケーションを起動し、可能な限り様々な処理を実施させます。これにより、学習モード下でプログラムが必要とする様々なファイルやディレクトリなどにアクセスすることになります。この例では、たとえば新しい端末ウインドウを開いて、 <command>systemctl start apache2</command> と入力し実行します。</para>
     </step>
     <step>
      <para>様々なプログラムの機能を利用したあとは、 <command>aa-genprof</command> の端末ウインドウ内で下記のような入力を行うことができます:</para>
      <itemizedlist mark="bullet" spacing="normal">
       <listitem>
        <para><keycap>S</keycap> と入力すると、 <command>aa-genprof</command> は先ほど印を付けた箇所以降のシステムログを検索する処理を実施します。ログ内に何らかのシステムイベントが見つかった場合、 &aa; はそれらを読み込んで判断します。これにより、セキュリティプロファイルを生成するにあたっての様々な質問を生成します。</para>
       </listitem>
       <listitem>
        <para><keycap>F</keycap> と入力すると、ツールを終了することができます。</para>
       </listitem>
      </itemizedlist>
      <note>
       <para>ハット (hat) を追加するように求められた場合は、 <xref linkend="cha-apparmor-hat"/> をお読みください。</para>
      </note>
     </step>
     <step>
      <para>あとは下記に示す 2 種類の質問に答えていきます:</para>
      <itemizedlist mark="bullet" spacing="normal">
       <listitem>
        <para>プロファイル対象のプログラムから特定のリソースへのアクセスが要求されたものの、プロファイル内には許可が書かれていないもの (詳しくは <xref linkend="ex-apparmor-commandline-profiling-summary-genprof-learn"/> をお読みください) 。</para>
       </listitem>
       <listitem>
        <para>プロファイル対象のプログラムからプログラムが実行されたものの、セキュリティドメイン遷移が定義されていないもの (詳しくは <xref linkend="ex-apparmor-commandline-profiling-summary-genprof-perms"/> をお読みください) 。</para>
       </listitem>
      </itemizedlist>
      <para>いずれの分類の質問であっても、プロファイル内にリソースやプログラムを追加するために回答しなければならない質問になります。 <xref linkend="ex-apparmor-commandline-profiling-summary-genprof-learn"/> や <xref linkend="ex-apparmor-commandline-profiling-summary-genprof-perms"/> には、それぞれ質問の例が示されています。続く手順では、それぞれの質問に対する回答方法を示しています。</para>
      <itemizedlist mark="bullet" spacing="normal">
       <listitem>
        <para>実行権限の取り扱いは複雑です。それぞれ表示された内容に対して、どのような実行権限を与えるのかを決定しなければなりません:</para>
        <example xml:id="ex-apparmor-commandline-profiling-summary-genprof-learn">
         <title>学習モードの例外: 特定のリソースへのアクセス制御</title>
<screen>Reading log entries from /var/log/audit/audit.log.
Updating AppArmor profiles in /etc/apparmor.d.

Profile:  /usr/sbin/cupsd
Program:  cupsd
Execute:  /usr/lib/cups/daemon/cups-lpd
Severity: unknown

(I)nherit / (P)rofile / (C)hild / (N)ame / (U)nconfined / (X)ix / (D)eny / Abo(r)t / (F)inish</screen>
        </example>
        <variablelist>
         <varlistentry>
          <term>Inherit (ix)</term>
          <listitem>
           <para>子プロセスに対して親と同じプロファイルを適用し、親と同じアクセス権限を継承するように指定します。このモードは、制限を受けているプログラムから他のプログラムを呼び出す際、新しい許可を設定したくない場合や、既にある許可を失いたくない場合に指定します。このモードは、たとえば <command>/usr/bin/mail</command> のメールクライアントが <command>less</command> をページャとして使用する場合など、 <emphasis>ヘルパーアプリケーション</emphasis> のようなプログラムを呼び出す際にしばしば用いられます。</para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>Profile (px/Px)</term>
          <listitem>
           <para>子プロセスに対して、カーネル内に読み込まなければならない独自のプロファイルを適用するように指定します。プロファイルが存在しない場合、子プロセスの実行はアクセス拒否として失敗します。これは、親プログラムから DNS の参照やお使いのシステムの MTA を介したメール送信など、グローバルサービスを実行するような場合に有用です。</para>
           <para><guimenu>profile with clean exec</guimenu> (クリーン実行付きプロファイル) (Px) を選択すると、子プロセスに環境変数を渡す際、その実行に影響があるような環境変数を削除して実行することができます。</para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>Child (cx/Cx)</term>
          <listitem>
           <para>サブプロファイルへの遷移を設定します。 px/Px での遷移と同様ですが、子プロファイルへの遷移という点が異なります。</para>
           <para><guimenu>profile with clean exec</guimenu> (クリーン実行付きプロファイル) (Cx) を選択すると、子プロセスに環境変数を渡す際、その実行に影響があるような環境変数を削除して実行することができます。</para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>Unconfined (ux/Ux)</term>
          <listitem>
           <para>子プロセスに対して &aa; のプロファイルを適用せず、リソースに対する制限を行わないようにします。</para>
           <para><guimenu>unconfined with clean exec</guimenu> (クリーン実行付き無制限) (Ux) を選択すると、子プロセスに環境変数を渡す際、その実行に影響があるような環境変数を削除して実行することができます。ただし、制限を取り外してしまうことはセキュリティ面での脆弱性を生む行為であり、危険であることに注意してください。そのため、それ以外の選択肢ではどうしても解決できない場合にのみ、指定してください。</para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>mmap (m)</term>
          <listitem>
           <para>この許可を設定すると、そのプロファイルが適用されるプログラムに対して、 mmap システムコールの際に <envar>PROT_EXEC</envar> フラグを設定できるようになります。これにより、データとして割り当てたメモリを実行することができるようになります。プロファイル生成時に求められた場合にのみ、この許可を設定してください。</para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>Deny</term>
          <listitem>
           <para>プロファイルに対して <literal>deny</literal> ルールを追加して、指定したディレクトリパス項目に対するアクセスを明示的に禁止するようにします。 &aa; はそのまま次のイベントの処理に移ります。</para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>Abort</term>
          <listitem>
           <para><command>aa-logprof</command> を中止し、ここまでに入力したルール変更を破棄して終了します。プロファイルの修正は行いません。</para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>Finish</term>
          <listitem>
           <para><command>aa-logprof</command> を終了し、ここまでに入力したルール変更を保存し、プロファイルの修正を行います。</para>
          </listitem>
         </varlistentry>
        </variablelist>
       </listitem>
       <listitem>
        <para><xref linkend="ex-apparmor-commandline-profiling-summary-genprof-perms"/> には、 &aa; がグロブパターン <filename>/var/run/nscd/*</filename> を利用して読み込みアクセスを許可し、一般的な Apache 関連のアクセスルールをカバーするため、抽象を使用しようとしている様子を示しています。</para>
        <example xml:id="ex-apparmor-commandline-profiling-summary-genprof-perms">
         <title>学習モードの例外: 項目に対する許可の設定</title>
<screen><?dbfo keep-together="always"?>Profile:  /usr/sbin/httpd2-prefork
Path:     /var/run/nscd/dbSz9CTr
Mode:     r
Severity: 3

  1 - /var/run/nscd/dbSz9CTr
 [2 - /var/run/nscd/*]

(A)llow / [(D)eny] / (G)lob / Glob w/(E)xt / (N)ew / Abo(r)t / (F)inish / (O)pts
Adding /var/run/nscd/* r to profile.

Profile:  /usr/sbin/httpd2-prefork
Path:     /proc/11769/attr/current
Mode:     w
Severity: 9

 [1 - #include &lt;abstractions/apache2-common&gt;]
  2 - /proc/11769/attr/current
  3 - /proc/*/attr/current

(A)llow / [(D)eny] / (G)lob / Glob w/(E)xt / (N)ew / Abo(r)t / (F)inish / (O)pts
Adding #include &lt;abstractions/apache2-common&gt; to profile.
</screen>
        </example>
        <para>&aa; には様々なパスやインクルードが用意されています。選択肢の番号を入力することで必要なオプションを選択し、次のステップに進むことができます。</para>
        <note>
         <para>&aa; のメニューでは、一部の選択肢のみが表示される場合もあります。</para>
        </note>
        <variablelist>
         <varlistentry>
          <term><literal>#include</literal></term>
          <listitem>
           <para>これは &aa; プロファイル内の記述で、他のファイルを参照するように設定するためのディレクティブです。これにより、他のファイル内に書かれているアクセス権を振り込むことができるようになります。また、 include を使用することで、複数のプログラムでアクセス許可の設定を共有することもできます。この仕組みにより、プロファイルのサイズを小さくすることにも繋がります。 include を使用するように提案された場合は、提案を受け入れるのがよいでしょう。</para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>グロブ版</term>
          <listitem>
           <para>次の手順で説明しているように、 <guimenu>Glob</guimenu> を選択することでアクセスすることができます。グロブの書式に関する詳細は、 <xref linkend="sec-apparmor-profiles-glob"/> をお読みください。</para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>実際のパス</term>
          <listitem>
           <para>プログラムが必要とするパスを直接指定して、正しく動作するように設定します。</para>
          </listitem>
         </varlistentry>
        </variablelist>
        <para>パスまたはインクルードの設定を行った後は、 <guimenu>Allow</guimenu> (許可) または <guimenu>Deny</guimenu> (拒否) を選択して、対応する項目を &aa; のプロファイルに追加します。表示されたディレクトリパスの項目で問題があるとお考えの場合は、 <guimenu>Glob</guimenu> (グロブ) を選択することもできます。</para>
        <para>学習モードで生成された項目を処理し、プロファイルにする方法には、下記のものがあります:</para>
        <variablelist>
         <varlistentry>
          <term>単に <keycap function="enter"/> を押す</term>
          <listitem>
           <para>選択したディレクトリパスに対して、アクセスを許可します。</para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>Allow</term>
          <listitem>
           <para>選択したディレクトリパスの項目に対して、アクセスを許可します。 &aa; では、アクセスモードの提案も行います。詳しくは <xref linkend="sec-apparmor-profiles-perm"/> をお読みください。</para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>Deny</term>
          <listitem>
           <para>指定したディレクトリパスの項目に対して、プログラムからのアクセスを拒否します。 &aa; はそのまま次のイベントの処理に移ります。</para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>New</term>
          <listitem>
           <para>このイベントに対応するルールを独自に作成します。ここでは、正規表現による指定にも対応しています。表現の指定がイベントの要件と合致しない場合、 &aa; は確認メッセージを表示して再入力を求めます。</para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>Glob</term>
          <listitem>
           <para>ワイルドカードを利用して幅広くマッチするルールを作成します。提示されたパスのうちのいずれかを選択するには、パスの前に示されている数字を入力して進めます。</para>
           <para>グロブの書式に関する詳細は、 <xref linkend="sec-apparmor-profiles-glob"/> をお読みください。</para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>Glob w/Ext</term>
          <listitem>
           <para>元のディレクトリパス情報を変更して、ファイル名の拡張子だけをマッチングルールとして残すグロブを生成します。たとえば <filename>/etc/apache2/file.ext</filename> というファイルへのアクセスであった場合、ファイル名の部分だけをワイルドカードにして <filename>/etc/apache2/*.ext</filename> のような形式に変更します。これにより、特定のディレクトリ内にある同じ拡張子 (<literal>.ext</literal>) のファイルすべてに対して、許可するルールを作成することができます。</para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>Abort</term>
          <listitem>
           <para><command>aa-logprof</command> を中止し、ここまでに入力したルール変更を破棄して終了します。プロファイルの修正は行いません。</para>
          </listitem>
         </varlistentry>
         <varlistentry>
          <term>Finish</term>
          <listitem>
           <para><command>aa-logprof</command> を終了し、ここまでに入力したルール変更を保存し、プロファイルの修正を行います。</para>
          </listitem>
         </varlistentry>
        </variablelist>
       </listitem>
      </itemizedlist>
     </step>
     <step>
      <para><command>vi</command> を利用してプロファイルの表示や編集を行いたい場合は、端末ウインドウ内で <command>vi /etc/apparmor.d/</command> <replaceable>プロファイル名</replaceable> のように入力して実行してください。 vim 内で &aa; のプロファイルを編集するにあたり、文法ハイライト機能を有効化したい場合は、 <command>:syntax on</command> と入力してから <command>:set syntax=apparmor</command> と入力します。 vim および文法ハイライト機能に関する詳細については、 <xref linkend="sec-apparmor-commandline-profiling-summary-vim"/> をお読みください。</para>
     </step>
     <step>
      <para><command>systemctl reload apparmor</command> コマンドを実行し、 &aa; を再起動して、プロファイルセットを再読み込みします。これにより、新しく作成したプロファイルが読み込まれるようになります。</para>
     </step>
    </procedure>
    <para>グラフィカルなフロントエンドを利用して &aa; のプロファイルを作成する場合と同様に、 &yast; のプロファイル追加ウイザードや <command>aa-genprof</command> でも、 <filename>/usr/share/apparmor/extra-profiles</filename> 内にあるローカルプロファイルを使用することができます。</para>
    <para>ローカルリポジトリにあるプロファイルを使用するには、下記のようにして行います:</para>
    <procedure>
     <step>
      <para>上述の手順で <command>aa-genprof</command> を起動します。</para>
      <para><command>aa-genprof</command> が無効化されているローカルプロファイルを検出すると、端末ウインドウ内に下記のような内容が表示されます:</para>
<screen>Profile: /usr/bin/opera

 [1 - Inactive local profile for /usr/bin/opera]

[(V)iew Profile] / (U)se Profile / (C)reate New Profile / Abo(r)t / (F)inish</screen>
     </step>
     <step>
      <para>提示されたプロファイルを使用するには <keycap>U</keycap> ( <guimenu>Use Profile</guimenu> ) と入力し、上述のプロファイル生成手順に従って続けます。</para>
      <para>有効化する前にプロファイルの内容を確認したい場合は、 <keycap>V</keycap> ( <guimenu>View Profile</guimenu> ) と入力します。</para>
      <para>既存のプロファイルを無視したい場合は、 <keycap>C</keycap> ( <guimenu>Create New Profile</guimenu> ) と入力して、上述のプロファイル生成手順で、何もない状態からプロファイルを作成していきます。</para>
     </step>
     <step>
      <para>すべての作業が終わったら、 <keycap>F</keycap> ( <guimenu>Finish</guimenu> ) と入力すると、変更点を保存して終了することができます。</para>
     </step>
    </procedure>
   </sect3>
   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-logprof">
    <title>aa-logprof: システムログのスキャン</title>
    <para><command>aa-logprof</command> は不平モードや強制モードで記録され、 <filename>/var/log/audit/audit.log</filename> 内もしくは &systemd; ジャーナル (詳しくは <xref linkend="cha-journalctl"/> を参照) 内に直接保存されているログを処理して、 &aa; のセキュリティプロファイル内の新しい項目を生成することができる対話型ツールです。</para>
    <para><command>aa-logprof</command> を実行すると、まずは不平モードや強制モードで記録されたログファイルを読み込んで処理し、既存のプロファイルセット内でカバーされていない新しいセキュリティイベントが見つかった場合に、既存のプロファイルを変更するための確認メッセージを表示します。 <command>aa-logprof</command> では、ログファイル内の情報からプログラムの挙動を確認します。</para>
    <para>制限を受けているプログラムが fork() したり他のプログラムを起動したりした場合、 <command>aa-logprof</command> はそれを検出すると、 fork() したプログラムや他のプログラムに対して適用すべき実行モードを尋ねます。実行モードは <emphasis>ix</emphasis> , <emphasis>px</emphasis> , <emphasis>Px</emphasis> , <emphasis>ux</emphasis> , <emphasis>Ux</emphasis> , <emphasis>cx</emphasis> , <emphasis>Cx</emphasis> のいずれか、もしくは名前付きプロファイルで、指定した実行モードで子プロセスを開始することになります。子プロセス向けのプロファイルが個別に存在する場合は、既定の選択肢は <emphasis>Px</emphasis> になります。逆に、プロファイルが存在しない場合は <emphasis>ix</emphasis> になります。個別のプロファイルが存在する子プロセスに対しては、 <command>aa-autodep</command> が実行され、動作中であれば &aa; 内に読み込まれるようになります。</para>
    <para><command>aa-logprof</command> が終了すると、プロファイルは変更した内容に応じて更新されます。 &aa; が有効化されていれば、更新されたプロファイルが読み込まれ。セキュリティイベントを生成したプロセスが現在も null-XXXX プロファイル (不平モードで作成される一時的なプロファイル) で動作していれば、対応する適切なプロファイルが適用されるようになります。</para>
    <para><command>aa-logprof</command> を実行するには、 &rootuser; でログインしている状態で、端末ウインドウ内で <command>aa-logprof</command> と入力します。また、 <command>aa-logprof</command> では下記のようなオプションを指定することができます:</para>
    <variablelist>
     <varlistentry>
      <term><command>aa-logprof -d</command> <replaceable>プロファイルディレクトリのパス</replaceable></term>
      <listitem>
       <para>プロファイルが標準ディレクトリ <filename>/etc/apparmor.d/</filename> 以外の場所にある場合は、上記のようにしてフルパスを指定します。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><command>aa-logprof -f</command> <replaceable>ログファイルのパス</replaceable></term>
      <listitem>
       <para>ログファイルが標準ディレクトリパス <filename>/var/log/audit/audit.log</filename> 以外の場所にある場合は、上記のようにしてログファイルのフルパスを指定します。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><command>aa-logprof -m "ログファイル内に記録するマーカー文字列"</command></term>
      <listitem>
       <para>システムログ内に、 <command>aa-logprof</command> が後から参照できるように、開始点の印を付けます。 <command>aa-logprof</command> は、指定した印以前のイベントはすべて無視します。なお、印内にスペースが含まれている場合は、正しく引用符で括らなければなりません。たとえば下記のようになります:</para>
<screen>&prompt.root;aa-logprof -m "17:04:21"</screen>
       <para>もしくは</para>
<screen>&prompt.root;aa-logprof -m e2ff78636296f16d0b5301209a04430d</screen>
      </listitem>
     </varlistentry>
    </variablelist>
    <para><command>aa-logprof</command> はログを読み込んでから、それぞれのイベントに対して処理方法を尋ねます。それぞれの質問には番号付きのリストが示され、プロファイル内にどれを追加すべきなのかを尋ねます。</para>
    <para>既定では、 <command>aa-logprof</command> は <filename>/etc/apparmor.d/</filename> 内にプロファイルがあるものとして検索します。また、 <command>aa-logprof</command> でプロファイルを更新する場合、 &rootuser; での実行であれば十分です。ただし、長期にわたるログを読み込ませる場合など、過去の分も含めた複数のログファイルを処理させたい場合は、 <command>zcat -f `ls -1tr</command> <replaceable>ログファイルのパス/*</replaceable> ` | aa-logprof -f - のように実行してください。</para>
   </sect3>
   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-logprof-ex1">
    <title>aa-logprof 例 1</title>
    <para>下記の例では、 httpd2-prefork が <filename>/etc/group</filename> ファイルへのアクセスを行う際、 <command>aa-logprof</command> 側でどのような対応を行うのかについて説明しています。なお、 <literal>[]</literal> は既定値を表しています。</para>
    <para>この例では、 <command>/etc/group</command> へのアクセスは httpd2-prefork による名前サービスの処理時に発生します。適切な回答は <literal>1</literal> で、これによってあらかじめ定義された &aa; ルールを取り込むことができるようになります。 <literal>1</literal> を選択すると、 <literal>#include</literal> によって名前サービス向けのルール一式が取り込まれ、以後に発生する DNS 関連のイベントすべてを解決することができるようになります。また、 DNS 関連の設定が変わったような場合でも、このファイルを修正すれば済むことになりますので、関連する多数のプロファイルを編集せずに済むことになります。</para>
<screen>
Profile:  /usr/sbin/httpd2-prefork
Path:     /etc/group
New Mode: r

[1 - #include &lt;abstractions/nameservice&gt;]
 2 - /etc/group
[(A)llow] / (D)eny / (N)ew / (G)lob / Glob w/(E)xt / Abo(r)t / (F)inish
</screen>
    <para>下記のいずれかの回答をすることができます:</para>
    <variablelist>
     <varlistentry>
      <term>単に <keycap function="enter"/> を押す</term>
      <listitem>
       <para>既定の動作を実行します。この例では、表示されているディレクトリパスに対して、アクセスを許可します。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Allow</term>
      <listitem>
       <para>表示されているディレクトリパスに対して、アクセスを許可します。詳しくは <xref linkend="sec-apparmor-profiles-perm"/> をお読みください。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Deny</term>
      <listitem>
       <para>表示されているディレクトリパスに対して、恒久的にアクセスを拒否します。 &aa; はそのまま次のイベントの処理に移ります。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>New</term>
      <listitem>
       <para>このイベントに対応するルールを独自に作成します。ここでは、正規表現による指定にも対応しています。表現の指定がイベントの要件と合致しない場合、 &aa; は確認メッセージを表示して再入力を求めます。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Glob</term>
      <listitem>
       <para>ワイルドカードを利用して幅広くマッチするルールを作成します。提示されたパスのうちのいずれかを選択するには、パスの前に示されている数字を入力して進めます。</para>
       <para>グロブの書式に関する詳細は、 <xref linkend="sec-apparmor-profiles-glob"/> をお読みください。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Glob w/Ext</term>
      <listitem>
       <para>元のディレクトリパス情報を変更して、ファイル名の拡張子だけをマッチングルールとして残すグロブを生成します。たとえば <filename>/etc/apache2/file.ext</filename> というファイルへのアクセスであった場合、ファイル名の部分だけをワイルドカードにして <filename>/etc/apache2/*.ext</filename> のような形式に変更します。これにより、特定のディレクトリ内にある同じ拡張子 (<literal>.ext</literal>) のファイルすべてに対して、許可するルールを作成することができます。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Abort</term>
      <listitem>
       <para><command>aa-logprof</command> を中止し、ここまでに入力したルール変更を破棄して終了します。プロファイルの修正は行いません。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Finish</term>
      <listitem>
       <para><command>aa-logprof</command> を終了し、ここまでに入力したルール変更を保存し、プロファイルの修正を行います。</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-logprof-ex2">
    <title>aa-logprof 例 2</title>
    <para>この例では、 vsftpd に対するプロファイル作成時の質問を示しています:</para>
<screen>Profile:  /usr/sbin/vsftpd
Path:     /y2k.jpg
<!-- will probably be displayed as /path/to/chroot/y2k.jpg nowadays
See also the chroot_relative flag.
         -->
New Mode: r

[1 - /y2k.jpg]

(A)llow / [(D)eny] / (N)ew / (G)lob / Glob w/(E)xt / Abo(r)t / (F)inish
</screen>
    <para>この質問には、いくつかの興味深い点があります。まず vsftpd がルートディレクトリに対するアクセス許可を求めています。ところが、 &productname; では、 vsftpd は既定で <filename>/srv/ftp</filename> 内のコンテンツを提供しているはずです。 <!-- without chroot_relative, you'll get /path/to/chroot/y2k.jpg, so you need to rewrite the whole section --> これは、 vsftpd が chroot 環境 (jail) で動作していることによるもので、プログラム上のコードではルートディレクトリにアクセスしているつもりであるため、 &aa; のログファイル内でも元のパスではなく、ルートディレクトリであるかのように表示されてしまいます。</para>
    <para>次に興味深い点はファイル名です。 FTP クライアントから、ディレクトリ内にあるすべての JPEG ファイルに対するアクセスを許可したい場合は、 <guimenu>Glob w/Ext</guimenu> を選んで <literal>/*.jpg</literal> に変更して処理を進めます。これにより、個別の <literal>.jpg</literal> ファイルに対していちいち許可を設定する必要がなくなるほか、将来的に <literal>.jpg</literal> ファイルが増えたような場合でも、問題なく対応できることになります。</para>
    <para>最後に興味深い点は、 FTP ファイル全体に対する点です。 <guimenu>Glob</guimenu> を選んで、 <command>aa-logprof</command> からの提案を <filename>/y2k.jpg</filename> から <filename>/*</filename> に変更します。それ以外にも、ディレクトリツリー全体に対してアクセスを許可してしまう方法もあります。この場合は <guimenu>New</guimenu> を選んで <literal>/**.jpg</literal> のように入力します。これにより、ディレクトリツリー全体に対して、すべての <literal>.jpg</literal> ファイルへのアクセスを許可します。それ以外にも、 <filename>/**</filename> と指定する方法もあります。この場合は、ディレクトリツリー全体のすべてのファイルに対して、アクセスを許可することになります。</para>
    <para>ここまでは、読み込みアクセスに関する話題を扱ってきました。書き込みアクセスについても同様に対応することができますが、書き込みアクセスを付与するにあたっては、より保守的に (制限を厳しくする方向に) 設定しておくことをお勧めします。また、実行アクセスについてはさらに複雑です。詳しい例については <xref linkend="ex-apparmor-commandline-profiling-summary-genprof-learn"/> をお読みください。</para>
    <para>下記の例では、 <filename>/usr/bin/mail</filename> に対してプロファイルを作成していて、 <command>/usr/bin/mail</command> が <command>/usr/bin/less</command> をヘルパーアプリケーションとして起動した際の質問の例です。 <command>/usr/bin/less</command> は、長いメールメッセージを <quote>ページ分割</quote> するために使用しています:</para>
<screen>
/usr/bin/nail -&gt; /usr/bin/less
(I)nherit / (P)rofile / (C)hild / (N)ame / (U)nconfined / (X)ix / (D)eny
</screen>
    <note>
     <para><filename>/usr/bin/mail</filename> の実際の実行ファイルが <filename>/usr/bin/nail</filename> となっていますが、これはスペルミスなどではなく、実際に存在するプログラム名です。</para>
    </note>
    <para>プログラム <filename>/usr/bin/less</filename> は非常にシンプルなプログラムで、 1 画面以上にわたる長いテキストをスクロールしながら読むことができるプログラムです。このような便利な仕組みであることから、 <filename>/usr/bin/mail</filename> でも使用されているわけです。なお、 <command>less</command> はシンプルな仕組みでありながらも、同時に巨大でパワフルなプログラムでもあり、 <command>tar</command> や <command>rpm</command> などのプログラムをさらに呼び出すこともできます。</para>
    <tip>
     <para>tar ファイルや RPM ファイルに対して <command>less</command> を実行すると、その中に含まれている内容を表示することができます。</para>
    </tip>
    <para>ですが、メールメッセージを読む際には、 <command>rpm</command> コマンドを自動的に実行してしまうのは危険です。なぜなら、 RPM プログラムにはシステムにプログラムをインストールしたり、プログラムを修正したりする機能が含まれるため、 Microsoft* Outlook でよく見つかるようなウイルス感染の経路になってしまうためです。そのため、ここで選ぶべき選択肢は <guimenu>Inherit</guimenu> (継承) になります。継承を指定すると、 <filename>/usr/bin/mail</filename> から実行される状況下で less プログラムを実行する場合、 <filename>/usr/bin/mail</filename> のプロファイルを適用し続けることになります。これには下記の 2 つの意味が含まれます:</para>
    <itemizedlist mark="bullet" spacing="normal">
     <listitem>
      <para><filename>/usr/bin/less</filename> に対する基本的なファイルアクセス設定を、 <filename>/usr/bin/mail</filename> のプロファイル内に追加する必要があります。</para>
     </listitem>
     <listitem>
      <para><command>tar</command> や <command>rpm</command> などのヘルパーアプリケーションを <filename>/usr/bin/mail</filename> に登録することを避けることで、 <filename>/usr/bin/mail</filename> が <filename>/usr/bin/less</filename> を実行しても、 &aa; が存在すれば非常に安全に動作することになります。もう 1 つの選択肢としては Cx 実行モードがあります。実行モードに関する詳細は、 <xref linkend="sec-apparmor-profiles-exec"/> をお読みください。</para>
     </listitem>
    </itemizedlist>
    <para>その他の状況下では、 <guimenu>Profile</guimenu> オプションを選択する必要があるかもしれません。この場合は、 <command>aa-logprof</command> に対して下記のような効果があります:</para>
    <itemizedlist mark="bullet" spacing="normal">
     <listitem>
      <para>現在のプロファイル内に px/Px モードのルールが書き込まれ、子プロセスに対する独自のプロファイルに遷移するようになります。</para>
     </listitem>
     <listitem>
      <para><command>aa-logprof</command> が子プロセスに対するプロファイルを作成し、構築を開始します。これは親プロセスのプロファイルと同じ方法で行われ、親プロセスのイベントは親のプロファイルに、子プロセスのイベントは子のプロファイルにそれぞれ保存されるようになります。 <command>aa-logprof</command> での質問は、両方をあわせて表示します。このプロファイルは、単独のプログラムを子として実行した場合にも当てはまります。</para>
     </listitem>
    </itemizedlist>
    <para>制限を受けているプログラムが fork() したり他のプログラムを起動したりした場合、 <command>aa-logprof</command> はそれを検出すると、 fork() したプログラムや他のプログラムに対して適用すべき実行モードを尋ねます。実行モードは継承 (<emphasis>ix</emphasis>) , プロファイル (<emphasis>px</emphasis> , <emphasis>Px</emphasis>) , 無制限 (<emphasis>ux</emphasis> , <emphasis>Ux</emphasis>) , 子プロセス (<emphasis>cx</emphasis> , <emphasis>Cx</emphasis>) , 名前付きプロファイルのほか、実行拒否を設定することもできます。</para>
    <para>子プロセス向けのプロファイルが個別に存在する場合は、既定の選択肢はプロファイル (<emphasis>Px</emphasis>) になります。逆に、プロファイルが存在しない場合は継承 (<emphasis>ix</emphasis>) になります。許可の詳細については、 <xref linkend="sec-apparmor-profiles-perm"/> をお読みください。</para>
    <para>プロファイル (<emphasis>px</emphasis> , <emphasis>Px</emphasis>) を選択した場合、子プロセス側のプログラムでは、独自のプロファイルを使用して実行します。この場合、親プロセスから子プロセスに対して環境変数を継承するにあたって、危険性のある変数の内容を削除するかどうかを尋ねます。削除するよう選択した場合は、プロファイル内に <literal>Px</literal> が書き込まれ、削除しないように選択した場合は、プロファイル内に <literal>px</literal> が書き込まれます。なお、プロファイル実行モードを選択した場合の既定値は <literal>Px</literal> です。</para>
    <para>無制限実行モードは非推奨であり、そのプログラムに対するプロファイルをどうやっても作成することができず、それ以外の選択肢が存在しない場合にのみ選択すべきものです。無制限実行モードを選択すると、警告メッセージが表示されて確認を求められますので、 <guimenu>Yes</guimenu> を入力して進めてください。また、危険性のある変数の内容を削除するかどうかを尋ねます。削除するよう選択した場合は、プロファイル内に <literal>Ux</literal> が書き込まれ、削除しないように選択した場合は、プロファイル内に <literal>ux</literal> が書き込まれます。なお、無制限実行モードを選択した場合の既定値は <literal>Ux</literal> です。</para>
    <important>
     <title>無制限での実行について</title>
     <para><literal>ux</literal> や <literal>Ux</literal> の使用は非常に危険です。子プロセスの実行に際して、セキュリティ面でのポリシー強制が一切働かなくなります。</para>
    </important>
   </sect3>
<!-- that all said:
         the aa-genprof and aa-logprof section have large parts of identical content.
         What about merging them?
         -->
   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-unconfined">
    <title>aa-unconfined: 保護されていないプロセスの識別</title>
    <para><command>aa-unconfined</command> コマンドは、お使いのシステムで開いているネットワークポートを調べ、システム内に読み込まれているプロファイルセットと比較を行い、 &aa; のプロファイルのないネットワークサービスを報告します。このコマンドの実行にあたっては &rootuser; の権限が必要となるほか、 &aa; のプロファイルで制限を受けていない状況下で実行する必要があります。</para>
    <para><command>aa-unconfined</command> は <filename>/proc</filename> ファイルシステムから実行ファイルの情報を取得する仕組みであるため、 &rootuser; で実行しなければなりません。また、下記のような競合状態が発生する可能性があります:</para>
    <itemizedlist mark="bullet" spacing="normal">
     <listitem>
      <para>コマンドの実行時に削除された実行ファイルがある場合、その扱いを誤ることがあります</para>
     </listitem>
     <listitem>
<!-- bnc#880080: netstat vs. ss/ip -->
      <para><command>netstat(8)</command> を実行してから後続のチェックを行うまでに、プロセスが終了したような場合、その扱いを誤ることがあります</para>
     </listitem>
    </itemizedlist>
    <note>
     <para>このプログラムは TCP と UDP を使用するプロセスのみを一覧表示します。その他のプロトコルを利用する通信については無視されます。そのため、フォレンジック用途にはお使いいただけません。検証環境内で、ネットワークにアクセスするプロセスに対してプロファイルを作成する用途にのみお使いください。</para>
    </note>
   </sect3>
   <sect3 xml:id="commandline-profiling-summary-aa-notify">
    <title>aa-notify</title>
    <para><command>aa-notify</command> は、お使いのデスクトップ環境内に &aa; の通知を表示することのできる、便利なユーティリティです。 &aa; のログファイルを直接調査したくなく、代わりにポリシーに違反した通知のみをデスクトップに表示したい場合に有用です。 &aa; のデスクトップ通知機能を有効化するには、下記のように入力して <command>aa-notify</command> を実行します:</para>
<screen>&prompt.sudo;aa-notify -p -u <replaceable>ユーザ名</replaceable> --display <replaceable>ディスプレイ番号</replaceable></screen>
    <para>ここで、 <replaceable>ユーザ名</replaceable> には現在ログインしているユーザのユーザ名を、 <replaceable>ディスプレイ番号</replaceable> には現在使用しているディスプレイのディスプレイ番号 (例: <literal>:0</literal>) をそれぞれ指定します。プログラムは裏で動作する仕組みで、拒否イベントが発生するたびに通知が表示されます。</para>
    <tip>
     <para>なお、現在使用している X Window のディスプレイ番号は、 <literal>$DISPLAY</literal> という環境変数に保存されていますので、 <literal>--display $DISPLAY</literal> と入力することで、現在のディスプレイをそのまま使用することができます。</para>
    </tip>
    <figure>
     <title><command>GNOME 内での aa-notify メッセージ</command></title>
     <mediaobject>
      <imageobject role="fo">
       <imagedata fileref="aa-notify.png" width="75%"/>
      </imageobject>
      <imageobject role="html">
       <imagedata fileref="aa-notify.png" width="40%"/>
      </imageobject>
     </mediaobject>
    </figure>
    <para>なお、 <option>-s <replaceable>日数</replaceable></option> というオプションを指定すると、指定した過去日数分の通知概要を表示することができます。 <command>aa-notify</command> の詳細については、 <command>man 8 aa-notify</command> で表示されるマニュアルページをお読みください。</para>
   </sect3>
   <sect3 xml:id="sec-apparmor-commandline-profiling-summary-vim">
    <title>apparmor.vim</title>
    <para>vim テキストエディタ向けの文法ハイライト機能を利用することで、 &aa; のプロファイル内にある様々な機能を色付きで表示することができます。 vim と vim 向けの &aa; 文法モードでは、プロファイルの意味を色で識別することができますので、端末ウインドウ内で入力を行いながら内容を確認することができます。</para>
    <para>vim で &aa; のプロファイルを編集している際、文法ハイライト機能を有効にするには、 <literal>:syntax on</literal> を実行してから <literal>:set syntax=apparmor</literal> を実行します。また、 vim 側でファイルを正しく &aa; のプロファイルとして認識しているかどうかを調べるには、下記の内容をプロファイルの末尾に入力します:</para>
<screen># vim:ft=apparmor</screen>
    <para>"\n  <!-- NOTE: already translated i nprevious paragraph. -->\n"</para>
    <tip>
     <para>なお、 <command>vim</command> を利用した場合、 <filename>/etc/apparmor.d/</filename> ディレクトリ内のファイルを編集すると、自動的に文法ハイライト機能が有効化されます。</para>
    </tip>
    <para>この機能を利用した場合は、 vim ではプロファイルの内容を下記のように表示します:</para>
    <variablelist>
     <varlistentry>
      <term>青</term>
      <listitem>
       <para>コメント</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>白</term>
      <listitem>
       <para>通常の読み込みアクセスの行</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>茶</term>
      <listitem>
       <para>ケーパビリティの項目および不平モードのフラグ</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>黄</term>
      <listitem>
       <para>書き込み権のあるアクセスの行</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>緑</term>
      <listitem>
       <para>実行許可 (ix もしくは px) を与えている行</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>赤</term>
      <listitem>
       <para>無制限アクセス (ux) を設定している行</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>赤い背景</term>
      <listitem>
       <para>正しく &aa; モジュールに読み込むことのできない、文法エラーのある行</para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>vim での文法ハイライト機能について、詳しくは <systemitem>apparmor.vim</systemitem> および <systemitem>vim</systemitem> の各マニュアルページ、もしくは vim エディタ内から <option>:help syntax</option> と入力して実行することで表示される、ヘルプをお読みください。また、文法ハイライトに関わる設定は、 <filename>/usr/share/vim/current/syntax/apparmor.vim.</filename> 内にあります。</para>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-apparmor-commandline-filenames">
  <title>主なファイル名とディレクトリ</title>

  <para>下記の一覧には、 &aa; フレームワークで使用される最も重要なファイルとディレクトリが列挙されています。プロファイルを手作業で管理もしくはトラブルシューティングしたい場合は、下記のファイルやディレクトリについて知っておく必要があります:</para>

  <variablelist>
   <varlistentry>
    <term><filename>/sys/kernel/security/apparmor/profiles</filename></term>
    <listitem>
     <para>現在読み込まれているプロファイルセットを表示することのできる、仮想ファイルです。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><filename>/etc/apparmor/</filename></term>
    <listitem>
     <para>&aa; の設定ファイルの配置場所です。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><filename>/usr/share/apparmor/extra-profiles</filename></term>
    <listitem>
     <para>&aa; に同梱されているプロファイルのローカルリポジトリです。既定では有効化されていません。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><filename>/etc/apparmor.d/</filename></term>
    <listitem>
     <para>プロファイルを保存するためのディレクトリです。なお、パス内の <literal>/</literal> を <literal>.</literal> に置き換えたファイル名 (ただしルートディレクトリを表す冒頭の <literal>/</literal> は除きます) で作成するのが慣習となっています。これにより、プロファイルのファイル名を分かりやすくしています。たとえば <filename>/usr/sbin/smbd</filename> というプログラム向けのプロファイルは、 <filename>usr.sbin.smbd</filename> というファイル名になっています。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><filename>/etc/apparmor.d/abstractions/</filename></term>
    <listitem>
     <para>抽象を保存しておくためのディレクトリです。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><filename>/etc/apparmor.d/program-chunks/</filename></term>
    <listitem>
     <para>プログラムチャンクを保存しておくためのディレクトリです。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><filename>/proc/*/attr/current</filename></term>
    <listitem>
     <para>このファイルの内容を出力することで、そのプロセスに対する制限状況と、適用されているプロファイルを表示することができます。また、 <command>ps</command> <option>auxZ</option> のように入力して実行すると、この情報を自動的に取得することができます。</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
</chapter>
