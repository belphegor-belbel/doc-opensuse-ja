<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter [
<!ENTITY % entities SYSTEM "entity-decl.ent">
%entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha-libvirt-storage">
 <title>ストレージの管理</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
  </dm:docmanager>
 </info>
 <para>&vmhost; 自身で &vmguest; を管理する場合は、 &vmhost; 内のファイルシステムに自由にアクセスすることができるため、 &vmguest; に対する仮想ハードディスクを作成したり割り当てたりすることは問題なく行なうことができます。ただし、 &vmguest; をリモートから管理している場合は、そうもいきません。このような理由から、 &libvirt; には <quote>ストレージプール</quote> と呼ばれる機能が用意され、これを利用してリモートのマシンからアクセスできる仕組みを用意しています。</para>
 <tip>
  <title>CD/DVD ISO イメージについて</title>
  <para>リモートから &vmhost; 内にある CD/DVD の ISO イメージにアクセスできるようにするには、それらをストレージプール内に配置する必要があります。</para>
 </tip>
 <para>&libvirt; では、ボリュームとプールと呼ばれる 2 種類のストレージが提供されています。</para>
 <variablelist>
  <varlistentry>
   <term>ストレージボリューム</term>
   <listitem>
    <para>ストレージボリュームは、ゲストに割り当てることのできるストレージデバイスを意味します。具体的には、仮想ディスクや CD/DVD 、もしくはフロッピィディスクの各イメージです。 &vmhost; 側では、ブロックデバイス (パーティション、論理ボリュームなど) やファイルをストレージボリュームとして使用することができます。</para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>ストレージプール</term>
   <listitem>
    <para>ストレージプールは &vmhost; 内でのストレージリソースで、デスクトップマシンでのネットワークストレージのような使い方で使用することができる仕組みです。 &vmhost; 側では下記のようなものをストレージプールとして使用することができます:</para>
    <variablelist>
     <varlistentry>
      <term>ファイルシステムのディレクトリ ( <guimenu>dir</guimenu> )</term>
      <listitem>
       <para>イメージファイルを提供するディレクトリです。このディレクトリ内には、対応するディスク形式 (raw, qcow2) のイメージのほか、 ISO イメージを配置することもできます。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>物理ディスクデバイス ( <guimenu>disk</guimenu> )</term>
      <listitem>
       <para>物理ディスク全体をストレージとして使用します。各ボリューム向けにパーティションを作成し、プールに追加することができます。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>事前フォーマット型ブロックデバイス ( <guimenu>fs</guimenu> )</term>
      <listitem>
       <para>ファイルシステムのディレクトリのプール ( <guimenu>dir</guimenu> ) と同じ仕組みでパーティションを指定します。 <guimenu>dir</guimenu> との違いは、 <guimenu>dir</guimenu> はあらかじめマウントされているディレクトリを対象とするのに対して、こちらは &libvirt; がマウントを処理する点に違いがあります。</para>
      </listitem>
     </varlistentry>
<!-- <varlistentry>
      <term>GlusterFS device (<guimenu>gluster</guimenu>)</term>
      <listitem>
       <para>
        ...
       </para>
      </listitem>
     </varlistentry> -->
     <varlistentry>
      <term>iSCSI ターゲット (iscsi)</term>
      <listitem>
       <para>iSCSI ターゲット上にプールを作成します。 &libvirt; でプールを使用するには、まずボリュームに対していったんログインする必要があります。ボリュームへのログインには、 &yast; の <guimenu>iSCSI イニシエータ</guimenu> をお使いください。 <phrase os="sles">詳しくは <xref linkend="book-storage"/> をお読みください。</phrase> iSCSI プール内でのボリューム作成には対応していませんので、既存の論理ユニット番号 (LUN) がそのままボリュームを表わすことになります。それぞれのボリューム (=LUN) を使用するには、あらかじめ正しい (もしくは空の) パーティションテーブルもしくはディスクラベルを作成しておく必要があります。作成していない場合は、 <command>fdisk</command> を利用して下記のように入力して実行し、作成を行なってください:</para>
<screen>~ # fdisk -cu /dev/disk/by-path/ip-&wsIip;:3260-iscsi-iqn.2010-10.com.example:[...]-lun-2

fdisk (util-linux 2.31.1) へようこそ。
ここで設定した内容は、書き込みコマンドを実行するまでメモリのみに保持されます。
書き込みコマンドを使用する際は、注意して実行してください。

デバイスには認識可能なパーティション情報が含まれていません。
新しい DOS ディスクラベルを作成しました。識別子は 0xc15cdc4e です。

コマンド (m でヘルプ): w
パーティション情報が変更されました。
ディスクを同期しています。</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>LVM ボリュームグループ (logical)</term>
      <listitem>
       <para>LVM ボリュームグループをプールとして使用します。あらかじめ設定しておいたボリュームグループを使用することができるほか、使用するデバイスを指定してグループを作成することもできます。ストレージボリュームは、ボリューム内でのパーティションとして作成されます。</para>
       <warning>
        <title>LVM ベースのプールの削除について</title>
        <para>ストレージマネージャ内で LVM ベースのプールを削除した場合、ボリュームグループについても削除が行なわれます。この操作により、プール内に存在する全てのデータを復元不可能な形で削除することになります。あらかじめご注意ください。</para>
       </warning>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>マルチパスデバイス ( <guimenu>mpath</guimenu> )</term>
      <listitem>
       <para>現時点でのマルチパスサポートは、既存のデバイスをゲストに割り当てるまでの範囲に限られています。 &libvirt; の中からマルチパスボリュームを作成したり設定したりする作業には対応していません。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>ネットワークで公開されているディレクトリ ( <guimenu>netfs</guimenu> )</term>
      <listitem>
       <para>ファイルシステムのディレクトリのプール ( <guimenu>dir</guimenu> ) と同じ仕組みでネットワークディレクトリを指定します。 <guimenu>dir</guimenu> はあらかじめマウントされているディレクトリを対象とするのに対して、こちらは &libvirt; がマウントを処理する点に違いがあります。なお、対応するプロトコルは NFS と GlusterFS です。</para>
      </listitem>
     </varlistentry>
<!-- <varlistentry>
      <term>Rados Block Device (<guimenu>rbd</guimenu>)</term>
      <listitem>
       <para>
        ...
       </para>
      </listitem>
     </varlistentry> -->
<!-- <varlistentry>
      <term>Sheepdog distributed storage system (<guimenu>sheepdog</guimenu>)</term>
      <listitem>
       <para>
        ...
       </para>
      </listitem>
     </varlistentry> -->
     <varlistentry>
      <term>SCSI ホストアダプタ ( <guimenu>scsi</guimenu> )</term>
      <listitem>
       <para>iSCSI ターゲットとほぼ同様の手順で SCSI ホストアダプタを使用します。デバイス名は <filename>/dev/sd<replaceable>X</replaceable></filename> ではなく、 <filename>/dev/disk/by-*</filename> にあるほうのデバイス名を指定しておくことをお勧めします。それは、後者のほうが環境変更 (ハードディスクの追加や削除) にうまく対応できるためです。 iSCSI プール内でのボリューム作成には対応していません。その代わり、既存の LUN (Logical Unit Number; 論理ユニット番号) がボリュームそのものを表わします。</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </listitem>
  </varlistentry>
 </variablelist>
 <warning>
  <title>セキュリティ面の考慮事項について</title>
  <para>データの損失や破壊を防ぐため、 &vmhost; 内でストレージプールとして使用している LVM ボリュームグループや iSCSI ターゲットなどを、 &vmhost; 自身が使用してはなりません。これらのリソースは &vmhost; 自身からアクセスする必要はありませんし、 &vmhost; 自身がマウントすることもありません。 &libvirt; 側がそれらを行ないます。</para>
  <para>また、 &vmhost; 側でラベルを利用してパーティションをマウントしてはなりません。特定の状況下では、 &vmguest; 内のパーティションに同じ名前が設定されてしまう場合があり、これによって本来のパーティションとは異なるものをマウントしてしまう危険性があるためです。</para>
 </warning>
 <sect1 xml:id="sec-libvirt-storage-vmm">
  <title>&vmm; を利用したストレージの管理</title>

  <para>&vmm; にはグラフィカルなインターフェイスであるストレージマネージャが用意されていますので、ここからストレージボリュームやプールを管理することができます。ストレージマネージャにアクセスするには、接続を選択したあと、マウスの右ボタンを押して <guimenu>詳細</guimenu> を選択するか、もしくは <menuchoice> <guimenu>編集</guimenu> <guimenu>接続の詳細</guimenu> </menuchoice> を選択します。その後 <guimenu>ストレージ</guimenu> タブを選択します。</para>

  <informalfigure>
   <mediaobject>
    <imageobject role="fo">
     <imagedata fileref="virt_virt-manager_storage.png" width="60%" format="PNG"/>
    </imageobject>
    <imageobject role="html">
     <imagedata fileref="virt_virt-manager_storage.png" width="60%" format="PNG"/>
    </imageobject>
   </mediaobject>
  </informalfigure>

  <sect2 xml:id="sec-libvirt-storage-vmm-addpool">
   <title>ストレージプールの追加</title>
   <para>ストレージプールを追加するには、下記の手順を実施します:</para>
   <procedure>
    <step>
     <para>左下にある <guimenu>プールの追加</guimenu> を押します。 <guimenu>新しいストレージプールを追加</guimenu> のダイアログが表示されます。</para>
    </step>
    <step>
     <para>まずはプールに対して設定する <guimenu>名前</guimenu> を入力します。ここでは英数字のほか、 <literal>_-.</literal> の各記号を使用することができます) 。あとは <guimenu>種類</guimenu> を選択して <guimenu>進む</guimenu> を押します。</para>
     <informalfigure>
      <mediaobject>
       <imageobject role="fo">
        <imagedata fileref="virt_virt-manager_storage_add.png" width="60%" format="PNG"/>
       </imageobject>
       <imageobject role="html">
        <imagedata fileref="virt_virt-manager_storage_add.png" width="60%" format="PNG"/>
       </imageobject>
      </mediaobject>
     </informalfigure>
    </step>
    <step>
     <para>続くダイアログでは、必要な詳細を設定します。ここで入力すべきデータは、選択したプールの種類によって異なります:</para>
     <variablelist>
      <varlistentry>
       <term><emphasis role="bold">種類</emphasis> = <guimenu>dir</guimenu> の場合</term>
       <listitem>
        <itemizedlist mark="bullet" spacing="normal">
         <listitem>
          <para><guimenu>ターゲットパス</guimenu> : 既存のディレクトリを指定します。</para>
         </listitem>
        </itemizedlist>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis role="bold">種類</emphasis> = <guimenu>disk</guimenu> の場合</term>
       <listitem>
        <itemizedlist mark="bullet" spacing="normal">
         <listitem>
          <para><guimenu>ターゲットパス</guimenu> : デバイスの存在するディレクトリを指定します。通常は <filename>/dev</filename> のままでかまいません。</para>
         </listitem>
         <listitem>
          <para><guimenu>フォーマット</guimenu> : デバイスのパーティションテーブルの形式を指定します。通常は <guimenu>auto</guimenu> (自動) のままでかまいませんが、それ以外の値を指定したい場合は、 &vmhost; 内で <command>parted</command> <option>-l</option> を実行して出力された内容から指定します。</para>
         </listitem>
         <listitem>
          <para><guimenu>ソースパス</guimenu> : デバイスのパスを指定します。環境変更 (ハードディスクの追加や削除) にうまく対応するため、シンプルな <filename>/dev/sd<replaceable>X</replaceable></filename> という形式ではなく、 <filename>/dev/disk/by-*</filename> の形式で指定しておくことをお勧めします。なお、ディスク内のパーティションではなく、ディスク全体を表わすデバイスパスを指定してください。</para>
         </listitem>
         <listitem>
          <para><guimenu>プールを構築</guimenu> : このオプションを選択すると、デバイスのフォーマットを行ないます。フォーマットを行なうと、その中にあるデータが全て失われることになりますので、注意して指定してください。</para>
         </listitem>
        </itemizedlist>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis role="bold">種類</emphasis> = <guimenu>fs</guimenu> の場合</term>
       <listitem>
        <itemizedlist mark="bullet" spacing="normal">
         <listitem>
          <para><guimenu>ターゲットパス</guimenu> : &vmhost; のファイルシステム内でのマウントポイントを指定します。</para>
         </listitem>
         <listitem>
          <para><guimenu>フォーマット</guimenu> : デバイスのファイルシステムの形式を指定します。通常は <guimenu>auto</guimenu> (自動) のままでかまいません。</para>
         </listitem>
         <listitem>
          <para><guimenu>ソースパス</guimenu> : デバイスファイルのパスを指定します。環境変更 (ハードディスクの追加や削除) にうまく対応するため、シンプルな <filename>/dev/sd<replaceable>X</replaceable></filename> という形式ではなく、 <filename>/dev/disk/by-*</filename> の形式で指定しておくことをお勧めします。</para>
         </listitem>
        </itemizedlist>
       </listitem>
      </varlistentry>
<!-- <varlistentry>
       <term><emphasis role="bold">Type</emphasis> <guimenu>gluster</guimenu></term>
       <listitem>
        <itemizedlist>
         <listitem>
          <para>
           <guimenu>Host Name</guimenu>: ...
          </para>
         </listitem>
         <listitem>
          <para>
           <guimenu>Source Name</guimenu>: ...
          </para>
         </listitem>
         <listitem>
          <para>
           <guimenu>Source Path</guimenu>: ...
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </varlistentry>-->
      <varlistentry>
       <term><emphasis role="bold">種類</emphasis> = <guimenu>iscsi</guimenu> の場合</term>
       <listitem>
        <para>&vmhost; 内で下記のコマンドを実行することで、必要なデータを取得することができます:</para>
<screen>&prompt.sudo;iscsiadm --mode node</screen>
        <para>上記を実行すると、下記の形式で iSCSI ボリュームの一覧を出力します。それぞれ太字の部分をデータとして使用します:</para>
<screen><emphasis role="bold">IP_アドレス</emphasis>:ポート,TPGT <emphasis role="bold">ターゲット名_(IQN)</emphasis></screen>
        <itemizedlist mark="bullet" spacing="normal">
         <listitem>
          <para><guimenu>ターゲットパス</guimenu> : デバイスファイルを含むディレクトリを指定します。 <literal>/dev/disk/by-path</literal> (既定値) もしくは <literal>/dev/disk/by-id</literal> のいずれかを指定してください。</para>
         </listitem>
         <listitem>
          <para><guimenu>ホスト名</guimenu> : iSCSI サーバのホスト名または IP アドレスを指定します。</para>
         </listitem>
         <listitem>
          <para><guimenu>ソースパス</guimenu> : iSCSI のターゲット名を指定します。</para>
         </listitem>
        </itemizedlist>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis role="bold">種類</emphasis> = <guimenu>logical</guimenu> の場合</term>
       <listitem>
        <itemizedlist mark="bullet" spacing="normal">
         <listitem>
          <para><guimenu>ターゲットパス</guimenu> : 既存のボリュームグループを使用する場合は、既存のデバイスパスを指定します。新しい LVM ボリュームグループを構築する場合は、 <filename>/dev</filename> ディレクトリ内に存在していないデバイス名を指定します。</para>
         </listitem>
         <listitem>
          <para><guimenu>ソースパス</guimenu> : 既存のボリュームグループを使用する場合は、何も指定しないでください。新しく作成する場合は、ここにデバイス名を入力します。</para>
         </listitem>
         <listitem>
          <para><guimenu>プールを構築</guimenu> : 新しいボリュームグループを作成する場合にのみ選択します。</para>
         </listitem>
        </itemizedlist>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis role="bold">種類</emphasis> = <guimenu>mpath</guimenu> の場合</term>
       <listitem>
        <itemizedlist mark="bullet" spacing="normal">
         <listitem>
          <para><guimenu>ターゲットパス</guimenu> : 現時点でのマルチパスサポートは、全てのマルチパスデバイスを利用可能な状態にするだけです。そのため、ここに指定した文字列は無視されるため、何を入力してもかまいません。ただし、何らかの値を指定しておかないと、 XML パーサの処理が失敗してしまいます。</para>
         </listitem>
        </itemizedlist>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis role="bold">種類</emphasis> = <guimenu>netfs</guimenu> の場合</term>
       <listitem>
        <itemizedlist mark="bullet" spacing="normal">
         <listitem>
          <para><guimenu>ターゲットパス</guimenu> : &vmhost; のファイルシステム内でのマウントポイントを指定します。</para>
         </listitem>
         <listitem>
          <para><guimenu>ホスト名</guimenu> : ネットワークファイルシステムを公開するサーバのホスト名または IP アドレスを指定します。</para>
         </listitem>
         <listitem>
          <para><guimenu>ソースパス</guimenu> : 公開されているサーバ内のディレクトリを指定します。</para>
         </listitem>
        </itemizedlist>
       </listitem>
      </varlistentry>
<!-- <varlistentry>
       <term><emphasis role="bold">Type</emphasis> <guimenu>rbd</guimenu></term>
       <listitem>
        <itemizedlist>
         <listitem>
          <para>
           <guimenu>Host Name</guimenu>: ...
          </para>
         </listitem>
         <listitem>
          <para>
           <guimenu>Source Name</guimenu>: ...
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </varlistentry>-->
      <varlistentry>
       <term><emphasis role="bold">種類</emphasis> = <guimenu>scsi</guimenu> の場合</term>
       <listitem>
        <itemizedlist mark="bullet" spacing="normal">
         <listitem>
          <para><guimenu>ターゲットパス</guimenu> : デバイスファイルを含むディレクトリを指定します。 <literal>/dev/disk/by-path</literal> (既定値) もしくは <literal>/dev/disk/by-id</literal> のいずれかを指定してください。</para>
         </listitem>
         <listitem>
          <para><guimenu>ソースパス</guimenu> : SCSI アダプタの名前を指定します。</para>
         </listitem>
        </itemizedlist>
       </listitem>
      </varlistentry>
<!-- <varlistentry>
       <term><emphasis role="bold">Type</emphasis> <guimenu>rbd</guimenu></term>
       <listitem>
        <itemizedlist>
         <listitem>
          <para>
           <guimenu>Host Name</guimenu>: ...
          </para>
         </listitem>
         <listitem>
          <para>
           <guimenu>Source Name</guimenu>: ...
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </varlistentry>-->
     </variablelist>
     <note>
      <title>ファイルの参照について</title>
      <para>リモートから操作している場合、 <guimenu>参照</guimenu> ボタンによる参照機能を利用することはできません。</para>
     </note>
    </step>
    <step>
     <para><guimenu>完了</guimenu> を押すと、ストレージプールへの追加が行なわれます。</para>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec-libvirt-storage-vmm-manage">
   <title>ストレージプールの管理</title>
   <para>&vmm; のストレージマネージャを使用することで、プール内にボリュームを作成したりそれらを削除したりすることができます。既存のストレージプールに対しては、一時的に無効化を行なったり、恒久的に削除を行なうこともできます。ただし、プールの基本設定の変更に関しては、現在 &suse; ではサポートしていません。</para>
   <sect3 xml:id="sec-libvirt-storage-vmm-manage-pool">
    <title>プールの開始／停止／削除</title>
    <para>ストレージプールの目的は、リモートから &vmguest; を管理する際、 &vmguest; に追加することのできる &vmhost; 内のブロックデバイスを提供することにあります。一時的にリモートからアクセスできないように無効化したい場合は、ストレージマネージャ内の左下にある <guimenu>プールの停止</guimenu> ボタンを押してください。停止されたプールは <guimenu>状態: 停止</guimenu> となり、一覧表示ではグレーで表示されるようになります。規定では、新しく作成されたプールは自動的に開始され、 &vmhost; 内でも <guimenu>自動起動</guimenu> が設定されます。</para>
    <para>無効化したプールを開始して、リモートからアクセスできるように戻すには、同様にストレージマネージャ内の左下にある <guimenu>プールの開始</guimenu> を押します。</para>
    <note>
     <title>プールの状態と割り当て済みのボリュームの関係について</title>
     <para>プールから &vmguest; に対して割り当てられているボリュームは、プールの状態 ( <guimenu>動作中</guimenu> や <guimenu>停止</guimenu>) に関わらず、常に利用できる状態になります。プールの状態は、 &vmguest; をリモートから管理する際に、ボリュームを割り当てることができるかどうかにのみ影響します。</para>
    </note>
    <para>プールを恒久的にアクセスできないように設定したい場合は、ストレージマネージャ内の左下にある <guimenu>プールの削除</guimenu> を押します。なお、プールの削除は無効化したプールに対してのみ実施することができます。また、プールを削除しても &vmhost; 内のコンテンツは物理的に削除されません。プールの設定を削除するだけです。ただし、プールを削除する際には、特に LVM のボリュームグループベースのものである場合には、特に注意して実施してください。</para>
    <warning xml:id="deleting-storage-pools">
     <title>ストレージプールの削除</title>
     <para><emphasis>ローカル</emphasis> のファイルシステムやパーティション、ディスクをベースにしたストレージプールを削除する場合、その時点でプールから &vmguest; に割り当て済みのボリュームが存在していても、特に何も影響がありません。</para>
     <para>逆に、 iSCSI, SCSI, LVM グループ, ネットワークで公開されているディレクトリの場合は、プールを削除すると &vmguest; からもアクセスができなくなります。ボリュームそれ自身は削除されることはありませんが、 &vmhost; からこれらのリソースにはアクセスしなくなります。</para>
     <para>iSCSI, SCSI, ネットワークで公開されているディレクトリについては、新しいプールを作成し直すか、ホストシステムから直接これらにアクセスすることで、再度アクセスができるようになります。</para>
     <para>LVM グループベースのストレージプールの場合、 LVM グループの定義も削除されることになりますので、ホストシステム内でも LVM グループの存在が削除されることになります。設定は復元不可能であり、プール内に存在していた全てのボリュームについても失われることになります。</para>
    </warning>
   </sect3>
   <sect3 xml:id="sec-libvirt-storage-vmm-manage-volume-add">
    <title>ストレージプールへのボリュームの追加</title>
    <para>&vmm; では、プールの種類がマルチパス, iSCSI, SCSI であるものを除き、全てのストレージプール内にボリュームを作成することができます。これらのプール内のボリュームは LUN と等価なものであり、 &libvirt; 内では変更することができません。</para>
    <procedure>
     <step>
      <para>新しいボリュームはストレージマネージャを利用して作成することができるほか、 &vmguest; に新しいストレージデバイスを追加する際に設定することもできます。いずれの場合であっても、左側のパネルでストレージプールを選択して、 <guimenu>新しいボリュームの作成</guimenu> を押します。</para>
     </step>
     <step>
      <para>まずはイメージの <guimenu>名前</guimenu> を入力し、イメージの形式を選択します。</para>
      <para>なお、 &suse; では現在 <literal>raw</literal> , <literal>qcow2</literal> の 2 種類のみをサポート対象としております。また、後者は LVM グループベースのプールでは選択できません。</para>
      <para>次に <guimenu>最大容量</guimenu> を指定します。ここでは、ディスクイメージが最大でどのサイズまで大きくするのかを指定します。 <literal>qcow2</literal> を選択していない場合は、これにあわせて初期の <guimenu>割り当て</guimenu> サイズを設定します。これらの値が異なる場合、必要に応じてサイズの増加する <emphasis>スパース</emphasis> <!-- NOTE: add description for "sparse" --> (実際のサイズと表示上のサイズが異なるファイルのこと) イメージを作成することになります。</para>
      <para><literal>qcow2</literal> を選択した場合、ベースイメージとなる <guimenu>バッキングストア</guimenu> (<quote>バッキングファイル</quote> と呼ばれることもあります) を設定することができます。バッキングストアを使用してイメージを作成すると、 <literal>qcow2</literal> ファイルには、ベースとなるイメージに対して変更された箇所のみが記録されるようになります。</para>
     </step>
     <step>
      <para><guimenu>完了</guimenu> を押してボリュームの作成を完了します。</para>
     </step>
    </procedure>
   </sect3>
   <sect3 xml:id="sec-libvirt-storage-vmm-manage-volume-delete">
    <title>ストレージプールからのボリュームの削除</title>
    <para>ボリュームの削除はストレージマネージャからのみ実施することができます。ボリュームを選択して <guimenu>ボリュームの削除</guimenu> を押してください。表示された確認メッセージに対して <guimenu>はい</guimenu> を押すと、削除が行なわれます。</para>
    <warning>
     <title>使用中でもボリュームを削除できてしまう問題について</title>
     <para>動作中の &vmguest; が使用しているボリュームであっても、削除そのものは実施できてしまいます。削除されたボリュームを復元する手段は用意されていません。</para>
     <para>&vmguest; で使用されているかどうかを確認するには、ストレージマネージャ内の <guimenu>使用中</guimenu> 列をご覧ください。</para>
    </warning>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-libvirt-storage-virsh">
  <title><command>virsh</command> を利用したストレージの管理</title>

  <para>コマンドラインからのストレージ管理は、 <command>virsh</command> で行なうことができます。しかしながら、ストレージプールの作成は &suse; ではサポートしていません。そのため、本章ではプールの開始や停止、削除に関して、およびボリュームの管理に関して説明しています。</para>

  <para>プールやボリュームの管理に使用する <command>virsh</command> のサブコマンドを全て表示したい場合は、それぞれ <command>virsh help pool</command> (プール管理) および <command>virsh help volume</command> (ボリューム管理) を実行してください。</para>

  <sect2 xml:id="sec-libvirt-storage-virsh-list-pools">
   <title>プールとボリュームの一覧表示</title>
   <para>現在有効化されている全てのプールを一覧表示するには、下記のコマンドを実行します。無効化されているプールも表示したい場合は、 <option>--all</option> を追加してください:</para>
<screen>&prompt.user;virsh pool-list --details</screen>
   <para>特定のプールに関する詳細情報を表示したい場合は、 <literal>pool-info</literal> サブコマンドを使用します:</para>
<screen>&prompt.user;virsh pool-info <replaceable>POOL</replaceable></screen>
   <para>規定では、ボリュームはプールごとにしか表示することができません。特定のプール内にある全てのボリュームを表示するには、下記のコマンドを実行します。</para>
<screen>&prompt.user;virsh vol-list --details <replaceable>プール名</replaceable></screen>
   <para>現時点では <command>virsh</command> コマンドを使用した場合、ゲストで使用されているかどうかを表示する手段が用意されていません。下記の手順を実施することで、 &vmguest; が使用している全てのプール内のボリュームを表示することができます。</para>
   <procedure xml:id="pro-libvirt-storage-virsh-list-vols">
    <title>&vmhost; で現在使用されている全てのストレージボリュームの一覧表示</title>
    <step>
     <para>下記の内容でファイルを作成して保存し、 XSLT スタイルシートを作成します。ファイル名はたとえば ~/libvirt/guest_storage_list.xsl のように設定します:</para>
<screen>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:output method="text"/&gt;
  &lt;xsl:template match="text()"/&gt;
  &lt;xsl:strip-space elements="*"/&gt;
  &lt;xsl:template match="disk"&gt;
    &lt;xsl:text&gt;  &lt;/xsl:text&gt;
    &lt;xsl:value-of select="(source/@file|source/@dev|source/@dir)[1]"/&gt;
    &lt;xsl:text&gt;&amp;#10;&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</screen>
    </step>
    <step>
     <para>シェルで下記のコマンドを実行します。なお、ゲストの XML 定義は全て既定の場所 ( <filename>/etc/libvirt/qemu</filename> ) に存在しているものとします。また、 <command>xsltproc</command> コマンドは、 <systemitem class="resource">libxslt</systemitem> パッケージ内に含まれています。</para>
<screen>SSHEET="$HOME/libvirt/guest_storage_list.xsl"
cd /etc/libvirt/qemu
for FILE in *.xml; do
  basename $FILE .xml
  xsltproc $SSHEET $FILE
done</screen>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec-libvirt-storage-virsh-start-pools">
   <title>プールの開始／停止／削除</title>
   <para>プールの開始や停止、削除を行なうには、 <command>virsh</command> の pool サブコマンドを使用します。下記では <replaceable>プール名</replaceable> の箇所にプールの名前もしくは UUID を入力してください:</para>
   <variablelist>
    <varlistentry>
     <term>プールの停止</term>
     <listitem>
<screen>&prompt.user;virsh pool-destroy <replaceable>プール名</replaceable></screen>
      <note>
       <title>プールの状態と割り当て済みのボリュームの関係について</title>
       <para>プールから &vmguest; に対して割り当てられているボリュームは、プールの状態 ( <guimenu>動作中</guimenu> や <guimenu>停止</guimenu>) に関わらず、常に利用できる状態になります。プールの状態は、 &vmguest; をリモートから管理する際に、ボリュームを割り当てることができるかどうかにのみ影響します。</para>
      </note>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>プールの削除</term>
     <listitem>
<screen>&prompt.user;virsh pool-delete <replaceable>プール名</replaceable></screen>
      <warning>
       <title>ストレージプールの削除</title>
       <para><xref linkend="deleting-storage-pools"/> をお読みください。</para>
      </warning>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>プールの開始</term>
     <listitem>
<screen>&prompt.user;virsh pool-start <replaceable>プール名</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>プールの自動開始の有効化</term>
     <listitem>
<screen>&prompt.user;virsh pool-autostart <replaceable>プール名</replaceable></screen>
      <para>自動開始を行なうものとしてマークしたプールは、 &vmhost; の起動時に開始されます。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>プールの自動開始の無効化</term>
     <listitem>
<screen>&prompt.user;virsh pool-autostart <replaceable>プール名</replaceable> --disable</screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec-libvirt-storage-virsh-add-volumes">
   <title>ストレージプールへのボリュームの追加</title>
   <para><command>virsh</command> では、ストレージプールにボリュームを追加する方法として、 2 種類のものを用意しています。 1 つは <literal>vol-create</literal> と<literal>vol-create-from</literal> のサブコマンドを利用した、 XML 定義ファイルを使用する方法、もう 1 つは <literal>vol-create-as</literal> サブコマンドでのコマンドラインパラメータによる指定です。前者に関しては &suse; のサポート対象外となっておりますので、本章では後者の <literal>vol-create-as</literal> サブコマンドについて説明しています。</para>
   <para>既存のプールにボリュームを追加するには、下記のようなコマンドを入力して実行します:</para>
<screen>&prompt.user;virsh vol-create-as <replaceable>プール名</replaceable><co xml:id="co-vol-create-as-pool"/><replaceable>名前</replaceable><co xml:id="co-vol-create-as-name"/> 12G --format<co xml:id="co-vol-create-as-capacity"/><replaceable>raw|qcow2</replaceable><co xml:id="co-vol-create-as-format"/> --allocation 4G<co xml:id="co-vol-create-as-alloc"/></screen>
   <calloutlist>
    <callout arearefs="co-vol-create-as-pool">
     <para>ボリュームを追加するプールの名前を指定します。</para>
    </callout>
    <callout arearefs="co-vol-create-as-name">
     <para>ボリュームの名前を指定します。</para>
    </callout>
    <callout arearefs="co-vol-create-as-capacity">
     <para>イメージのサイズを指定します。それぞれ k (キロバイト), M (メガバイト), G (ギガバイト), T (テラバイト) の各単位接尾辞を指定することができます。</para>
    </callout>
    <callout arearefs="co-vol-create-as-format">
     <para>ボリュームの形式を指定します。 &suse; では現在、 <literal>raw</literal> , <literal>qcow2</literal> のみをサポート対象としております。</para>
    </callout>
    <callout arearefs="co-vol-create-as-alloc">
     <para>任意指定のパラメータです。既定では <command>virsh</command> は、必要に応じてサイズの増加する <emphasis>スパース</emphasis> <!-- NOTE: add description for "sparse" -->(実際のサイズと表示上のサイズが異なるファイルのこと) ファイルを作成しますが、ここでサイズを指定することで、初期状態での割り当てサイズを指定します (この例では 4 ギガバイトを割り当てます) 。なお、 k (キロバイト), M (メガバイト), G (ギガバイト), T (テラバイト) の各単位接尾辞を指定することができます。</para>
     <para>このパラメータを指定しない場合、初期状態では全くサイズを割り当てないスパースイメージファイルを作成します。また、スパースではない <!-- NOTE: add description for "non-sparse" -->(実際のサイズと表示上のサイズが同じ) ファイルを作成したい場合は、イメージと同じサイズ (この例では <literal>12G</literal>) を指定してください。</para>
    </callout>
   </calloutlist>
   <sect3 xml:id="sec-libvirt-storage-virsh-add-volumes-clone">
    <title>既存のボリュームの複製</title>
    <para>プールにボリュームを追加するもう 1 つの方法としてあげられるのが、既存のボリュームの複製です。この場合、新しいボリュームは元のボリュームと同じプール内に作成されます。</para>
<screen>&prompt.user;virsh vol-clone <replaceable>既存のボリューム名</replaceable><co xml:id="co-vol-clone-existing"/><replaceable>新しいボリューム名</replaceable><co xml:id="co-vol-clone-new"/> --pool <replaceable>プール名</replaceable><co xml:id="co-vol-clone-pool"/></screen>
    <calloutlist>
     <callout arearefs="co-vol-clone-existing">
      <para>複製元のボリューム名を指定します。</para>
     </callout>
     <callout arearefs="co-vol-clone-new">
      <para>新しく作成するボリューム名を指定します。</para>
     </callout>
     <callout arearefs="co-vol-clone-pool">
      <para>任意指定のパラメータです。 &libvirt; では既存のボリュームの場所を自動的に判別しますが、それがうまくいかない場合はパラメータを指定してください。</para>
     </callout>
    </calloutlist>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-libvirt-storage-virsh-del-volumes">
   <title>ストレージプールからのボリュームの削除</title>
   <para>プールからボリュームを恒久的に削除するには、 <literal>vol-delete</literal> サブコマンドを使用します:</para>
<screen>&prompt.user;virsh vol-delete <replaceable>名前</replaceable> --pool <replaceable>プール名</replaceable></screen>
   <para><option>--pool</option> オプションは任意指定です。 &libvirt; ではボリュームの場所を自動的に判別しますが、それがうまくいかない場合はパラメータを指定してください。</para>
   <warning>
    <title>ボリューム削除時にチェックが行なわれない件について</title>
    <para>動作中の &vmguest; が使用しているボリュームであっても、削除そのものは実施できてしまいます。削除されたボリュームを復元する手段は用意されていません。</para>
    <para>&vmguest; で使用されているかどうかを確認するには、 <xref linkend="pro-libvirt-storage-virsh-list-vols"/> で説明している手順を行なってください。</para>
   </warning>
  </sect2>

  <sect2 xml:id="libvirt-storage-virsh-attach-volumes">
   <title>&vmguest; へのボリュームの割り当て</title>
   <para><xref linkend="sec-libvirt-storage-virsh-add-volumes"/> の手順に従ってボリュームを作成したら、あとはそれを仮想マシンに割り当てて、ハードディスクとして使用できるようにします:</para>
<screen>&prompt.user;virsh attach-disk <replaceable>ドメイン名_(仮想マシン名)</replaceable> <replaceable>イメージファイル名</replaceable> <replaceable>ディスクデバイス名</replaceable></screen>
   <para>たとえば下記のようになります:</para>
<screen>&prompt.user;virsh attach-disk sles12sp3 /virt/images/example_disk.qcow2 sda2</screen>
   <para>新しいディスクが割り当てられているかどうかを確認するには、 <command>virsh dumpxml</command> コマンドの出力を調査します:</para>
<screen>&prompt.root;virsh dumpxml sles12sp3
[...]
&lt;disk type='file' device='disk'&gt;
 &lt;driver name='qemu' type='raw'/&gt;
 &lt;source file='/virt/images/example_disk.qcow2'/&gt;
 &lt;backingStore/&gt;
 &lt;target dev='sda2' bus='scsi'/&gt;
 &lt;alias name='scsi0-0-0'/&gt;
 &lt;address type='drive' controller='0' bus='0' target='0' unit='0'/&gt;
&lt;/disk&gt;
[...]</screen>
   <sect3>
    <title>ホットプラグ (活性接続) と恒久変更</title>
    <para>ディスクの接続は動作中のドメイン (仮想マシン) に対しても、停止中のドメインに対しても実施することができます。また、接続方法は <option>--live</option> と <option>--config</option> のオプションで制御することができます:</para>
    <variablelist>
     <varlistentry>
      <term><option>--live</option></term>
      <listitem>
       <para>動作中のドメインに対してディスクを活性接続します。接続されたディスクはドメインの設定ファイルには保存されません。停止中のドメインに対して <option>--live</option> オプションを使用すると、エラーになります。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>--config</option></term>
      <listitem>
       <para>ドメインの設定を恒久的に変更します。接続されたディスクは、次回のドメイン起動時に利用できるようになります。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>--live</option> <option>--config</option></term>
      <listitem>
       <para>ディスクを活性接続し、かつドメインの設定を恒久的に変更します。</para>
      </listitem>
     </varlistentry>
    </variablelist>
    <tip>
     <title><command>virsh attach-device</command></title>
     <para><command>virsh attach-disk</command> よりも <command>virsh attach-device</command> のほうが、より一般的な形式です。後者のコマンドであれば、ドメインに対してディスク以外のデバイスを追加することもできます。</para>
    </tip>
   </sect3>
  </sect2>

  <sect2 xml:id="libvirt-storage-virsh-detach-volumes">
   <title>&vmguest; からのボリュームの割り当て解除</title>
   <para>ドメインからディスクを切り離すには、 <command>virsh detach-disk</command> を使用します:</para>
<screen>&prompt.root;virsh detach-disk <replaceable>ドメイン名_(仮想マシン名)</replaceable> <replaceable>ディスクデバイス</replaceable></screen>
   <para>たとえば下記のようになります:</para>
<screen>&prompt.root;virsh detach-disk sles12sp3 sda2</screen>
   <para><xref linkend="libvirt-storage-virsh-attach-volumes"/> での説明にあるとおり、 <option>--live</option> と <option>--config</option> のオプションで割り当て方法を制御することができます。</para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-libvirt-storage-locking">
  <title><systemitem class="daemon">virtlockd</systemitem> を利用したディスクファイルやブロックデバイスのロック (施錠)</title>

  <para>ブロックデバイスやディスクファイルをロック (施錠) することで、これらのリソースを他の VM ゲストから書き込まれることがないように保護することができます。これにより、同一の &vmguest; が二重に起動されることを防ぐことができるほか、異なる仮想マシンに同じディスクが割り当てられたりすることがないようになります。これにより、仮想マシンのディスクイメージが、誤った設定によって破壊されてしまうのを防ぐことにもなります。</para>

  <para>ロック処理は <systemitem class="daemon">virtlockd</systemitem> と呼ばれるデーモンが取り扱います。 &libvirtd; デーモンとは個別に動作する仕組みであることから、 &libvirtd; がクラッシュしたり再起動したりしてしまったような場合でも、ロックを提供し続けることができます。さらに <systemitem class="daemon">virtlockd</systemitem> 自身の更新にも対応していて、自分自身で再起動を実施できるようになっています。これにより、 <systemitem class="daemon">virtlockd</systemitem> を更新しても、 &vmguest; を再起動する必要がありません。なお、 <systemitem class="daemon">virtlockd</systemitem> は &kvm;, &qemu;, &xen; にそれぞれ対応しています。</para>

  <sect2 xml:id="sec-libvirt-storage-locking-enable">
   <title>ロックの有効化</title>
   <para>仮想ディスクのロックは &productname; の既定では有効化されていません。有効化してシステムの起動時に自動的に開始されるようにするには、下記の手順を実施します:</para>
   <procedure>
    <step>
     <para><filename>/etc/libvirt/qemu.conf</filename> ファイルを編集して、下記を設定します:</para>
<screen>lock_manager = "lockd"</screen>
    </step>
    <step>
     <para>あとは過去のコマンドを実行して、 <systemitem class="daemon">virtlockd</systemitem> デーモンを開始します:</para>
<screen>&prompt.sudo;systemctl start virtlockd</screen>
    </step>
    <step>
     <para>&libvirtd; デーモンを再起動します:</para>
<screen>&prompt.sudo;systemctl restart libvirtd</screen>
    </step>
    <step>
     <para>システムの起動時に <systemitem class="daemon">virtlockd</systemitem> が自動的に開始されるように設定します:</para>
<screen>&prompt.sudo;systemctl enable virtlockd</screen>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec-libvirt-storage-locking-configure">
   <title>ロックの設定</title>
   <para>既定では、 <systemitem class="daemon">virtlockd</systemitem> は &vmguest; に設定された全てのディスクを自動的にロックします。また、既定の設定では "直接" ロック領域を使用し、 VM ゲストの &lt;disk&gt; に書かれたデバイスに結びつけられたファイルに対して直接ロックを取得します。たとえば &vmguest; 内に下記のような設定が存在した場合、 <filename>/var/lib/libvirt/images/my-server/disk0.raw</filename> ファイルに対して <literal>flock(2)</literal> を直接実行して、ロックを獲得します:</para>
<screen>&lt;disk type='file' device='disk'&gt;
 &lt;driver name='qemu' type='raw'/&gt;
 &lt;source file='/var/lib/libvirt/images/my-server/disk0.raw'/&gt;
 &lt;target dev='vda' bus='virtio'/&gt;
&lt;/disk&gt;</screen>
   <para><systemitem class="daemon">virtlockd</systemitem> の設定は、設定ファイルである <filename>/etc/libvirt/qemu-lockd.conf</filename> を編集することで変更することができます。ここにはさらに詳しい情報の書かれたコメント (英語) が含まれています。なお、設定を変更した後は、それを反映させるために <systemitem class="daemon">virtlockd</systemitem> を再読み込みさせる必要があります:</para>
<screen>&prompt.sudo;systemctl reload virtlockd</screen>
<!-- fs 2014-08-05: FIXME Check if tru &sle; 11 SP3
<note>
    <title>Locking Currently Only Available for All Disks</title>
    <para>
     Currently, locking can only be activated globally, so that all virtual
     disks are locked. Support for locking selected disks is planned for future
     releases.
    </para>
   </note>

   <sect3 id="sec-libvirt-storage-locking-configure-noauto">
    <title>Manually Managing Locks</title>
    <para>
     As stated above, all virtual disks are locked by default. To
     restrict locking to selected disks, you need to turn off auto locking by
     setting
    </para>
    <screen>auto_disk_leases = 0</screen>
    <para>
     If auto locking is turned off you need to add &lt;lease> statements to
     the &lt;devices> section of the &vmguest;s XML definitions by editing
     them with the <command>virsh edit</command> command. A sample entry will
     look like the following example:
    </para>
    see https://www.redhat.com/archives/libvir-list/2013-April/msg01714.html
    <screen>TBD</screen>
    <para>

     Device leases
When using a lock manager, it may be desirable to record device leases against a VM. The lock manager will ensure the VM won't start unless the leases can be acquired.

  ...
  <devices>
    ...
    <lease>
      <lockspace>somearea</lockspace>
      <key>somekey</key>
      <target path='/some/lease/path' offset='1024'/>
    </lease>
    ...
  </devices>
  ...
lockspace
This is an arbitrary string, identifying the lockspace within which the key is held. Lock managers may impose extra restrictions on the format, or length of the lockspace name.
key
This is an arbitrary string, uniquely identifying the lease to be acquired. Lock managers may impose extra restrictions on the format, or length of the key.
target
This is the fully qualified path of the file associated with the
lockspace. The offset specifies where the lease is stored within the file. If
the lock manager does not require a offset, just pass 0.
    </para>
    <important>
     <title>Starting &vmguest;s without Locking</title>
     <para>
      If auto locking is disabled, <systemitem
      class="daemon">virtlockd</systemitem> automatically prevents all
      &vmguest;s that have no proper <quote>lease-configuration</quote> from
      being started. This ensures that only &vmguest;s with disks that are
      locked can be started.
     </para>
     <para>
      Disable this behavior by setting
     </para>
     <screen>require_lease_for_disks = 0</screen>
    </important>
   </sect3>
-->
   <sect3 xml:id="sec-libvirt-storage-locking-configure-shared-fs">
    <title>間接ロック領域の有効化</title>
    <para><systemitem class="daemon">virtlockd</systemitem> の既定の設定では、 "直接" ロック領域を使用し、 VM ゲストの &lt;disk&gt; に書かれたデバイスに結びつけられたファイルに対して直接ロックを取得します。</para>
    <para>ディスクのファイルパスがホストから直接アクセスできるものではない場合、 <systemitem class="daemon">virtlockd</systemitem> を設定して <quote>間接</quote> ロック領域を使用するように設定することができます。この場合、間接ロック領域ディレクトリ内に、ディスクファイルパスのハッシュファイルを作成します。このロックは、実際のディスクファイルパスの代用として使用され、保持されるようになります。間接ロック領域は、 <literal>fcntl()</literal> ロックに対応していないファイルシステムを使用する場合にも便利です。間接ロック領域は、 <option>file_lockspace_dir</option> 設定で指定します:</para>
<screen>file_lockspace_dir = "<replaceable>ロック領域のディレクトリ</replaceable>"</screen>
   </sect3>
   <sect3 xml:id="sec-libvirt-storage-locking-configure-lvm-iscsi">
    <title>LVM もしくは iSCSI ボリュームでのロックの有効化</title>
    <para>複数のホストで共有されている LVM や iSCSI ボリューム内に仮想ディスクが存在する場合、それらをロックするには、パス (既定で使用される方法) ではなく UUID で行なう必要があります。それに加えてロック領域のディレクトリは、全てのホストからアクセスすることのできる共有の領域内に配置する必要があります。　<systemitem class="daemon">virtlockd</systemitem> の LVM/iSCSI におけるロックの設定は、下記のようになります:</para>
<screen>lvm_lockspace_dir = "<replaceable>ロック領域のディレクトリ</replaceable>"
iscsi_lockspace_dir = "<replaceable>ロック領域のディレクトリ</replaceable>"</screen>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-libvirt-storage-resize">
  <title>ゲストのブロックデバイスのオンラインサイズ変更</title>

  <para>状況によっては、ゲストシステムで使用されるブロックデバイスのサイズを変更し、サイズを大きくするか小さくする必要に迫られることがあります。たとえば元々割り当てていたサイズでは不足しているような場合には、サイズを増やす必要があります。ゲストに割り当てていたディスクが <emphasis>論理ボリューム</emphasis> 内に存在していれば、ゲストシステムを動作させた状態のままサイズを変更することができます。これはオフラインによるディスクサイズの変更 (<xref linkend="sec-guestfs-tools"/> 内で説明している <command>virt-resize</command> コマンドに関する説明をお読みください) とは異なり、サイズ変更時にもゲストを停止させる必要がありませんので、大きな利点になります。 &vmguest; のディスクサイズを変更するには、下記の手順を実施します:</para>

  <procedure>
   <title>ゲストディスクのオンラインサイズ変更</title>
   <step>
    <para>まずはゲストシステム内で、現在のサイズを確認します (下記では <filename>/dev/vda</filename> にディスクが配置されているものとします) 。</para>
<screen>&prompt.root;fdisk -l /dev/vda
Disk /dev/sda: 160.0 GB, 160041885696 bytes, 312581808 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes</screen>
   </step>
   <step>
    <para>ホスト側で、ゲストの <filename>/dev/vda</filename> を提供している論理ボリュームのサイズを変更します。ここではたとえば 200 GB に変更します。</para>
<screen>&prompt.root;lvresize -L 200G /dev/mapper/vg00-home
Extending logical volume home to 200 GiB
Logical volume home successfully resized</screen>
   </step>
   <step>
    <para>ホスト側で、ゲストの <filename>/dev/mapper/vg00-home</filename> ディスクに対応するブロックデバイスのサイズを変更します。なお、下記の <replaceable>ドメイン_ID</replaceable> の箇所には、 <command>virsh list</command> で表示されるドメイン名 (仮想マシン名) を入力します。</para>
<screen>&prompt.root;virsh blockresize  --path /dev/vg00/home --size 200G <replaceable>ドメイン_ID</replaceable>
ブロックデバイス '/dev/vg00/home' の容量が変更されました</screen>
   </step>
   <step>
    <para>ゲスト側で、新しいディスクサイズが認識されていることを確認します。</para>
<screen>&prompt.root;fdisk -l /dev/vda
Disk /dev/sda: 200.0 GB, 200052357120 bytes, 390727260 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes</screen>
   </step>
  </procedure>
 </sect1>
 <sect1 xml:id="sec-libvirt-storage-share">
  <title>ホストとゲストの間でのディレクトリ共有 (ファイルシステムのパススルー)</title>

  <para>libvirt では、 &qemu; のファイルシステムパススルー (VirtFS とも呼ばれます) 機能を利用して、ホストとゲストの間でのディレクトリ共有を行なうことができます。このようなディレクトリは複数の &vmguest; から同時にアクセスすることができるため、 &vmguest; 間でのファイル交換を行なうこともできます。</para>

  <note>
   <title>Windows ゲストとファイルシステムのパススルーについて</title>
   <para>Windows には共有ディレクトリをマウントするためのデバイスドライバが提供されていないため、 &vmhost; と Windows ゲストとの間では、ファイルシステムのパススルー機能を利用してディレクトリの共有を行なうことはできません。</para>
  </note>

  <para>&vmguest; に対してディレクトリを共有するには、下記の手順を実施します:</para>

  <procedure>
   <step>
    <para>&vmm; でゲストのコンソールを開いて、メニューから <menuchoice><guimenu>表示</guimenu> <guimenu>詳細</guimenu></menuchoice> を選択するか、もしくはツールバー内の <guimenu>仮想マシンの情報を表示</guimenu> を選択します。あとは <menuchoice> <guimenu>ハードウェアを追加</guimenu> <guimenu>ファイルシステム</guimenu> </menuchoice> を選択して、 <guimenu>ファイルシステム・パススルー</guimenu> を表示します。</para>
   </step>
   <step>
    <para><guimenu>ドライバー</guimenu> では、 <guimenu>Handle</guimenu> もしくは <guimenu>Path</guimenu> のいずれかを選択します。既定値は <guimenu>Path</guimenu> です。 <guimenu>モード</guimenu> ではセキュリティモデルを指定します。これは、ホスト内でのファイルパーミッションの設定方法を指定します。下記のいずれかを選択します:</para>
    <variablelist>
     <varlistentry>
      <term><guimenu>Passthrough</guimenu> (既定値)</term>
      <listitem>
       <para>ファイルシステム内のファイルを、クライアントユーザの権限で直接作成します。これは NFSv3 を利用している場合によく似ています。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><guimenu>Squash</guimenu></term>
      <listitem>
       <para><guimenu>Passthrough</guimenu> と同様ですが、 <command>chown</command> などの特権操作の失敗については無視します。これは &kvm; が <systemitem class="username">root</systemitem> で動作していない場合に必要となります。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><guimenu>Mapped</guimenu></term>
      <listitem>
       <para>ファイルサーバ側の権限 ( <literal>qemu.qemu</literal> ) でファイルを作成します。ユーザ権限とクライアント側の権限情報は、拡張属性内に保存します。このモデルは、ホストとゲストを完全に分離しておきたい場合にお勧めの設定です。</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </step>
   <step>
    <para>&vmhost; 内のディレクトリを <guimenu>ソースパス</guimenu> に指定します。なお、共有されたディレクトリをマウントする際には、 <guimenu>ターゲットパス</guimenu> に指定した名前を使用します。また、この文字列はタグとして使用するだけのものであり、 &vmguest; 内のパスを表わすものではありません。</para>
   </step>
   <step>
    <para><!-- NOTE: not "Apply" but "Finish"? --><guimenu>完了</guimenu> を押して設定を適用します。 &vmguest; が動作中の場合は、設定を反映させるのにシャットダウンが必要となります (ゲストの再起動では不十分です) 。</para>
   </step>
   <step>
    <para>&vmguest; を起動します。共有されたディレクトリをマウントするには、下記のコマンドを実行します:</para>
<screen>&prompt.sudo;mount -t 9p -o trans=virtio,version=9p2000.L,rw <replaceable>タグ</replaceable> /<replaceable>マウントポイント</replaceable></screen>
    <para>共有されたディレクトリを恒久的にマウントしたい場合は、下記のような内容を <filename>/etc/fstab</filename> に追加します:</para>
<screen><replaceable>タグ</replaceable>   /<replaceable>マウントポイント</replaceable>    9p  trans=virtio,version=9p2000.L,rw    0   0</screen>
   </step>
  </procedure>
 </sect1>
 <sect1 xml:id="libvirt-storage-rbd">
  <title>&libvirt; を利用した RADOS ブロックデバイスの使用</title>
  <para>RADOS Block Devices (RBD) はデータを Ceph クラスタに保存します。このブロックデバイスでは、スナップショットやレプリケーション、データの一貫性維持などを行なうことができます。お使いの &libvirt; 管理下の &vmguest; から RBD を使用したい場合は、他のブロックデバイスと同様の手順を実施してください。</para>
  <para os="sles;sled">詳しくは &ses; の <citetitle>&admin;</citetitle> 内にある <citetitle>Using libvirt with Ceph</citetitle> (英語) の章をお読みください。 &ses; のドキュメンテーションは、 <link xlink:href="&dsc-ses;/"/> で公開されています。</para>
 </sect1>
</chapter>
