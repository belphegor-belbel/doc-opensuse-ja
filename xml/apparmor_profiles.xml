<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter [
<!ENTITY % entities SYSTEM "generic-entities.ent">
%entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha-apparmor-profiles">
 <title>プロファイルのコンポーネントと文法</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>
 <para>アプリケーションに対する &aa; のプロファイル作成はわかりやすく、直感的な仕組みになっています。 &aa; にはプロファイル作成を支援するツールが添付されているため、プログラミングの知識もスクリプトの処理も必要とはなりません。管理者に対して求められる作業は、セキュリティを強化する目的で、各アプリケーションに対して最も厳格なアクセス制御とプログラム実行のポリシーを設定することだけです。</para>
 <para>アプリケーションに対するプロファイルの更新や修正は、ソフトウエアの設定を変更したり、必要な機能範囲の変化が起こったりした場合のみです。 &aa; には、プロファイルの更新や修正に対応した、直感的なツールが用意されています。</para>
 <para>プロファイルを作成したいプログラムを選択したあとは、実際に &aa; のプロファイルを作成するだけです。プロファイルの作成を行うにあたっては、コンポーネントやその文法の理解を深める必要があります。 &aa; には、シンプルで再利用性の高いプロファイルを作成するための、さまざまな機能が用意されています:</para>
 <variablelist>
  <varlistentry>
   <term>ファイル取り込み</term>
   <listitem>
    <para>include と呼ばれるステートメントを使用することで、他の &aa; プロファイル内の一部分を取り込むことができます。これにより、新しいプロファイルの構造を単純化することができます。</para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>抽象</term>
   <listitem>
    <para>抽象機能は、一般的なアプリケーションの処理をまとめて取り込む機能を提供します。</para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>プログラムチャンク</term>
   <listitem>
    <para>プログラムチャンクとはファイル取り込み機能の一部で、特定のプログラムスイートに固有として設定されているプロファイルの一部を、取り込むことができる機能です。</para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>ケーパビリティ項目</term>
   <listitem>
    <para>ケーパビリティ項目とは、 POSIX.1e ( <link xlink:href="https://ja.wikipedia.org/wiki/POSIX#POSIX.1"/> ) として定められている Linux ケーパビリティ向けのプロファイル項目で、制限されたプロセスが権限の必要なシステムコールを行う際、より細かい制御を行うことのできる仕組みを指します。</para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>ネットワークアクセス制御項目</term>
   <listitem>
    <para>ネットワークアクセス制御項目とは、アドレスの種類とファミリをベースにして、ネットワークへのアクセスを制御するための項目です。</para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>ローカル変数定義</term>
   <listitem>
    <para>ローカル変数を定義することで、パスのショートカットを設定することができます。</para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>ファイルアクセス制御項目</term>
   <listitem>
    <para>ファイルアクセス制御項目とは、アプリケーション側からのアクセスを許可するファイルの一覧を表す項目です。</para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term>rlimit 項目</term>
   <listitem>
    <para>rlimit 項目は、アプリケーションに対するリソース制限を設定し、制御するための項目です。</para>
   </listitem>
  </varlistentry>
 </variablelist>
 <para>プロファイルを作成すべきプログラムの判断については <xref linkend="sec-apparmor-concept-determine"/> を、 &yast; を利用して &aa; のプロファイルを作成する方法については <xref linkend="cha-apparmor-yast"/> を、 &aa; のコマンドラインインターフェイスを利用したプロファイルの作成については <xref linkend="cha-apparmor-commandline"/> を、それぞれお読みください。</para>
 <para>&aa; のプロファイルに関する詳細については、 <command>man 5 apparmor</command> をお読みください。</para>
 <sect1 xml:id="sec-apparmor-profiles-parts">
  <title>&aa; プロファイル内の各部の意味</title>

  <para>プロファイルに何が含まれているのか、およびプロファイルを作成するにはどうしたらよいのかを説明するにあたって、もっとも簡単な方法は例を挙げる方法です。たとえば <command>/usr/bin/foo</command> という架空のアプリケーションに対して、下記のようなプロファイルが存在する場合を例にします:</para>

<screen>#include &lt;tunables/global&gt;<co xml:id="co-apparmor-profiles-vardef"/>

# a comment naming the application to confine
/usr/bin/foo<co xml:id="co-apparmor-profiles-path"/> {<co xml:id="co-apparmor-profiles-brack"/>
   #include &lt;abstractions/base&gt;<co xml:id="co-apparmor-profiles-incl"/>

   capability setgid<co xml:id="co-apparmor-profiles-capent"/>,
   network inet tcp<co xml:id="co-apparmor-profiles-netd"/>,

   link /etc/sysconfig/foo -&gt; /etc/foo.conf,<co xml:id="co-apparmor-profiles-lp"/>
   /bin/mount            ux,
   /dev/{,u}<co xml:id="co-apparmor-profiles-ext"/>random     r,
   /etc/ld.so.cache      r,
   /etc/foo/*            r,
   /lib/ld-*.so*         mr,
   /lib/lib*.so*         mr,
   /proc/[0-9]**         r,
   /usr/lib/**           mr,
   /tmp/                 r,<co xml:id="co-apparmor-profiles-pathent"/>
   /tmp/foo.pid          wr,
   /tmp/foo.*            lrw,
   /@{HOME}<co xml:id="co-apparmor-profiles-variable"/>/.foo_file   rw,
   /@{HOME}/.foo_lock    kw,
   owner<co xml:id="co-apparmor-profiles-owner"/> /shared/foo/** rw,
   /usr/bin/foobar       Cx,<co xml:id="co-apparmor-profiles-cx"/>
   /bin/**               Px -&gt; bin_generic,<co xml:id="co-apparmor-profiles-named"/>

   # a comment about foo's local (children) profile for /usr/bin/foobar.

   profile /usr/bin/foobar<co xml:id="co-apparmor-profiles-local"/> {
      /bin/bash          rmix,
      /bin/cat           rmix,
      /bin/more          rmix,
      /var/log/foobar*   rwl,
      /etc/foobar        r,
   }

  # foo's hat, bar.
   ^bar<co xml:id="co-apparmor-profiles-hat"/> {
    /lib/ld-*.so*         mr,
    /usr/bin/bar          px,
    /var/spool/*          rwl,
   }
}
</screen>

  <calloutlist>
   <callout arearefs="co-apparmor-profiles-vardef">
    <para>ここでは、変数定義を含むファイルを読み込んでいます。</para>
   </callout>
   <callout arearefs="co-apparmor-profiles-path">
    <para>制限対象となるプログラムに対して、正規化されたパスを指定しています。</para>
   </callout>
   <callout arearefs="co-apparmor-profiles-brack">
    <para>この中括弧 ( <literal>{}</literal> ) は、ステートメントやサブプロファイル、パス項目やケーパビリティ項目、ネットワーク項目などのコンテナとして機能するものです。</para>
   </callout>
   <callout arearefs="co-apparmor-profiles-incl">
    <para>このディレクティブにより、 &aa; プロファイルのコンポーネントを取り込んでいます。これにより、プロファイルを単純化できるようになっています。</para>
   </callout>
   <callout arearefs="co-apparmor-profiles-capent">
    <para>capability (ケーパビリティ) 項目のステートメントでは、 <!-- NOTE: what is "29"? --> POSIX.1e ドラフトで規定されたケーパビリティを有効化しています。</para>
   </callout>
   <callout arearefs="co-apparmor-profiles-netd">
    <para>アプリケーションに対して、どの種類のネットワークアクセスを許可するかを指定しているディレクティブです。詳しくは <xref linkend="sec-apparmor-profiles-nac"/> をお読みください。</para>
   </callout>
   <callout arearefs="co-apparmor-profiles-lp">
    <para>リンク対ルールでは、リンクの元と宛先をそれぞれ指定することができます。詳しくは <xref linkend="sec-apparmor-profiles-perm-link-pair"/> をお読みください。</para>
   </callout>
   <callout arearefs="co-apparmor-profiles-ext">
    <para>この中括弧 ( <literal>{}</literal> ) は、カンマ区切りで複数の項目を列挙するための仕組みです。この場合、 <quote>u</quote> があるものと無いものに展開されます。</para>
   </callout>
   <callout arearefs="co-apparmor-profiles-pathent">
    <para>プログラム側から、ファイルシステム内のどの領域にアクセスを許可するのかを設定する、パス項目です。この項目では、最初に絶対パス表記でのファイル名 (ワイルドカード可) を記述し、次に許可されるアクセスモード (たとえば <literal>r</literal> であれば読み込み、 <literal>w</literal> であれば書き込み、 <literal>x</literal> であれば実行など) をそれぞれ指定します。スペースやタブなど、任意の種類のホワイトスペースをパス名の前に指定することができますが、パス名とアクセスモードの指定は区切らなければなりません。また、アクセスモードと行末のカンマとの間は、スペースを入れても入れなくてもかまいません。利用可能なアクセスモードに関する詳細は、 <xref linkend="sec-apparmor-profiles-perm"/> をお読みください。</para>
   </callout>
   <callout arearefs="co-apparmor-profiles-variable">
    <para>この変数は、プロファイル本体を変更することなく内容を変更したい場合に使用するものです。</para>
   </callout>
   <callout arearefs="co-apparmor-profiles-owner">
    <para>所有者条件ルールと呼ばれるルールで、自分自身で所有しているファイルに対して、読み込みや書き込みの権限を許可することができます。詳しくは <xref linkend="sec-apparmor-profiles-perm-owner"/> をお読みください。</para>
   </callout>
   <callout arearefs="co-apparmor-profiles-cx">
    <para>この項目は、 <literal>/usr/bin/foobar</literal> という名前のローカルプロファイルに遷移させるためのものです。利用可能な実行モードに関する概要は、 <xref linkend="sec-apparmor-profiles-exec"/> をお読みください。</para>
   </callout>
   <callout arearefs="co-apparmor-profiles-named">
    <para>グローバルスコープ内に位置する bin_generic というプロファイルへの遷移を表す、名前付きプロファイル遷移です。詳しくは <xref linkend="sec-apparmor-profiles-exec-named"/> をお読みください。</para>
   </callout>
   <callout arearefs="co-apparmor-profiles-local">
    <para>ここでは、ローカルプロファイル <literal>/usr/bin/foobar</literal> を定義しています。</para>
   </callout>
   <callout arearefs="co-apparmor-profiles-hat">
    <para>ここでは、アプリケーションに対する <quote>ハット</quote> と呼ばれるサブプロファイルを参照しています。 &aa; のチェンジハット機能について、詳しくは <xref linkend="cha-apparmor-hat"/> をお読みください。</para>
   </callout>
  </calloutlist>

  <para>プログラムに対してプロファイルを作成すると、プログラムはプロファイル内に指定されたモードでファイルへのアクセスが許可されるほか、同じくプロファイル内に指定された POSIX ケーパビリティの使用のみが許可されます。これらの制限は、 Linux のアクセス制御に付加する形で動作します。</para>

  <formalpara>
   <title>例:</title>
   <para>プログラム側でケーパビリティ <systemitem>CAP_CHOWN</systemitem> を使用できるようにするには、通常の Linux アクセス制御で <systemitem>CAP_CHOWN</systemitem> に対するアクセス許可を持つ (通常は &rootuser; が所有するプロセスである必要があります) だけでなく、プロファイル内に <systemitem>chown</systemitem> のケーパビリティが設定されていなければなりません。また、プログラムが <filename>/foo/bar</filename> というファイルに書き込む場合、ファイルの所有者やパーミッションの設定で書き込みできる権限を持つだけでなく、プロファイル内に <literal>/foo/bar w</literal> という設定がなければなりません。</para>
  </formalpara>

  <para>&aa; のルールへの違反は、 <systemitem class="resource">audit</systemitem> パッケージがインストールされていれば <filename>/var/log/audit/audit.log</filename> に、インストールされていない場合は <filename>/var/log/messages</filename> に記録されます (syslog パッケージさえもインストールされていない場合は、 <systemitem>journalctl</systemitem> にのみ記録されます) 。このような &aa; の仕組みにより、実際に攻撃を受けた場合であっても、攻撃による被害を軽減することができるようになっています。</para>
 </sect1>
 <sect1 xml:id="sec-apparmor-profiles-types">
  <title>プロファイルの種類</title>

  <para>&aa; ではプロファイルが 4 種類に分けられています。それぞれ標準プロファイルと未接続プロファイル、ローカルプロファイルとハットと呼ばれます。標準プロファイルと未接続プロファイルは単独で動作するプロファイルであり、 <filename>/etc/apparmor.d/</filename> ディレクトリ内にファイルとして配置されます。ローカルプロファイルとハットは、親プロファイル内に組み込まれる子プロファイルで、アプリケーションのサブタスクに対してより厳しい、もしくは別途の制限を提供するために使用します。</para>

  <sect2 xml:id="sec-apparmor-profiles-types-attached">
   <title>標準プロファイル</title>
   <para>既定の &aa; プロファイルは、プログラムに対して名前で接続される仕組みであるため、プロファイル名は制限対象のアプリケーションパスに一致していなければなりません。</para>
<screen><?dbfo keep-together="always"?>/usr/bin/foo {
...
}
</screen>
   <para>上記のようなプロファイルが存在すると、制限を受けていないプロセスが <filename>/usr/bin/foo</filename> を実行すると、自動的に読み込まれて制限が適用されます。</para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-types-unattached">
   <title>未接続プロファイル</title>
   <para>未接続プロファイルは、ファイルシステムのネームスペース内に存在しておらず、そのためにアプリケーションの実行時に自動的に読み込まれ適用されるものではありません。未接続プロファイルの場合、プロファイル名の前に <literal>profile</literal> というキーワードを指定します。プロファイル名には自由な名前を設定することができますが、<literal>:</literal> や <literal>.</literal> で始まる名前は指定できません。また、プロファイル名にはスペースを入れることもできますが、この場合は正しく引用符を指定しなければなりません。また、名前が <literal>/</literal> で始まる場合、そのプロファイルは標準プロファイルとして扱われます。たとえば下記の 2 つのプロファイルは、同じ名前の標準プロファイルを意味するものになります:</para>
<screen>profile /usr/bin/foo {
...
}
/usr/bin/foo {
...
}</screen>
   <para>上述のように、未接続プロファイルは自動的に読み込まれませんし、 <literal>Px</literal> ルールで遷移することもありません。この未接続プロファイルを使用するには、名前付きプロファイル遷移の機能 (詳しくは <xref linkend="sec-apparmor-profiles-exec-named"/> をお読みください) を使用するか、もしくは <literal>change_profile</literal> ルール (詳しくは <xref linkend="sec-apparmor-profiles-types-change"/> をお読みください) で適用する必要があります。</para>
   <para>未接続プロファイルは一般に、システム全体のプロファイルとしては制限を加えるべきではないシステムユーティリティ (例: <literal>/bin/bash</literal>) などに対して、特別なプロファイルを割り当てるために使用します。また、役割の設定やユーザへの制限などを設定する際にも使用します。</para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-types-local">
   <title>ローカルプロファイル</title>
   <para>ローカルプロファイルは、制限を受けているアプリケーションがユーティリティプログラムを起動する際、そのユーティリティに対する特殊な制限を設定する際に便利な機能です。この種類のプロファイルは標準プロファイルと同様に指定することができますが、親プロファイル内に組み込まれて使用され、かつ <literal>profile</literal> キーワードで始める点が異なります。</para>
<screen><?dbfo keep-together="always"?>/parent/profile {
   ...
   profile /local/profile {
      ...
   }
}</screen>
   <para>ローカルプロファイルに遷移させたい場合は、 <literal>cx</literal> ルール (詳しくは <xref linkend="sec-apparmor-profiles-exec-cx"/> をお読みください) もしくは名前付きプロファイル遷移 (詳しくは <xref linkend="sec-apparmor-profiles-exec-named"/> をお読みください) を使用します。</para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-types-hat">
   <title>ハット</title>
   <para>&aa; では、 "ハット" とは追加の制限を提供するローカルプロファイルを意味するほか、 <literal>change_hat</literal> を利用して遷移することのできる、暗黙のルールを意味します。詳しくは <xref linkend="cha-apparmor-hat"/> をお読みください。</para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-types-change">
   <title>ルール変更</title>
   <para>&aa; では、 <literal>change_hat</literal> および <literal>change_profile</literal> と呼ばれるルールを利用して、制御ドメインの遷移を行うことができます。 <literal>change_hat</literal> がプロファイル内で定義したハットに遷移するのに対して、 <literal>change_profile</literal> は他のプロファイルを参照する処理を行います。 <literal>change_profile</literal> では、下記のように <literal>change_profile</literal> キーワードを明記します:</para>
<screen>change_profile -&gt; /usr/bin/foobar,</screen>
   <para><literal>change_hat</literal> と <literal>change_profile</literal> のいずれも、個別のアプリケーションを起動することなく、アプリケーション内でのプロファイル遷移を実現します。 <literal>change_profile</literal> は一般に、読み込まれたプロファイル間で一方向の遷移を行います。それに対して、 <literal>change_hat</literal> は戻ってくることを前提とした遷移となり、後から正しい機密鍵を指定することで、親プロファイルに戻ってくることができます。</para>
   <para><literal>change_profile</literal> は、アプリケーションが特定の設定フェーズを経由して起動し、後から権限レベルを落とすような仕組みである場合に、最適な仕組みです。起動フェーズ内でマッピングしたり開いたりしたリソースについては、プロファイルが変更されてもアクセスが許可され続けますが、新しいプロファイルでは新しいリソースを開く処理が制限されたり、リソースによっては切り替え前よりも制限を厳しくしたりするような動作に適切な仕組みです。特に、ケーパビリティやファイルのリソースについては制限ができる (ただしメモリマップされていなければ) ものの、メモリについては以前と同じく利用できるようになります。</para>
   <para><literal>change_hat</literal> はアプリケーションが仮想マシンやインタプリタを動作させるような場合に最適な仕組みで、それらの仮想マシンやインタプリタがアプリケーションのリソースへのアクセスを提供しないような場合に適切です (たとえば Apache の <literal>mod_php</literal> などがそれにあたります) 。なお <literal>change_hat</literal> は、元のプロファイルに戻るための機密鍵をアプリケーションのメモリ内に保存しますので、権限を縮小したフェーズではメモリに直接悪性できる権限を持つべきではありません。また、ハットではファイルハンドルへのアクセスを制限することはできますが、閉じることはできませんので、ファイルアクセスが正しく分離されていることも重要となります。もしもアプリケーションがバッファリングを行っていて、バッファを利用したファイルアクセスの機能を提供している場合、これらのファイルへのアクセスはカーネルからは検出することができず、新しいプロファイルでも制限がされないことがありうることにも注意してください。</para>
   <warning>
    <title>ドメイン遷移の安全性について</title>
    <para><literal>change_hat</literal> や <literal>change_profile</literal> によるドメイン遷移は、プロセスのメモリマッピングに影響を与えることができませんし、既に開いているリソースを閉じることもしませんので、 exec によるドメイン遷移よりはずっと安全性が低いことに注意してください。</para>
   </warning>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-apparmor-profiles-includes">
  <title>include ステートメント</title>

  <para>include ステートメントは、プロファイルを単純化するため、他の &aa; プロファイルのコンポーネントを取り込むことができるディレクティブです。一般に、プログラムからファイルへのアクセス許可を設定するための仕組みで、ファイルやディレクトリへのアクセスを別ファイルに切り出すことができますので、他のプログラムでも同様に必要となるようなファイルやディレクトリを列挙することができます。これにより、プロファイルのサイズも小さくすることができます。</para>

  <para>include ステートメントは通常、ハッシュ ( <literal>#</literal> ) 記号から書き始めます。ただし、ハッシュ ( <literal>#</literal> ) 記号はプロファイル内のコメント文を記述する際にも使用するものであるため、プロファイルが少しわかりにくくなってしまいます。このような問題から、 <literal>#include</literal> はその前にハッシュ記号がある場合には効果を失うように作られている (<literal>##include</literal> はコメントとして扱われます) ほか、 <literal>#</literal> と <literal>include</literal> の間にスペースを入れた場合も、同様に効果を失うように作られています (<literal># include</literal> もコメントとして扱われます) 。</para>

  <para>このほか、冒頭のハッシュ記号を省略して、 <literal>include</literal> だけで記述することもできます。</para>

<screen>include "/etc/apparmor.d/abstractions/foo"</screen>

  <para>上記は、下記と同じ意味になります:</para>

<screen>#include "/etc/apparmor.d/abstractions/foo"</screen>

  <note>
   <title>末尾に ',' を付けてはならない件について</title>
   <para>include ステートメントは C 言語のプリプロセッサの文法に従って作られているため、その他の &aa; ルールのように、文末に ',' を入れることはありません。</para>
  </note>

  <para>また、文法を少し変えることで、 <literal>include</literal> の動作を変更することができます。たとえばパスの指定の際、 <literal>""</literal> で括って指定すると、絶対パスや相対パスとして読み込ませることができます。</para>

<screen>include "/etc/apparmor.d/abstractions/foo"   # 絶対パス表記
include "abstractions/foo"   # 現在のディレクトリからの相対パス表記</screen>

  <para>なお相対パス表記の場合、現在読み込んでいるファイルからの相対パスとして扱われることに注意してください。たとえば現在のプロファイルが <filename>/etc/apparmor.d/bar</filename> である場合、下記のように include を記述したとします:</para>

<screen>include "abstractions/foo"</screen>

  <para>すると、 <filename>/etc/apparmor.d/abstractions/foo</filename> というファイルを取り込むことになります。また、</para>

<screen>include "example"</screen>

  <para>のような include ステートメントが <filename>/etc/apparmor.d/abstractions/foo</filename> プロファイル内に存在したとすると、 <filename>/etc/apparmor.d/abstractions/example</filename> というファイルを取り込むことになります。</para>

  <para>また、 <literal>&lt;&gt;</literal> を使用してファイルパスを指定すると、インクルードパス (<option>-I</option> で指定することができます。既定では <filename>/etc/apparmor.d</filename> ディレクトリです) 内を検索することができます。たとえばインクルードパスが下記のように指定されているものとします:</para>

<screen>-I /etc/apparmor.d/ -I /usr/share/apparmor/</screen>

  <para>この場合、下記のような include ステートメントを実行したとします:</para>

<screen>include &lt;abstractions/foo&gt;</screen>

  <para>すると、まずは <filename>/etc/apparmor.d/abstractions/foo</filename> にファイルが存在していないかどうかを調べ、存在していない場合は <filename>/usr/share/apparmor/abstractions/foo</filename> のファイルが存在していないかどうかを調べる動作になります。</para>

  <tip>
   <para>既定のインクルードパスは、 <command>apparmor_parser</command> に <option>-I</option> オプションを指定するか、もしくは <filename>/etc/apparmor/parser.conf</filename> 内に指定することで、上書きすることができます:</para>
<screen>Include /usr/share/apparmor/
Include /etc/apparmor.d/</screen>
   <para>このファイル内でも複数の項目を設定することができます。ただし、複数の項目を設定した場合は、 <command>apparmor_parser</command> に対して、順序通りに <option>-I</option> や <option>--Include</option> を指定したものとして扱われます。</para>
  </tip>

  <para>include ステートメントのパス指定が '/' で終わるものであった場合、これはディレクトリ内にある全てのファイルを取り込むものとして処理されます。</para>

  <para>お使いのアプリケーションのプロファイル作成を支援する目的で、 &aa; には 3 種類の include ステートメント (抽象／プログラムチャンク／チューナブル) が用意されています。</para>

  <sect2 xml:id="sec-apparmor-profiles-includes-abstractions">
   <title>抽象</title>
   <para>抽象とは一般的なアプリケーション処理をまとめた include ファイルで、たとえば認証機構やネームサービスルーチンへのアクセス、一般的なグラフィック要件やシステムアカウンティングなどが含まれます。これらの抽象内に記述されたファイルは、それぞれの処理で必要となるファイルであり、これらのうちのどれか 1 つにでもアクセスが必要となった場合、同じ抽象内の他のファイルに対しても、おそらくアクセスが必要となるものとして作られています (もちろん設定内容やプログラム側の要件にも依存します) 。抽象は <filename>/etc/apparmor.d/abstractions</filename> ディレクトリ内に配置されています。</para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-includes-chunks">
   <title>プログラムチャンク</title>
   <para>プログラムチャンクディレクトリ ( <filename>/etc/apparmor.d/program-chunks</filename> ) には、プログラムスイートごとに固有となるプロファイルチャンクのほか、スイート外では一般に必要とされないチャンクが含まれています。そのため、プロファイルウイザード ( <command>aa-logprof</command> および <command>aa-genprof</command> ) では、使用するよう提案することはありません。現時点では、プログラムチャンクは postfix プログラムスイート向けにのみ提供されています。</para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-includes-tunables">
   <title>チューナブル</title>
   <para>チューナブルのディレクトリ ( <filename>/etc/apparmor.d/tunables</filename> ) には、グローバル変数の定義が含まれています。プロファイル内で使用すると、これらの変数は処理時に展開され処理されますので、プロファイルそのものを変更することなく、値を変更することができるようになります。全てのプロファイルで使用される全てのチューナブル定義を追加するには、 <filename>/etc/apparmor.d/tunables/global</filename> に設定します。</para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-apparmor-profiles-capabilities">
  <title>ケーパビリティ項目 (POSIX.1e)</title>

  <para>ケーパビリティルールは、単純に <literal>capability</literal> の後ろに、 <systemitem>capabilities(7)</systemitem> のマニュアルページに書かれた POSIX.1e のケーパビリティ名を記述するだけです。単一のルール内に複数のケーパビリティを記述したり、全てのケーパビリティを指定 (<literal>capability</literal> とだけ記述する) したりすることもできます。</para>

<screen>
capability dac_override sys_admin,   # 複数のケーパビリティ
capability,                          # 全てのケーパビリティ
</screen>
 </sect1>
 <sect1 xml:id="sec-apparmor-profiles-nac">
  <title>ネットワークアクセス制御</title>

  <para>&aa; では、アドレスの種類とファミリをベースにして、ネットワークアクセスの制限を行うことができます。下記にネットワークアクセス制御ルールの書式を示します:</para>

<screen>network [[&lt;ドメイン&gt;<co xml:id="co-apparmor-profiles-nac-dom"/>][&lt;種類<co xml:id="co-apparmor-profiles-nac-type"/>&gt;][&lt;プロトコル<co xml:id="co-apparmor-profiles-nac-proto"/>&gt;]]</screen>

  <calloutlist>
   <callout arearefs="co-apparmor-profiles-nac-dom">
    <para>指定できるドメイン: <literal>inet</literal> , <literal>ax25</literal> , <literal>ipx</literal> , <literal>appletalk</literal> , <literal>netrom</literal> , <literal>bridge</literal> , <literal>x25</literal> , <literal>inet6</literal> , <literal>rose</literal> , <literal>netbeui</literal> , <literal>security</literal> , <literal>key</literal> , <literal>packet</literal> , <literal>ash</literal> , <literal>econet</literal> , <literal>atmsvc</literal> , <literal>sna</literal> , <literal>pppox</literal> , <literal>wanpipe</literal> , <literal>bluetooth</literal> , <literal>unix</literal> , <literal>atmpvc</literal> , <literal>netlink</literal> , <literal>llc</literal> , <literal>can</literal> , <literal>tipc</literal> , <literal>iucv</literal> , <literal>rxrpc</literal> , <literal>isdn</literal> , <literal>phonet</literal> , <literal>ieee802154</literal> , <literal>caif</literal> , <literal>alg</literal> , <literal>nfc</literal> , <literal>vsock</literal></para>
   </callout>
   <callout arearefs="co-apparmor-profiles-nac-type">
    <para>指定できる種類: <literal>stream</literal> , <literal>dgram</literal> , <literal>seqpacket</literal> , <literal>rdm</literal> , <literal>raw</literal> , <literal>packet</literal></para>
   </callout>
   <callout arearefs="co-apparmor-profiles-nac-proto">
    <para>指定できるプロトコル: <literal>tcp</literal> , <literal>udp</literal> , <literal>icmp</literal></para>
   </callout>
  </calloutlist>

  <para>&aa; ツールではファミリと種類の指定にのみ対応しています。また、 &aa; モジュールは <quote>ACCESS DENIED</quote> (アクセス拒否) メッセージ内に <literal>network <replaceable>ドメイン</replaceable> <replaceable>種類</replaceable></literal> のみを書き込みます。さらに、これらのメッセージはプロファイル生成ツール (&yast; およびコマンドライン) のみに出力されます。</para>

  <para>下記の例は、 &aa; プロファイル内で使用されるネットワーク関連のルール例を示しています。ただし、後ろの 2 つの書式は、現時点での &aa; ツールでは対応していないことに注意してください。</para>

<screen>network<co xml:id="co-apparmor-profiles-nac-nw"/>,
network inet<co xml:id="co-apparmor-profiles-nac-inet"/>,
network inet6<co xml:id="co-apparmor-profiles-nac-inet6"/>,
network inet stream<co xml:id="co-apparmor-profiles-nac-istream"/>,
network inet tcp<co xml:id="co-apparmor-profiles-nac-itcp"/>,
network tcp<co xml:id="co-apparmor-profiles-nac-tcp"/>,
</screen>

  <calloutlist>
   <callout arearefs="co-apparmor-profiles-nac-nw">
    <para>全てのネットワーク処理を許可します。ドメインや種類、プロトコルでの制限を適用しません。</para>
   </callout>
   <callout arearefs="co-apparmor-profiles-nac-inet">
    <para>IPv4 のネットワーク処理を許可します。</para>
   </callout>
   <callout arearefs="co-apparmor-profiles-nac-inet6">
    <para>IPv6 のネットワーク処理を許可します。</para>
   </callout>
   <callout arearefs="co-apparmor-profiles-nac-istream">
    <para>IPv4 TCP のネットワーク処理を許可します。</para>
   </callout>
   <callout arearefs="co-apparmor-profiles-nac-itcp">
    <para>IPv4 TCP のネットワーク処理を許可します (1 行上のルールと同じ意味です) 。</para>
   </callout>
   <callout arearefs="co-apparmor-profiles-nac-tcp">
    <para>IPv4 と IPv6 の TCP ネットワーク処理を許可します。</para>
   </callout>
  </calloutlist>
 </sect1>
 <sect1 role="General" xml:id="sec-apparmor-profiles-glob">
  <title>プロファイル名／フラグ／パス／グロブ</title>

  <para>プロファイルは、プログラムの実行ファイルのフルパスを指定することで、プログラムに割り当てられます。たとえば標準プロファイル (<xref linkend="sec-apparmor-profiles-types-attached"/>) の場合、プロファイルは下記のように記述します:</para>

<screen>/usr/bin/foo { ... }</screen>

  <para>下記では、プロファイルの命名の際や他の既存のコンテキスト内にプロファイルを配置する際、そして単純にファイルパスを指定する際に、便利なテクニックを紹介しています。</para>

  <para>&aa; ではディレクトリパスとファイルパスを明示的に区別して扱います。ディレクトリとして明示したい場合は、末尾に <literal>/</literal> を指定します:</para>

  <variablelist>
   <varlistentry>
    <term><filename>/some/random/example/* r</filename></term>
    <listitem>
     <para><filename>/some/random/example</filename> 内のファイルに対して、読み込みアクセスを許可します。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><filename>/some/random/example/ r</filename></term>
    <listitem>
     <para>ディレクトリにのみ読み込みアクセスを許可します。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><filename>/some/**/ r</filename></term>
    <listitem>
     <para><filename>/some</filename> 以下の任意のディレクトリに対して、読み込みアクセスを許可します (ただし <filename>/some/</filename> 自身には許可しません) 。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><filename>/some/random/example/** r</filename></term>
    <listitem>
     <para><filename>/some/random/example</filename> 以下の任意のファイルとディレクトリに対して、読み込みアクセスを許可します (ただし <filename>/some/random/example/</filename> 自身には許可しません) 。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><filename>/some/random/example/**[^/] r</filename></term>
    <listitem>
     <para><filename>/some/random/example</filename> 以下のファイルに対して、読み込みアクセスを許可します。このとき、明示的にディレクトリを除外します ( <literal>[^/]</literal> ) 。</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>グロブ (もしくは正規表現マッチング) はワイルドカードなどを利用して、ファイルやサブディレクトリをまとめて指定するための仕組みです。一般的なシェル、たとえば csh, Bash, zsh などで使用されるグロブ書式を利用して指定することができます。</para>

  <informaltable>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>
       <para><literal>*</literal></para>
      </entry>
      <entry>
       <para>任意の長さの文字列にマッチします (ただし <literal>/</literal> は含まないものとします) 。</para>
       <para>例: 複数パスの一括指定。</para>
      </entry>
     </row>
     <row>
      <entry>
       <para><literal>**</literal></para>
      </entry>
      <entry>
       <para>任意の長さの文字列にマッチします (<literal>/</literal> を含みます) 。</para>
       <para>例: サブディレクトリを含む全ファイルの一括指定。</para>
      </entry>
     </row>
     <row>
      <entry>
       <para><literal>?</literal></para>
      </entry>
      <entry>
       <para>1 文字にマッチします (ただし <literal>/</literal> は含まないものとします) 。</para>
      </entry>
     </row>
     <row>
      <entry>
       <para><literal>[abc]</literal></para>
      </entry>
      <entry>
       <para><literal>a</literal> , <literal>b</literal> , <literal>c</literal> のいずれかの文字にマッチします。</para>
       <para>例: <literal>/home[01]/*/.plan</literal> のように指定すると、 <filename>/home0</filename> および <filename>/home1</filename> のディレクトリ内にある <filename>.plan</filename> ファイルにアクセスを許可します。</para>
      </entry>
     </row>
     <row>
      <entry>
       <para><literal>[a-c]</literal></para>
      </entry>
      <entry>
       <para><literal>a</literal> , <literal>b</literal> , <literal>c</literal> のいずれかの文字にマッチします。</para>
      </entry>
     </row>
     <row>
      <entry>
       <para><literal>{ab,cd}</literal></para>
      </entry>
      <entry>
       <para><literal>ab</literal> という文字列、もしくは <literal>cd</literal> という文字列のいずれかにマッチします。</para>
       <para>例: <literal>/{usr,www}/pages/**</literal> のように指定すると、 <filename>/usr/pages</filename> 以下の全てのファイルと、 <filename>/www/pages</filename> 以下の全てのファイルに対して、アクセスを許可します。</para>
      </entry>
     </row>
     <row>
      <entry>
       <para><literal>[^a]</literal></para>
      </entry>
      <entry>
       <para><literal>a</literal> を除く全ての 1 文字にマッチします。</para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>

  <sect2 xml:id="sec-apparmor-profiles-flags">
   <title>プロファイルフラグ</title>
   <para>プロファイルフラグは、対応するプロファイルの動作を制御するためのものです。プロファイルの定義内に手作業で指定することで、フラグを追加することができます。プロファイルフラグは下記の書式で設定します:</para>
<screen>/path/to/profiled/binary flags=(フラグ) {
  [...]
}</screen>
   <para>複数のフラグを指定したい場合は、カンマ ',' またはスペース ' ' で区切って指定します。プロファイルフラグには 3 種類のものがあります。モードフラグ、相対フラグ、接続フラグです。</para>
   <para><emphasis>モード</emphasis> フラグには <literal>complain</literal> フラグ (不正なアクセスが記録されるだけで、拒否はされない) があります。このフラグを指定しない場合、プロファイルは <literal>enforce</literal> フラグ (実際にポリシーを強制する) が指定されたものとして扱われます。</para>
   <tip>
    <para>プロファイル全体を complain (不平) モードに設定する場合、より柔軟な方法として、 <filename>/etc/apparmor.d/force-complain/</filename> ディレクトリ内にシンボリックリンクを作成する方法があります。</para>
<screen>ln -s /etc/apparmor.d/bin.ping /etc/apparmor.d/force-complain/bin.ping</screen>
   </tip>
   <para><emphasis>相対</emphasis> フラグには <literal>chroot_relative</literal> フラグ (ネームスペースではなく chroot に対する相対として扱う) のほか、 <literal>namespace_relative</literal> フラグ (こちらが既定値で、 chroot の外側で相対として扱う) があります。これらは相互排他です。</para>
   <para><emphasis>接続</emphasis> フラグには相互排他関係にある 2 対のフラグがあります。 <literal>attach_disconnected</literal> フラグと <literal>no_attach_disconnected</literal> フラグ (パス名がネームスペース外に解決された場合、ルートに割り当てるかどうか (つまり、冒頭に '/' があるかどうか)) と、 <literal>chroot_attach</literal> フラグと <literal>chroot_no_attach</literal> フラグ (chroot 環境外に存在していて、同じネームスペース内に存在するファイルに対して、 chroot 環境内からのパス名生成の制御) があります。</para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-glob-variables">
   <title>プロファイル内での変数の使用</title>
   <para>&aa; ではプロファイル内でパスを指定するために変数を使用することができます。グローバル変数を使用することで、作成するプロファイルに可搬性を持たせたり、パスに対するショートカットを定義したりすることができます。</para>
   <para>グローバル変数が便利になる例としては、たとえばユーザのホームディレクトリが異なる場所にマウントされるような環境があります。この場合、変数を使用すれば、影響する全てのプロファイルのホームディレクトリを書き換える代わりに、変数の値を書き換えるだけで済みます。グローバル変数は <filename>/etc/apparmor.d/tunables</filename> 内で定義し、 include ステートメントを利用して参照してください。ホームディレクトリであれば、 <filename>/etc/apparmor.d/tunables/home</filename> ファイル内に <envar>@{HOME}</envar> と <envar>@{HOMEDIRS}</envar> の変数定義が存在しています。</para>
   <para>一方のローカル変数は、プロファイルの冒頭部に記述します。これは chroot されたパスのベースディレクトリを指定するような場合に有用です。たとえば下記のようになります:</para>
<screen>@{CHROOT_BASE}=/tmp/foo
/sbin/rsyslogd {
...
# chrooted applications
@{CHROOT_BASE}/var/lib/*/dev/log w,
@{CHROOT_BASE}/var/log/** w,
...
}</screen>
   <para>下記の例では、 @{HOMEDIRS} でユーザのホームディレクトリが存在するディレクトリを設定し、 @{HOME} ではホームディレクトリの一覧を設定しています。その後、 @{HOMEDIRS} に対して、ホームディレクトリとして使用するディレクトリを追加しています。</para>
<screen>@{HOMEDIRS}=/home/
@{HOME}=@{HOMEDIRS}/*/ /root/
[...]
@{HOMEDIRS}+=/srv/nfs/home/ /mnt/home/</screen>
   <note>
    <para>現在の &aa; ツールでは、変数を利用するには、プロファイルを手作業で編集および管理しなければなりません。</para>
   </note>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-pattern-matching">
   <title>パターンマッチ</title>
   <para>プロファイル名にグロブ表記を使用することで、複数のバイナリにマッチするプロファイルを作成することができます。</para>
   <para>下記の例は、 <filename>/usr/bin</filename> もしくは <filename>/bin</filename> 内にある <command>foo</command> というバイナリに対するプロファイル例です。</para>
<screen>/{usr/,}bin/foo { ... }</screen>
   <para>下記の例では、 <filename>/bin/foo</filename> という実行ファイルの場合、正確にマッチする <literal>/bin/foo</literal> というプロファイルを選択します。それ以外の、たとえば <filename>/bin/fat</filename> というプログラムの場合は、 <literal>/bin/foo</literal> にマッチしませんので、 <literal>/bin/f*</literal> という名前の、 <literal>/bin/**</literal> よりも厳密にマッチするプロファイルを選択します。</para>
<screen>
/bin/foo { ... }

/bin/f*  { ... }

/bin/**  { ... }
</screen>
   <para>プロファイル名におけるグロブの使用例について、詳しくは <command>man 5 apparmor.d</command> で表示されるマニュアルページ (英語) 内の <literal>Globbing</literal> というセクションをお読みください。</para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-namespaces">
   <title>ネームスペース</title>
   <para>ネームスペースは異なるプロファイルセットを提供するために使用します。一方をシステム、他方を chroot 環境やコンテナなどに適用するためのものです。また、ネームスペースは階層構造を持っていて、親は子を参照できるものの、子は親を参照できなくなっています。また、ネームスペースは <literal>:</literal> で始まり、その後ろに英数字の名前を指定したあと、末尾に <literal>:</literal> と、必要に応じてダブルスラッシュ <literal>//</literal> を付けます。具体的には下記のようになります:</para>
<screen>:childNameSpace://</screen>
   <para>子ネームスペースに読み込まれたプロファイルには、ネームスペースの指定が冒頭に付与されます (親側からの見た目):</para>
<screen>:childNameSpace://apache</screen>
   <para>ネームスペースは <literal>change_profile</literal>　API のほか、名前付きプロファイル遷移でも指定することができます:</para>
<screen>/path/to/executable px -&gt; :childNameSpace://apache</screen>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-naming-attachment">
   <title>プロファイル名と接続仕様</title>
   <para>プロファイルには名前のほか、接続仕様を指定することができます。この仕組みにより、ユーザや管理者にとって分かりやすいプロファイル名を指定しながら、同時に複雑なパターンマッチング (詳しくは <xref linkend="sec-apparmor-profiles-pattern-matching"/> をお読みください) を設定することができます。たとえば下記のような既定のプロファイルがあるとします:</para>
<screen>/** { ... }</screen>
   <para>上記のようなプロファイルに対して、下記のように名前を設定することができます:</para>
<screen>profile default /** { ... }</screen>
   <para>パターンマッチングに対しても名前を設定することができます。たとえば:</para>
<screen>/usr/lib64/firefox*/firefox-*bin { ... }</screen>
   <para>上記のようなプロファイルに対して、下記のように名前を設定することができます:</para>
<screen>profile firefox /usr/lib64/firefox*/firefox-*bin { ... }</screen>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-glob-alias">
   <title>別名ルール</title>
   <para>別名ルールは、プロファイルパスのマッピングをサイト固有のレイアウトに変換するためのもう 1 つの方法です。これらは変数を利用してパスを書き換える方式の代替となるものであるほか、変数解決よりも後に動作する仕組みです。別名ルールでは、ルールがターゲットのプレフィクス内に存在するかのように、同じソースプレフィクスを持つルールを扱うよう指定することができます。</para>
<screen>alias /home/ -&gt; /usr/home/</screen>
   <para>上記のように指定すると、 <filename>/home/</filename> に対するマッチングが、 <filename>/usr/home/</filename> に対しても作用するようになります。たとえば:</para>
<screen>/home/username/** r,</screen>
   <para>上記のような設定が存在すると、下記の意味として使用されるようになります:</para>
<screen>/usr/home/username/** r,</screen>
   <para>別名ルールは、プロファイル自身を書き換えることなく、ルールのマッピングを素早く変更する機能も提供します。もちろん元のパスも従来通り許可されます。上述の例では、別名ルールを設定した後でも、 <filename>/home/</filename> は許可され続けます。</para>
   <para>また <literal>alias</literal> ルールを複数指定することで、同時に複数のターゲットを指定することもできます。</para>
<screen>alias /home/ -&gt; /usr/home/
alias /home/ -&gt; /mnt/home/</screen>
   <note>
    <para>現在の &aa; ツールでは、別名を利用するには、プロファイルを手作業で編集および管理しなければなりません。</para>
   </note>
   <tip>
    <para>グローバルな別名を設定したい場合は、 <filename>/etc/apparmor.d/tunables/alias</filename> ファイル内に設定してください。</para>
   </tip>
  </sect2>
 </sect1>
 <sect1 role="General" xml:id="sec-apparmor-profiles-perm">
  <title>ファイルアクセス許可のアクセスモード</title>

  <para>ファイルのアクセス許可モードを指定する場合、下記の中から組み合わせて指定してください:</para>

  <informaltable>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>
       <para><literal>r</literal></para>
      </entry>
      <entry>
       <para>読み込みモード</para>
      </entry>
     </row>
     <row>
      <entry>
       <para><literal>w</literal></para>
      </entry>
      <entry>
       <para>書き込みモード (<literal>a</literal> とは互いに排他関係にあります)</para>
      </entry>
     </row>
     <row>
      <entry>
       <para><literal>a</literal></para>
      </entry>
      <entry>
       <para>追記モード (<literal>w</literal> とは互いに排他関係にあります)</para>
      </entry>
     </row>
     <row>
      <entry>
       <para><literal>k</literal></para>
      </entry>
      <entry>
       <para>ファイル施錠 (ロック) モード</para>
      </entry>
     </row>
     <row>
      <entry>
       <para><literal>l</literal></para>
      </entry>
      <entry>
       <para>リンクモード</para>
      </entry>
     </row>
     <row>
      <entry>
       <para><literal>link <replaceable>ファイル</replaceable> -&gt; <replaceable>ターゲット</replaceable></literal></para>
      </entry>
      <entry>
       <para>リンク対ルール (他のアクセスモードとは共存不可)</para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>

  <sect2 xml:id="sec-apparmor-profiles-perm-r">
   <title>読み込みモード (r)</title>
   <para>指定したリソースに対して、プログラムからの読み込みアクセスを許可します。読み込みアクセスはシェルスクリプトなどのインタプリタ型のコンテンツで必要となるほか、コアダンプを実施できるかどうかの判断としても使われます。</para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-perm-w">
   <title>書き込みモード (w)</title>
   <para>指定したリソースに対して、プログラムからの書き込みアクセスを許可します。ファイルを削除する (アンリンクする) ような場合にも、この許可が必要となります。</para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-perm-a">
   <title>追記モード (a)</title>
   <para>指定したリソースに対して、プログラムからファイルの末尾への書き込みを許可します。 <literal>w</literal> モードとは異なり、追記モードではファイル内容の上書きが許可されないほか、ファイル名の変更や削除なども行うことができなくなります。追記の許可は通常、アプリケーション側からログファイルへの書き込みを行うような場合に指定すべきもので、これにより既に記録されているログコンテンツの上書きを禁止することができます。追記の許可は書き込みモードのサブセットとして規定されているため、 <literal>w</literal> と <literal>a</literal> のフラグの両方を指定することはできませんし、相互に排他関係にあるフラグとなります。</para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-perm-k">
   <title>ファイル施錠 (ロック) モード (k)</title>
   <para>指定したリソースに対して、プログラムからファイル施錠 (ロック) を許可します。従来のバージョンの &aa; では、アプリケーション側からアクセスができれば、施錠も許可されていました。新しいバージョンの &aa; では、個別のモードとして規定されるようになっていますので、どうしても施錠が必要なファイルにのみ許可を与えることができますので、サービス拒否 (Denial of Service; DoS) 攻撃のような攻撃シナリオを防ぐことができるようになっています。</para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-perm-link">
   <title>リンクモード (l)</title>
   <para>リンクモードはハードリンクに対するアクセスを許可します。リンクを作成すると、ターゲットとなるファイルと元のファイルは同じアクセス許可になります (ただしリンク先のファイルにはリンクモードの指定は不要です) 。</para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-perm-link-pair">
   <title>リンク対</title>
   <para>リンクモードでは任意のファイルに対してリンクを作成する許可を与えますが、これはリンクがターゲットによって付与された許可のサブセットを持っている場合に限られます (サブセット許可テストと呼びます) 。</para>
<screen>/srv/www/htdocs/index.html rl,</screen>
   <para>リンク元とリンク先を指定することで、リンク対ルールはハードリンクの作成方法に関して、より広い制御を提供します。リンク対ルールは、既定では標準ルールのリンク許可が必要とする、リンクのサブセット許可テストを強制しません。</para>
<screen>link /srv/www/htdocs/index.html -&gt; /var/www/index.html</screen>
   <para>テストを必要とするようルールを強制するには、 <literal>subset</literal> キーワードを指定します。下記の 2 つのルールは同じ意味になります:</para>
<screen>/var/www/index.html l,
link subset /var/www/index.html -&gt; /**,</screen>
   <note>
    <para>現時点では、リンク対ルールは &yast; やコマンドラインツールでサポートしていません。この種類のルールを使用したい場合は、プロファイルを手作業で編集してください。なお、ツール側ではリンク対ルールを操作することはありませんので、それらを含むプロファイルをツールで操作しても問題はありません。</para>
   </note>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-perm-file-allow">
   <title>任意指定の <literal>allow</literal> および <literal>file</literal> ルール</title>
   <para>プロファイル内では通常、許可するファイルを列挙する仕組みであるため、 <literal>allow</literal> キーワードを指定する必要はありません。逆に特定のファイルに対して明示的に禁止を設定したい場合にのみ、 <literal>deny</literal> キーワード (詳しくは <xref linkend="sec-apparmor-profiles-perm-deny"/> をお読みください) を指定してください。</para>
<screen>
allow file /example r,
allow /example r,
allow network,
</screen>
   <para>同様に、 <literal>file</literal> キーワードも指定不要です。これは、 <literal>network</literal> や <literal>mount</literal> などのルール種類のキーワードが現れない限り、自動的に <literal>file</literal> が指定されたものとして扱われるためです。</para>
<screen>file /example/rule r,</screen>
   <para>上記は、下記と同じ意味になります。</para>
<screen>/example/rule r,</screen>
   <para>下記のルールは全てのファイルに対するアクセスを許可します:</para>
<screen>file,</screen>
   <para>上記は、下記と同じ意味になります。</para>
<screen>/** rwmlk,</screen>
   <para>ファイルルールの場合、アクセス許可を先に記述することもできますが、基本的にはこれを使用すべきではありません。もしもこの方式を使用する場合は、ルールの冒頭で記述してください。これは特に、他の種類のルールと混在させるような場合に重要です。</para>
<screen>
/path rw,            # 古い形式
rw /path,            # 許可を先に記述した例
file rw /path,       # 明示的に 'file' キーワードを指定した例
allow file rw /path, # 明示的に 'allow' キーワードを指定した例
</screen>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-perm-owner">
   <title>所有者条件ルール</title>
   <para>ファイルルールでは、ファイルの所有者であった場合の特例を設定することができます (fsuid がファイルの uid と一致している必要があります) 。所有者である場合のルールを設定するには、ルールの前に <literal>owner</literal> キーワードを指定します。所有者条件ルールでも、通常のファイルルールと同様に設定を行うことができます。</para>
<screen>owner /home/*/** rw</screen>
   <para>所有者条件ルールとリンクルールの両方を使用した場合、テストはターゲットのファイルに対して行われ、リンクができるようになるためには、ユーザがファイルを所有していなければならなくなります。</para>
   <note>
    <title>通常のファイルルールの優先順位について</title>
    <para>所有者条件ルールは通常のファイルルールに対するサブセットとして扱われます。通常のファイルルールと所有者条件ルールが重複した場合、それらは一括で扱われます。たとえば下記のようなルールが存在したものとします:</para>
<screen>/foo r,
owner /foo rw,  # もしくは単に "w,"</screen>
    <para>この場合ルールが合成され、全てのユーザに対して <literal>r</literal> が許可され、所有者にのみ <literal>w</literal> が許可されます。</para>
   </note>
   <tip>
    <para>ファイルの所有者 <emphasis>以外の</emphasis> ユーザを明示的に指定したい場合は、 <literal>other</literal> キーワードを指定してください。</para>
<screen>owner /foo rw,
other /foo r,</screen>
   </tip>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-perm-deny">
   <title>拒否ルール</title>
   <para>拒否ルールは既知のオブジェクトに対して明示的な禁止を設定するための仕組みです。プロファイル生成ツールでは、拒否ルールによる既知の拒否については問い合わせを行いません。また、監査ログにもこの拒否は記録されなくなりますので、ログファイル内に不要な出力を行わないようにすることができます。なお、拒否ルールで拒否された内容も監査ログに出力したい場合は、拒否ルールの指定の前に <literal>audit</literal> を指定してください。</para>
   <para>拒否ルールと許可ルールを混在させることもできます。この場合、幅広く許可ルールを設定しておいて、特定のファイルにのみ明示的な拒否を設定することができるようになります。拒否ルールは所有者条件ルールと組み合わせることもできます。この場合、ユーザが所有するファイルへのアクセスを拒否することができます。下記の例では、ユーザのディレクトリ内にある全てに対して許可を与えるものの、 <filename>.ssh/</filename> 以下のファイルについては書き込みを禁止しています:</para>
<screen>deny /home/*/.ssh/** w,
owner /home/*/** rw,</screen>
   <para>ただし、拒否ルールを数多く設定してしまうようなことは避けてください。これは、プロファイルの可読性を損なうことになってしまうためです。しかしながら、拒否ルールを賢く使用することで、プロファイルを単純化することができます。そのため、ツールでは特定のファイルのみを生成し、グロブを伴う拒否ルールは作成しないようになっています。グロブを利用した拒否ルールを作成したい場合は、手作業でプロファイルを編集してください。ツール側では拒否ルールを操作することはありませんので、それらを含むプロファイルをツールで操作しても問題はありません。</para>
  </sect2>
 </sect1>

 <sect1 xml:id="sec-apparmor-profiles-mount">
  <title>マウントルール</title>
  <para>&aa; では、マウントやマウント解除の操作を制限することもできます。この制限では、ファイルシステムの種類やフラグなどを設定することもできます。ルールの書式は <command>mount</command> コマンドの書式をベースにしていて、 <literal>mount</literal> (マウント時), <literal>remount</literal> (再マウント時), <literal>umount</literal> (マウント解除時) のキーワードのいずれかを指定します。その他の条件指定は任意で、指定しない場合は全てに対してマッチするものとして扱われます。たとえばファイルシステムを指定しなかった場合、全てのファイルシステムに対してルールが適用されることになります。</para>
  <para>条件指定は <literal>options=</literal> もしくは <literal>options in</literal> で条件を指定します。</para>
  <para><literal>options=</literal> では、厳密に一致すべきオプションを指定します。</para>
  <screen>mount options=ro /dev/foo -E /mnt/,</screen>
  <para>上記は下記にマッチします:</para>
  <screen>&prompt.root;<command>mount -o ro /dev/foo /mnt</command></screen>
  <para>ただし、下記にはマッチしません:</para>
<screen>&prompt.root;<command>mount -o ro,atime /dev/foo /mnt</command>
&prompt.root;<command>mount -o rw /dev/foo /mnt</command></screen>
  <para><literal>options in</literal> では、使用されているマウントオプションが、ルール内で指定された値のうちのいずれかにマッチすることを求めます。</para>
  <screen>mount options in (ro,atime) /dev/foo -&gt; /mnt/,</screen>
  <para>上記は下記にマッチします:</para>
  <screen>&prompt.root;<command>mount -o ro /dev/foo /mnt</command>
&prompt.root;<command>mount -o ro,atime /dev/foo /mnt</command>
&prompt.root;<command>mount -o atime /dev/foo /mnt</command></screen>
  <para>ただし、下記にはマッチしません:</para>
<screen>&prompt.root;<command>mount -o ro,sync /dev/foo /mnt</command>
&prompt.root;<command>mount -o ro,atime,sync /dev/foo /mnt</command>
&prompt.root;<command>mount -o rw /dev/foo /mnt</command>
&prompt.root;<command>mount -o rw,noatime /dev/foo /mnt</command>
&prompt.root;<command>mount /dev/foo /mnt</command></screen>
  <para>複数の条件を設定したい場合は、 <literal>options</literal> を複数並べて記述してください。</para>
  <screen>mount options=ro options=atime</screen>
  <para>上記は下記にマッチします:</para>
<screen>&prompt.root;<command>mount -o ro /dev/foo /mnt</command>
&prompt.root;<command>mount -o atime /dev/foo /mnt</command></screen>
  <para>ただし、下記にはマッチしません:</para>
  <screen>&prompt.root;<command>mount -o ro,atime /dev/foo /mnt</command></screen>
  <para>複数の指定を行った場合、それらは個別に扱われます。</para>
<screen>mount options=ro,
mount options=atime,</screen>
  <para>上記は下記とは異なります:</para>
<screen>mount options=(ro,atime),
mount options in (ro,atime),</screen>
  <para>下記のルールでは、 <filename>/dev/foo</filename> デバイスを <filename>/mnt/</filename> にマウントすることを許可し、その際に読み込み専用か、 inode のアクセス日時のオプション指定を許すと共に、 'nodev' と 'user' のオプションの指定も許可しています:</para>
  <screen>mount options=(ro, atime) options in (nodev, user) /dev/foo -&gt; /mnt/,</screen>
  <para>上記を指定すると、下記が許可されるようになります:</para>
<screen>&prompt.root;<command>mount -o ro,atime /dev/foo /mnt</command>
&prompt.root;<command>mount -o nodev /dev/foo /mnt</command>
&prompt.root;<command>mount -o user /dev/foo /mnt</command>
&prompt.root;<command>mount -o nodev,user /dev/foo /mnt</command></screen>
 </sect1>

 <sect1 xml:id="sec-apparmor-profiles-pivot-root">
  <title>ピボットルートルール</title>
  <para>&aa; ではルートファイルシステムの変更を制限することもできます。書式は下記のとおりです:</para>
  <screen>pivot_root [oldroot=<replaceable>古いルート</replaceable>] <replaceable>新しいルート</replaceable></screen>
  <para>'pivot_root' 内で指定するパスはディレクトリであるため、 '/' で終わらなければなりません。</para>
  <screen># 任意のルートディレクトリを許可する
pivot_root,

# 新しいルートディレクトリは任意で、古いルートディレクトリのみ
# /mnt/root/old/ に制限する
pivot_root oldroot=/mnt/root/old/,

# 新しいルートディレクトリのみ /mnt/root/ に制限する
pivot_root /mnt/root/,

# 古いルートディレクトリを /mnt/root/old/ に、
# 新しいルートディレクトリを /mnt/root/ に制限する
pivot_root oldroot=/mnt/root/old/ /mnt/root/,

# 古いルートディレクトリを /mnt/root/old/ に、
# 新しいルートディレクトリを /mnt/root/ に制限し、
# /mnt/root/sbin/init のプロファイルに遷移する
pivot_root oldroot=/mnt/root/old/ /mnt/root/ -&gt; /mnt/root/sbin/init,</screen>
 </sect1>

 <sect1 xml:id="sec-apparmor-profiles-ptrace">
  <title>PTrace ルール</title>
  <para>&aa; では ptrace のシステムコールを制限することもできます。 ptrace ルールは蓄積型のルールで、 ptrace に対する許可は全ての ptrace ルールの和集合となります。ルール内でアクセスリストを指定していない場合は、暗黙に許可が発行されるようになります。</para>
  <para> <literal>trace</literal> および <literal>tracedby</literal> の許可では ptrace(2) の制御を、 <literal>read</literal> および <literal>readby</literal> の許可では proc(5) ファイルシステムへのアクセスや kcmp(2), futexes (get_robust_list(2)), パフォーマンストレースイベントの制御を、それぞれ行うことができます。</para>
  <para>ptrace が許可されるようにするには、 ptrace する側とされる側の両方のプロセスに対して、必要な許可を設定する必要があります。つまり、 ptrace する側のプロセスには <literal>trace</literal> の許可が、 ptrace される側のプロセスには <literal>tracedby</literal> の許可が必要となります。</para>
  <para>&aa; における PTrace ルールの例:</para>
<screen># 全ての ptrace アクセスを許可する
ptrace,

# 明示的に全ての ptrace アクセスを許可する
ptrace (read, readby, trace, tracedby),

# ptrace(2) の使用を明示的に禁止する
deny ptrace (trace),

# 無制限のプロセス (例: デバッガ) から自身に対する ptrace を許可する
ptrace (readby, tracedby) peer=unconfined,

# /usr/bin/foo 以下のプロファイルを利用している実行中プロセスに対して、 ptrace を許可する
ptrace (trace) peer=/usr/bin/foo,</screen>
 </sect1>

 <sect1 xml:id="sec-apparmor-profiles-signal">
  <title>シグナルルール</title>
  <para>&aa; ではプロセス間シグナルを制御することもできます。 &aa; の signal ルールは蓄積型のルールで、シグナルに対する許可は全ての signal ルールの和集合となります。ルール内でアクセスリストを指定していない場合は、暗黙に許可が発行されるようになります。</para>
  <para>なお、シグナルの送信側と受信側のプロセスは、両方とも必要な許可を得る必要があります。</para>
  <para>signal ルールの例:</para>
<screen><?dbfo keep-together="always"?># 全てのシグナルへのアクセスを許可する
signal,

# HUP と INT のシグナルのみ明示的に禁止する
deny signal (send) set=(hup, int),

# 無制限プロセスから自分自身へのシグナルを許可する
signal (receive) peer=unconfined,

# /usr/bin/foo 以下のプロファイルで動作するプロセスに対して、
# シグナルの送信を許可する
signal (send) peer=/usr/bin/foo,

# PID の存在チェックを許可する
signal (receive, send) set=("exists"),

# 組み込みの @{profile_name} 変数を使用して、自分自身へのシグナル送信を許可する
signal peer=@{profile_name},

# 2 種類のリアルタイムシグナルを許可する
signal set=(rtmin+0 rtmin+32),</screen>
 </sect1>

 <sect1 xml:id="sec-apparmor-profiles-exec">
  <title>実行モード</title>

  <para>実行モードとは名前付きプロファイル遷移とも呼ばれ、下記のモードが用意されています:</para>

  <informaltable>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>
       <para><literal>Px</literal></para>
      </entry>
      <entry>
       <para>専用プロファイル実行モード</para>
      </entry>
     </row>
     <row>
      <entry>
       <para><literal>Cx</literal></para>
      </entry>
      <entry>
       <para>専用ローカルプロファイル実行モード</para>
      </entry>
     </row>
     <row>
      <entry>
       <para><literal>Ux</literal></para>
      </entry>
      <entry>
       <para>無制限実行モード</para>
      </entry>
     </row>
     <row>
      <entry>
       <para><literal>ix</literal></para>
      </entry>
      <entry>
       <para>継承実行モード</para>
      </entry>
     </row>
     <row>
      <entry>
       <para><literal>m</literal></para>
      </entry>
      <entry>
       <para><command>mmap(2)</command> コールによる <literal>PROT_EXEC</literal> の許可</para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>

  <sect2 xml:id="sec-apparmor-profiles-exec-px">
   <title>専用プロファイル実行モード (px)</title>
   <para>このモードでは、特定のリソースを実行する際の &aa; のドメイン遷移で、専用のセキュリティプロファイルを求めるようになります。プロファイルが何も定義されていない場合、リソースへのアクセスは拒否されます。</para>
   <para><literal>Ux</literal> , <literal>ux</literal> , <literal>px</literal> , <literal>ix</literal> とは非互換です。</para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-exec-cx">
   <title>専用ローカルプロファイル実行モード (cx)</title>
   <para><literal>Px</literal> と同様に専用のプロファイルを求めますが、 <literal>Cx</literal> ではグローバルなプロファイルセットを検索するのではなく、現在のプロファイル内にあるローカルのプロファイルを検索します。このプロファイル遷移は、ヘルパーアプリケーションなどに対して個別のプロファイル設定を必要とするような場合に利用します。</para>
   <note>
    <title>専用ローカルプロファイル実行モード (cx) の制限について</title>
    <para>現時点では Cx による遷移はトップレベルのプロファイルに限定され、ハットや子プロファイル内では使用できません。この制限は将来的に撤廃される予定です。</para>
   </note>
   <para><literal>Ux</literal> , <literal>ux</literal> , <literal>Px</literal> , <literal>px</literal> , <literal>cx</literal> , <literal>ix</literal> とは非互換です。</para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-exec-ux">
   <title>無制限実行モード (ux)</title>
   <para>プログラムに対して、実行時にどの &aa; プロファイルも適用せずに実行することを指示します。このモードは、プログラム側からマシンの再起動など、特権処理を実行する必要がある場合に有用です。他の実行ファイル内に特権操作の機能を配置し、そこに対して実行権限を与えることで、制限を受けている全てのプロセスに課された制限を迂回できるようになります。なお、ルートプロセスに対して無制限処理を適用すると、 &aa; のポリシー自身も変更できることになります。制限の内容について、詳しくは <systemitem>apparmor(7)</systemitem> のマニュアルページをお読みください。</para>
   <para><literal>ux</literal> , <literal>px</literal> , <literal>Px</literal> , <literal>ix</literal> とは非互換です。</para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-exec-clean">
   <title>安全ではない実行モード</title>
   <para>実行モードのうち、小文字版 (具体的には <literal>px</literal> , <literal>cx</literal> , <literal>ux</literal> がそれに該当します) は限られた条件下でのみお使いください。これらの実行モードでは <envar>LD_PRELOAD</envar> などの環境変数の洗浄処理を行いませんので、呼び出す側のドメインは呼び出された側のリソースに対して、影響を与えすぎてしまうことがあります。これらのモードは、<envar>LD_PRELOAD</envar> などの変数を使用しなければならないため、子プロファイル側でどうしても制限を取り外さなければならない場合に <emphasis>のみ</emphasis> 使用すべきです。これらのモードを指定したプロファイルでは、セキュリティが弱くなることに注意してください。また、ご自身の責任でお使いください。</para>
   <remark>jsegitz 2014-07-15: if the child absolutely needs to use the environment of the calling process. (running unconfined isn't the important part here,
   you can you px and not run unconfined)</remark>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-exec-ix">
   <title>継承実行モード (ix)</title>
   <para><literal>ix</literal> は指定されたプログラムを <command>execve(2)</command> で実行する際、 &aa; ドメイン遷移を防止する仕組みです。その代わり、現在のプロファイルを継承して実行するようになります。</para>
   <para>このモードは、制限を受けているプログラムが他の制限付きのプログラムを呼び出していて、そのプログラム側で追加の許可を設定して欲しくない場合や、現在持っている許可を失いたくない場合に指定します。なお、 <literal>ix</literal> の実行モードでは権限を変更しないため、環境変数の洗浄を行う版はありません。</para>
   <para><literal>cx</literal> , <literal>ux</literal> , <literal>px</literal> とは非互換です。また、 <literal>m</literal> の許可を内包します。</para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-exec-m">
   <title>実行可能なマッピングの許可 (m)</title>
   <para>このモードはファイルをメモリにマッピングする際、 <command>mmap(2)</command> の呼び出しで <envar>PROT_EXEC</envar> フラグを付けることを許可します。このフラグにより、メモリ内容を実行できるようにします。これは特定のアーキテクチャ向けに用意されている、実行不可データページの機能を利用するものです。これにより、ファイルを経由した不正なコード実行を防ぐことができます。 &aa; ではこのモードを利用し、行儀のよいプログラム (もしくは実行不可メモリへのアクセス制御を強制するアーキテクチャ上の全てのプログラム) に対して、ライブラリとして使用できるファイルを制限し、 <command>ld(1)</command> , <envar>LD_PRELOAD</envar> , <envar>LD_LIBRARY_PATH</envar> に対して設定される、無効な <option>-L</option> フラグの効果を制限することができます。詳しくは <command>ld.so(8)</command> のマニュアルページをお読みください。</para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-exec-named">
   <title>名前付きプロファイル遷移</title>
   <para>既定では、 <literal>px</literal> と <literal>cx</literal> (およびそれらのクリーン実行版) の遷移では、実行されるプログラム名に一致するプロファイルに遷移します。名前付きプロファイル遷移では、遷移先のプロファイル名を指定することができます。これは単一のプロファイルを複数のバイナリで共有する必要があるような場合や、名前以外の方法で異なるプロファイルを使用する必要があるような場合に有用です。名前付きプロファイル遷移は <literal>cx</literal> , <literal>Cx</literal> , <literal>px</literal> , <literal>Px</literal> と併用することができます。現時点では、プロファイルごとに 20 種類までの名前付きプロファイル遷移を設定することができます。</para>
   <para>名前付きプロファイル遷移では、 <literal>-&gt;</literal> 記号を利用して、遷移先のプロファイル名を指定します:</para>
<screen>/usr/bin/foo
{
  /bin/** px -&gt; shared_profile,
  ...
  /usr/*bash cx -&gt; local_profile,
  ...
  profile local_profile
  {
    ...
  }
}
</screen>
   <note>
    <title>通常の遷移と名前付き遷移の違いについて</title>
    <para>グロブ機能を利用することで、通常型のプロファイルでは <quote>一対多</quote> の関係を設定することができます。たとえば <literal>/bin/** px</literal> のように指定すると、 <filename>/bin/ping</filename> , <filename>/bin/cat</filename> などのプログラムに対応したプロファイルに遷移することになります。</para>
    <para>一方の名前付きプロファイル遷移では、 <quote>多対一</quote> の関係を設定することができます。ルールに該当するものであれば、その名前にかかわらず常に同じプロファイルに遷移することになります。</para>
    <para>名前付きプロファイル遷移は、ログ内では <literal>Nx</literal> モードとして記録されます。また、遷移先のプロファイル名は <literal>name2</literal> として示されます。</para>
   </note>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-exec-fallback">
   <title>プロファイル遷移に対するフォールバックモード</title>
   <para><literal>px</literal> と <literal>cx</literal> はいずれも、強い依存関係を指定していることになります。つまり、指定したプロファイルが存在しない場合、実行は失敗することになります。継承フォールバックの場合は実行が成功しますが、現在のプロファイルを継承して動作することになります。継承フォールバックを指定するには、 <literal>cx</literal> , <literal>Cx</literal> , <literal>px</literal> , <literal>Px</literal> に <literal>ix</literal> を加えて、 <literal>cix</literal> , <literal>Cix</literal> , <literal>pix</literal> , <literal>Pix</literal> のように指定してください。</para>
<screen>/path Cix -&gt; プロファイル名,</screen>
   <para>もしくは、下記のように指定してもかまいません:</para>
<screen>Cix /path -&gt; プロファイル名,</screen>
   <para>なお、 <literal>-&gt; プロファイル名</literal> の指定は任意です。</para>
   <para>同じことが無制限実行モードである <literal>ux</literal> にも適用できます。これらを組み合わせると、 <literal>cux</literal> , <literal>CUx</literal> , <literal>pux</literal> , <literal>PUx</literal> になります。これらのモードは、指定したプロファイルが見つからない場合、 <quote>無制限に</quote> 実行するモードにフォールバックすることになります。</para>
<screen>/path PUx -&gt; プロファイル名,</screen>
   <para>もしくは、下記のように指定してもかまいません:</para>
<screen>PUx /path -&gt; profile_name,</screen>
   <para>なお、 <literal>-&gt; プロファイル名</literal> の指定は任意です。</para>
   <para>フォールバックモードは、名前付きプロファイル遷移でも使用することができます。</para>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-exec-variables">
   <title>実行モード内での変数設定</title>
   <para>Px, Cx, Ux の実行モードのうちのいずれかを選択した場合、子プロセスが継承する環境変数のうち、下記の変数の内容が削除されることに注意してください。そのため、これらの変数に依存して動作するアプリケーションやプロセスが存在した場合、 Px, Cx, Ux のフラグを指定すると、正しく動作しなくなってしまいます:</para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para><envar>GCONV_PATH</envar></para>
    </listitem>
    <listitem>
     <para><envar>GETCONF_DIR</envar></para>
    </listitem>
    <listitem>
     <para><envar>HOSTALIASES</envar></para>
    </listitem>
    <listitem>
     <para><envar>LD_AUDIT</envar></para>
    </listitem>
    <listitem>
     <para><envar>LD_DEBUG</envar></para>
    </listitem>
    <listitem>
     <para><envar>LD_DEBUG_OUTPUT</envar></para>
    </listitem>
    <listitem>
     <para><envar>LD_DYNAMIC_WEAK</envar></para>
    </listitem>
    <listitem>
     <para><envar>LD_LIBRARY_PATH</envar></para>
    </listitem>
    <listitem>
     <para><envar>LD_ORIGIN_PATH</envar></para>
    </listitem>
    <listitem>
     <para><envar>LD_PRELOAD</envar></para>
    </listitem>
    <listitem>
     <para><envar>LD_PROFILE</envar></para>
    </listitem>
    <listitem>
     <para><envar>LD_SHOW_AUXV</envar></para>
    </listitem>
    <listitem>
     <para><envar>LD_USE_LOAD_BIAS</envar></para>
    </listitem>
    <listitem>
     <para><envar>LOCALDOMAIN</envar></para>
    </listitem>
    <listitem>
     <para><envar>LOCPATH</envar></para>
    </listitem>
    <listitem>
     <para><envar>MALLOC_TRACE</envar></para>
    </listitem>
    <listitem>
     <para><envar>NLSPATH</envar></para>
    </listitem>
    <listitem>
     <para><envar>RESOLV_HOST_CONF</envar></para>
    </listitem>
    <listitem>
     <para><envar>RES_OPTIONS</envar></para>
    </listitem>
    <listitem>
     <para><envar>TMPDIR</envar></para>
    </listitem>
    <listitem>
     <para><envar>TZDIR</envar></para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 xml:id="sec-apparmor-profiles-exec-clean-keywords">
   <title><literal>safe</literal> キーワードおよび <literal>unsafe</literal> キーワード</title>
   <para>実行モードの修飾子を使用する代わりに、 <literal>safe</literal> や <literal>unsafe</literal> のキーワードを使用することもできます。たとえば、</para>
<screen>/example_rule Px,</screen>
   <para>上記は下記のいずれかと同じ意味になります:</para>
<screen>safe /example_rule px,
safe /example_rule Px,
safe px /example_rule,
safe Px /example_rule,</screen>
   <para>また、</para>
<screen>/example_rule px,</screen>
   <para>上記は、下記のいずれかと同じ意味になります:</para>
<screen>unsafe /example_rule px,
unsafe /example_rule Px,
unsafe px /example_rule,
unsafe Px /example_rule,</screen>
   <para><literal>safe</literal> / <literal>unsafe</literal> のキーワードは相互に排他なキーワードであり、ファイルルールの <literal>owner</literal> の後ろに指定することもできます。書式として記述すると、下記のようになります:</para>
<screen>[audit] [deny] [owner] [safe|unsafe] ファイルルール</screen>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-apparmor-profiles-rlimit">
  <title>リソース制限制御</title>

  <para>&aa; では、アプリケーションのリソース制限 (rlimits/ulimits としても知られています) を設定したり制御したりすることができます。既定では &aa; はアプリケーションの rlimits を制限せず、プロファイル内に書かれた制限にのみ従うようになっています。リソース制限に関する詳細については、 <systemitem>setrlimit(2)</systemitem> , <systemitem>ulimit(1)</systemitem> , <systemitem>ulimit(3)</systemitem> の各マニュアルページをお読みください。</para>

  <para>&aa; ではシステム側に用意された rlimits を活用しているだけであり、通常発生するような追加の監査を提供するものではありません。また、システム側で設定された rlimits の値を増やすこともできず、 &aa; ではアプリケーションに対して設定されたリソース制限を減らす設定のみを適用することができます。</para>

  <para>設定された値は子プロセスに対しても引き継がれ、新しいプロファイルに遷移した場合であっても、アプリケーションの制限がなくなった場合でも、制限が残ります。そのため、アプリケーションが新しいプロファイルに遷移した場合、遷移先のプロファイルではアプリケーションの rlimits をさらに減らすことしかできなくなります。</para>

  <para>&aa; の rlimit ルールでは、アプリケーションのハードリミットの仲介処理も行っています。アプリケーション側では、プロファイル内で指定された値よりもハードリミットを増やすことはできませんが、新しいプロファイル内で制限を増やすように設定しておいて、そのプロファイルに遷移するように設定することは自由に行うことができます。</para>

  <para>&aa; での rlimit の制御においてソフトリミットは、ハードリミットと同じか、より小さい値に設定されているようにするだけで、それ以外の制御は行いません。</para>

  <para>&aa; のハードリミットルールは下記のような書式で指定します:</para>

<screen>set rlimit <replaceable>リソース</replaceable> &lt;= <replaceable>値</replaceable>,</screen>

  <para><replaceable>リソース</replaceable> と <replaceable>値</replaceable> には、それぞれ下記のものを指定することができます:</para>

  <variablelist>
   <varlistentry>
    <term><literal>cpu</literal></term>
    <listitem>
     <para>CPU 時間の制限 (秒単位) 。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>fsize</literal> , <literal>data</literal> , <literal>stack</literal> , <literal>core</literal> , <literal>rss</literal> , <literal>as</literal> , <literal>memlock</literal> , <literal>msgqueue</literal></term>
    <listitem>
     <para>バイト単位での数値、もしくは K/KB (キロバイト), M/MB (メガバイト), G/GB (ギガバイト) の接尾辞付きの数値を指定することができます。例:</para>
<screen>rlimit data &lt;= 100M,</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>fsize</literal> , <literal>nofile</literal> , <literal>locks</literal> , <literal>sigpending</literal> , <literal>nproc</literal> , <literal>rtprio</literal></term>
    <listitem>
     <para>0 以上の数値を指定することができます。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>nice</literal></term>
    <listitem>
     <para>-20 から 19 までの数値を指定することができます。</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <note>
  <para>nproc のリソース制限は、その他のリソース制限とは異なる動作になっています。標準的なプロセス制限ではなく、任意の時点におけるプロファイル内の最大プロセス数を意味します。新しいプロセスを作成する際、プロファイルで指定された制限に引っかかると、現在実行中のプロセス数が減らない限り、処理が失敗することになります。</para>
  </note>

  <note>
   <para>現時点では、ツールを利用してプロファイル内に rlimit のルールを追加することはできません。 rlimit の制御を追加する唯一の方法は、手作業でテキストファイルを利用してプロファイルを編集する方法です。なお、 rlimit を含むプロファイルをツールで編集しても、 rlimit の項目を削除することはありませんので安全です。</para>
  </note>
 </sect1>
 <sect1 xml:id="sec-apparmor-profiles-audit">
  <title>監査ルール</title>

  <para>&aa; では、特定のルールに監査を設定して、監査ログ内にメッセージを出力するようにすることができます。指定したルールに対して監査メッセージを出力するように設定するには、ルールの前に <literal>audit</literal> キーワードを指定します:</para>

<screen>audit /etc/foo/*        rw,</screen>

  <para>特定の処理時にのみ監査メッセージを出力させたい場合は、ルールを 2 つに分割することをお勧めします。下記の例では、ファイルを書き込み用に開いた場合は監査メッセージを出力するものの、読み込み用に開いた場合は出力しません:</para>

<screen>audit /etc/foo/*  w,
/etc/foo/*        r,</screen>

  <note>
   <para>監査メッセージはそれぞれの読み込みや書き込み処理で生成されるのではなく、ファイルが読み込み用や書き込み用に開いた際に出力されます。</para>
  </note>

  <para>監査ルールには <literal>owner</literal> / <literal>other</literal> の条件付きファイルルールを追加することもできます。これにより、ユーザが所有するファイルである場合や、ユーザが所有していないファイルである場合にのみ、監査メッセージを出力することができるようになります:</para>

<screen>audit owner /home/*/.ssh/**       rw,
audit other /home/*/.ssh/**       r,</screen>
 </sect1>
</chapter>
