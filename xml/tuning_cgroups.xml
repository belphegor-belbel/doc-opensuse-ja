<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter [
<!ENTITY % entities SYSTEM "entity-decl.ent">
%entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha-tuning-cgroups">

 <title>カーネルコントロールグループ</title>
 <info>
  <abstract>
   <para>カーネルコントロールグループ ( <quote>cgroups</quote> ) は、プロセスに対してハードウエアやシステムの資源を割り当てたり、制限したりするための仕組みです。この機能を利用することで、プロセスをツリー構造で管理することができるようになります。</para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker>
   </dm:bugtracker>
  </dm:docmanager>
 </info>

 <sect1 xml:id="sec-tuning-cgroups-overview">
  <title>概要</title>
  <para>それぞれのプロセスは正確に 1 つの管理用 cgroup に割り当てられます。 cgroup は階層構造型のツリー (木構造) として管理するもので、その構造の任意の箇所 (枝) もしくは 1 つのプロセスに対して、 CPU やメモリ、ディスクの I/O やネットワーク帯域などのリソース制限を割り当てます。</para>
  <para>&productname; では、 &systemd; が cgroup を利用してグループ内の全てのプロセスを管理しています。この場合、 &systemd; はグループをスライスと呼んでいます。 &systemd; には、 cgroup の設定を行なうためのインターフェイスも用意されています。</para>
  <para><command>systemd-cgls</command> コマンドでは、階層構造を表示することができます。</para>
  <para>本章は概要のみを説明しています。詳しい説明については、列挙されている参照先をお読みください。</para>
 </sect1>

 <sect1 xml:id="sec-tuning-cgroups-usage">
  <title>リソース制限の設定</title>
  <note>
    <title>暗黙のリソース消費について</title>
    <para>暗黙のうちに消費され、実行環境によって異なるリソースが存在することに注意してください。これにはたとえば、ライブラリやカーネル内のデータ構造のほか、利用しているユーティリティの fork() 処理の振る舞い、計算の効率性などがあります。このようなことから、実行環境を変えた場合は、リソース制限を再計算する必要があります。</para>
  </note>
  <para><literal>cgroup</literal> に対する制限は、 <command>systemctl set-property</command> コマンドで設定します。書式は下記のとおりです:</para>
  <screen>&prompt.root;<command>systemctl set-property [--runtime] <replaceable>名前</replaceable> <replaceable>プロパティ_1</replaceable>=<replaceable>値</replaceable> [<replaceable>プロパティ_2</replaceable>=<replaceable>値</replaceable>]</command></screen>
  <para>必要であれば <option>--runtime</option> オプションを指定することもできます。このオプションを指定すると、再起動後には指定した制限が適用されなくなります。</para>
  <para>なお、 <replaceable>名前</replaceable> には &systemd; のスライス名やスコープ名、ソケット名やマウント名、スワップ名を指定します。また、プロパティには下記のものがあります:</para>
  <variablelist>
   <varlistentry>
    <term><literal>CPUAccounting=</literal> <option>[yes|no]</option></term>
    <listitem>
     <para>CPU 使用率の算出を行なうかどうかを指定します。値には <literal>yes</literal> (はい) または <literal>no</literal> (いいえ) のいずれかを指定することができます。</para>
     <para>例:</para>
     <screen>&prompt.root;<command>systemctl set-property user.slice CPUAccounting=yes</command></screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>CPUQuota=</literal> <replaceable>パーセント値</replaceable></term>
    <listitem>
     <para>プロセスに対して CPU 時間の割り当てを行ないます。この値はパーセント単位で指定するため、末尾に <literal>%</literal> を付けて指定します。この設定を行なうと、 <literal>CPUAccounting=yes</literal> が設定されたものとして扱われます。</para>
     <para>例:</para>
     <screen>&prompt.root;<command>systemctl set-property user.slice CPUQuota=50%</command></screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>MemoryAccounting=</literal> <option>[yes|no]</option></term>
    <listitem>
     <para>メモリ使用率の算出を行なうかどうかを指定します。値には <literal>yes</literal> (はい) または <literal>no</literal> (いいえ) のいずれかを指定することができます。</para>
     <para>例:</para>
     <screen>&prompt.root;<command>systemctl set-property user.slice MemoryAccounting=yes</command></screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>MemoryLow=</literal> <replaceable>容量</replaceable></term>
    <listitem>
     <para>プロセスからの未使用メモリが指定した容量より少ない場合、メモリを他の用途に再利用しないようにします。 <replaceable>容量</replaceable> の値には K (キロ), M (メガ), G (ギガ), T (テラ) の各接頭辞を使用することができます。この設定を行なうと、 <literal>MemoryAccounting=yes</literal> が設定されたものとして扱われます。</para>
     <para>例:</para>
     <screen>&prompt.root;<command>systemctl set-property nginx.service MemoryLow=512M</command></screen>
     <note>
      <title>統合型のコントロールグループ階層構造について</title>
      <para>この設定は、統合型のコントロールグループ階層構造を使用している場合にのみ利用することができます。また、 <option>MemoryLimit=</option> の設定が無効化されます。統合型のコントロールグループ階層構造を使用するには、 &grub; ブートローダのカーネルコマンドラインパラメータに対して、 <option>systemd.unified_cgroup_hierarchy=1</option> を追加してください。なお、 &grub; の設定に関する詳細は、 <xref linkend="cha-grub2"/> をお読みください。</para>
     </note>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>MemoryHigh=</literal> <replaceable>容量</replaceable></term>
    <listitem>
     <para>この制限以上にメモリを使用した場合、プロセスからできる限り積極的にメモリを取り除こうとする動きをします。 <replaceable>容量</replaceable> の値には K (キロ), M (メガ), G (ギガ), T (テラ) の各接頭辞を使用することができます。この設定を行なうと、 <literal>MemoryAccounting=yes</literal> が設定されたものとして扱われます。</para>

     <para>例:</para>
     <screen>&prompt.root;<command>systemctl set-property nginx.service MemoryHigh=2G</command></screen>
     <note>
      <title>統合型のコントロールグループ階層構造について</title>
      <para>この設定は、統合型のコントロールグループ階層構造を使用している場合にのみ利用することができます。また、 <option>MemoryLimit=</option> の設定が無効化されます。統合型のコントロールグループ階層構造を使用するには、 &grub; ブートローダのカーネルコマンドラインパラメータに対して、 <option>systemd.unified_cgroup_hierarchy=1</option> を追加してください。なお、 &grub; の設定に関する詳細は、 <xref linkend="cha-grub2"/> をお読みください。</para>
     </note>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>MemoryMax=</literal> <replaceable>容量</replaceable></term>
    <listitem>
     <para>メモリの最大値を設定することができます。プロセスがこの値を超えてメモリを確保した場合、プロセスは kill されます。 <replaceable>容量</replaceable> の値には K (キロ), M (メガ), G (ギガ), T (テラ) の各接頭辞を使用することができます。この設定を行なうと、 <literal>MemoryAccounting=yes</literal> が設定されたものとして扱われます。</para>
     <para>例:</para>
     <screen>&prompt.root;<command>systemctl set-property nginx.service MemoryMax=4G</command></screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>DeviceAllow=</literal></term>
    <listitem>
     <para>読み込み ( <literal>r</literal> ), 書き込み ( <literal>w</literal> ), mknod ( <literal>m</literal> ) のアクセスを許可します。このコマンドの場合、デバイスノードの指定と、スペースを入れて <literal>r</literal> , <literal>w</literal>, <literal>m</literal> の一覧を指定する必要があります。</para>
     <para>例:</para>
     <screen>&prompt.root;<command>systemctl set-property system.slice DeviceAllow="/dev/sdb1 r"</command></screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>DevicePolicy=</literal> <option>[auto|closed|strict]</option></term>
    <listitem>
     <para><literal>strict</literal> に設定した場合、 <literal>DeviceAllow</literal> に列挙したデバイスにのみアクセスを許可するようになります。 <literal>closed</literal> を指定すると、 <filename>/dev/null</filename> , <filename>/dev/zero</filename> , <filename>/dev/full</filename> , <filename>/dev/random</filename> , <filename>/dev/urandom</filename> などの標準疑似デバイスにもアクセスを許可するようになります。 <literal>auto</literal> を設定した場合は、 <literal>DeviceAllow</literal> でルールが設定されない場合、全てのデバイスへのアクセスが許可されるようになります。既定値は <literal>auto</literal> です。</para>
    </listitem>
   </varlistentry>
  </variablelist>
  <para>プロパティに対する詳細と完全な一覧については、 <command>man systemd.resource-control</command> で表示されるマニュアルページをお読みください。</para>
 </sect1>
 
 <sect1 xml:id="sec-tuning-cgroups-tasksmax">
  <title>TasksMax を利用した fork ボムの防止</title>
   <para>&systemd; 228 では <literal>DefaultTasksMax</literal> の制限が 512 に設定されています。これは systemd の各ユニットに対して、作成できるプロセス数の制限を行なうための仕組みで、それ以前のバージョンでは制限がありませんでした。このように設定を行なったのは、 fork によって作成される過剰なプロセスやスレッドによってシステム資源が枯渇してしまうのを防ぐ、セキュリティ改善のためのものです。</para> 
   <para>しかしながら、この既定値は全ての用途に対して適用可能なものではありません。また、 CPU やメモリの使用量に対する直接的な制限ではありませんので、 512 に設定してもシステムの安定性を保つことができるかどうかはわかりませんし、データベースシステムなどのように 512 個以上のプロセスを動作させなければならない場合もあります。 &systemd; 234 では、この値が 15% (カーネル側に設定されたプロセス数の最大値である 32768 の 15% 。詳しくは <command>cat /proc/sys/kernel/pid_max</command> をご覧ください) に設定されていますが、必要に応じて設定ファイルで変更することができます。具体的には、 <filename>/etc/systemd/system.conf</filename> ファイルを編集して設定を行なってください。なお、下記ではそれ以外の方法について説明しています。</para>
  
 <sect2 xml:id="sec-tasksmax-defaults">
  <title>現時点での既定の TasksMax 値の検出</title>
   <para>&sle; では、 systemd のユニットやユーザスライスに対する提供元の既定値を上書きするため、独自の設定ファイルが 2 つ用意され、いずれも <literal>infinity</literal> に設定されています。 1 つめの <filename>/usr/lib/systemd/system.conf.d/20-suse-defaults.conf</filename> には、下記のような設定が書かれています:</para>
   <screen>
[Manager]
DefaultTasksMax=infinity
   </screen>
   <para>もう 1 つの存在である <filename>/usr/lib/systemd/system/user-.slice.d/20-suse-defaults.conf</filename> には、下記のような設定が書かれています:</para>
   <screen>[Slice]
TasksMax=infinity
   </screen>
  <para><literal>infinity</literal> は無制限の意味です。特に要件がなければ既定値を変更する必要はありませんが、必要であれば設定を変更してください。</para>
</sect2>

<sect2 xml:id="sec-edit-taskmax-default">
 <title>DefaultTasksMax 値の設定</title>
  <para>グローバルな <literal>DefaultTasksMax</literal> の値を変更したい場合は、設定を上書きするための新しい設定ファイル <filename>/etc/systemd/system.conf.d/10-system-tasksmax.conf</filename> を作成して対応してください。この設定ファイルには、下記のような内容を記述します (下記の例では、 systemd のユニットごとに最大 256 個までのタスク制限を設定します):</para>
   <screen>
[Manager]
DefaultTasksMax=256
</screen>
   <para>新しい設定を読み込んで、設定が反映されたことを確認します:</para>
   <screen>&prompt.sudo;systemctl daemon-reload
&prompt.user;systemctl show --property DefaultTasksMax
DefaultTasksMax=256
   </screen>
   <para>設定値はお使いのシステムの要件に合わせて指定してください。また、特定のサービスに限定して制限を高くすることもできます。たとえば MariaDB で設定を変更したい場合、まずは現在の設定値を確認します:</para>
   <screen>
&prompt.user;systemctl status mariadb.service
  ● mariadb.service - MariaDB database server
   Loaded: loaded (/usr/lib/systemd/system/mariadb.service; disabled; vendor preset&gt;
   Active: active (running) since Tue 2020-05-26 14:15:03 PDT; 27min ago
     Docs: man:mysqld(8)
           https://mariadb.com/kb/en/library/systemd/
 Main PID: 11845 (mysqld)
   Status: "Taking your SQL requests now..."
    Tasks: 30 (limit: 256)
   CGroup: /system.slice/mariadb.service
           └─11845 /usr/sbin/mysqld --defaults-file=/etc/my.cnf --user=mysql
   </screen>
   <para><quote>Tasks</quote> 以下には現在動作中のタスク数 (30 個) と上限 (256 個) が示されています。負荷の高いデータベースシステムとしては不十分な値であることから、たとえば MariaDB のみを 8192 個までに拡大してみることにします。設定値を変更するには、 <command>systemctl edit</command> コマンドを実行して、下記のような設定を記入します:</para>
   <screen>&prompt.sudo;systemctl edit mariadb.service
       
[Service]
TasksMax=8192

&prompt.user;systemctl status mariadb.service 
● mariadb.service - MariaDB database server
   Loaded: loaded (/usr/lib/systemd/system/mariadb.service; disabled; vendor preset: disab&gt;
  Drop-In: /etc/systemd/system/mariadb.service.d
           └─override.conf
   Active: active (running) since Tue 2020-06-02 17:57:48 PDT; 7min ago
     Docs: man:mysqld(8)
           https://mariadb.com/kb/en/library/systemd/
  Process: 3446 ExecStartPre=/usr/lib/mysql/mysql-systemd-helper upgrade (code=exited, sta&gt;
  Process: 3440 ExecStartPre=/usr/lib/mysql/mysql-systemd-helper install (code=exited, sta&gt;
 Main PID: 3452 (mysqld)
   Status: "Taking your SQL requests now..."
    Tasks: 30 (limit: 8192)
   CGroup: /system.slice/mariadb.service
           └─3452 /usr/sbin/mysqld --defaults-file=/etc/my.cnf --user=mysql
   </screen>
   <para><command>systemctl edit</command> コマンドは <filename>/etc/systemd/system/mariadb.service.d/override.conf</filename> という名前の上書き用設定ファイルを作成します。ここには既存のユニットファイルに対する上書き値のみが保存されます。もちろん 8192 でなくてもかまいません。お使いの要件に合わせて設定してください。</para>
</sect2>
   
<sect2>
    <title>ユーザに対する既定の TasksMax 制限</title>
   <para>ユーザに対する既定の制限値は十分に高く設定されています。これは、ユーザセッションではより多くのリソースを必要とするためです。独自の制限を設定したい場合は、 <filename>/etc/systemd/system/user-.slice.d/user-taskmask.conf</filename> のような設定ファイルを作成し、その中に設定値を記述してください。下記の例では、タスクの最大値を 16284 に設定しています:</para>
   <screen>
[Slice]
TasksMax=16284
   </screen>
   <para>あとは systemd に対して設定値の再読み込みを指示し、設定が変更されたことを確認します:</para>
   <screen>&prompt.sudo;systemctl daemon-reload
       
&prompt.user;systemctl show --property TasksMax user-.slice
TasksMax=16284

&prompt.user;systemctl show --property TasksMax user-1000.slice
TasksMax=16284
   </screen>
   <para>具体的にどのような設定値にすべきかについては、お使いの用途とシステム側に搭載されているリソースのほか、他のリソース設定によっても異なります。 TasksMax の値が低すぎる場合は、 "Failed to fork (Resources temporarily unavailable)" (fork に失敗した (リソースが一時的に利用できなくなっている)), "Can't create thread to handle new connection" (新しい接続を処理するためのスレッドが作成できない), "Error: Function call 'fork' failed with error code 11, 'Resource temporarily unavailable'" (エラーコード 11 (リソースが一時的に利用できなくなっている) で fork の関数呼び出しが失敗した) などのエラーが発生することになります。</para>
   <para>systemd でのシステムリソースの制限の設定方法について、詳しくは<literal>systemd.resource-control (5)</literal> をお読みください。</para>
</sect2>
</sect1>

<sect1>
    <title>さらなる情報</title>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>カーネルのドキュメンテーション <filename>/usr/src/linux/Documentation/cgroups</filename> (<systemitem>kernel-source</systemitem> パッケージ内)</para>
   </listitem>
   <listitem>
    <para><link xlink:href="http://lwn.net/Articles/604609/"/>: Brown, Neil: Control Groups Series (2014 年, 7 部構成)</para>
   </listitem>
   <listitem>
    <para><link xlink:href="http://lwn.net/Articles/243795/"/>: Corbet, Jonathan: Controlling memory use in containers (2007 年)</para>
   </listitem>
   <listitem>
    <para><link xlink:href="http://lwn.net/Articles/236038/"/>: Corbet, Jonathan: Process containers (2007 年)</para>
   </listitem>
  </itemizedlist>
 </sect1>
</chapter>
