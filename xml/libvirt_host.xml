<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter [
<!ENTITY % entities SYSTEM "entity-decl.ent">
%entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha-libvirt-host">
 <title>&vmhost; の準備</title>
 <para>ゲスト側の仮想マシンをインストールする前に、まずは &vmhost; 内に必要なリソースを用意して環境を整える必要があります。具体的には下記の設定を行う必要があります:</para>
 <itemizedlist>
  <listitem>
   <para><emphasis>ネットワーク</emphasis>: ホストが提供するネットワークと接続するための機能に関する設定を行います。</para>
  </listitem>
  <listitem>
   <para><emphasis>ストレージプール</emphasis>: ホストが提供するストレージをゲスト側からアクセスできるようにして、ディスクイメージ等を保存できるようにします。</para>
  </listitem>
 </itemizedlist>
 <sect1 xml:id="libvirt-host-network">
  <title>ネットワークの設定</title>

  <para>&vmguest; に対してネットワーク機能を提供するには、下記の 2 種類の方法があります:</para>

  <itemizedlist>
   <listitem>
    <para><emphasis>ネットワークブリッジ</emphasis>: ゲスト側にネットワーク接続を提供する設定の既定値で、推奨される方式です。</para>
   </listitem>
   <listitem>
    <para><emphasis>仮想ネットワーク</emphasis>: 転送機能を利用してネットワーク接続を提供する方式です。</para>
   </listitem>
  </itemizedlist>

  <sect2 xml:id="libvirt-networks-bridged">
   <title>ネットワークブリッジ</title>
   <para>ネットワークブリッジは、 &vmguest; に対してレイヤ 2 スイッチの機能を提供します。レイヤ 2 スイッチは、ポート間のパケット転送の際にレイヤ 2 イーサネットパケットを利用し、 MAC アドレスをベースにして宛先を判断します。これにより、 &vmhost; から &vmguest; に対して、レイヤ 2 アクセスのネットワークを提供することになります。これは、 &vmguest; の仮想的なイーサネットケーブルがイーサネットハブに接続され、そこからホスト自身やホスト内で動作する他の &vmguest; に接続できる形態と同じになります。この設定は、 <emphasis>共有物理デバイス</emphasis> と称することもあります。</para>
   <para>ネットワークブリッジは、 &productname; を &kvm; または &xen; のハイパーバイザとして設定した際の既定の設定になっています。これは &vmguest; と &vmhost; の LAN を単純に接続できるため、お勧めの方法でもあります。</para>
   <para>ネットワークブリッジを作成する際に使用すべきツールは、 &vmhost; 側でのネットワーク接続を管理する際に使用しているサービスによって異なります:</para>
   <itemizedlist>
    <listitem>
     <para>ネットワーク接続を <systemitem>wicked</systemitem> で管理している場合は、 &yast; またはコマンドラインツールを利用してネットワークブリッジを作成します。サーバ用途として構築した場合は、 <systemitem>wicked</systemitem> が既定で使用されます。</para>
    </listitem>
    <listitem>
     <para>ネットワーク接続を &nm; で管理している場合は、コマンドラインツール <command>nmcli</command> でネットワークブリッジを作成します。デスクトップ環境やラップトップ環境の場合は、 &nm; が既定で使用されます。</para>
    </listitem>
   </itemizedlist>
   <sect3 xml:id="libvirt-networks-bridged-yast">
    <title>&yast; を利用したネットワークブリッジの管理</title>
    <para>本章では、 &yast; を利用してネットワークブリッジを追加または削除する方法を説明しています。</para>
    <sect4 xml:id="libvirt-networks-bridged-yast-add">
     <title>ネットワークブリッジの追加</title>
     <para>&vmhost; にネットワークブリッジを追加するには、下記の手順を行います:</para>
     <procedure>
      <step>
       <para><menuchoice><guimenu>&yast;</guimenu><guimenu>システム</guimenu><guimenu>ネットワークの設定</guimenu></menuchoice> を起動します。</para>
      </step>
      <step>
       <para><guimenu>概要</guimenu> タブに移動して <guimenu>追加</guimenu> を押します。</para>
      </step>
      <step>
       <para><guimenu>デバイスの種類</guimenu> では <guimenu>ブリッジ</guimenu> を選択し、 <guimenu>設定名</guimenu> の項目にはブリッジデバイスのインターフェイス名を入力します。あとは <guimenu>次へ</guimenu> を押します。</para>
      </step>
      <step>
       <para><guimenu>アドレス</guimenu> のタブでは、 DHCP 経由でアドレスを取得するか、もしくは固定で IP アドレスを設定するかを選択し、必要であれば IP アドレスやサブネットマスク、ホスト名などをそれぞれ入力します。</para>
       <para><guimenu>可変 IP アドレス</guimenu> は、ブリッジが DHCP サーバに接続されているような場合のみ有用です。</para>
       <para>物理的なイーサネットデバイスへの接続を持たない仮想ブリッジを作成する場合は、 <guimenu>固定 IP アドレス</guimenu> を選択します。この場合、プライベート IP アドレスの範囲から選んで使用することをお勧めします。たとえば <literal>192.168.0.0/16</literal> , <literal>172.16.0.0/12</literal> , <literal>10.0.0.0/8</literal> などの中から選択します。</para>
       <para>ホストシステムとは接続しないゲスト間のみのネットワーク接続を作成する場合は、 IP アドレスを <literal>0.0.0.0</literal> 、サブネットマスクを <literal>255.255.255.255</literal> に設定します。これにより、 IP アドレスを設定しない特殊なネットワークを構成することができます。</para>
      </step>
      <step>
       <para><guimenu>ブリッジ接続デバイス</guimenu> のタブでは、ネットワークブリッジに含めたいネットワークデバイスを選択します。</para>
      </step>
      <step>
       <para><guimenu>次へ</guimenu> を押すと <guimenu>概要</guimenu> タブに戻りますので、設定内容を確認して <guimenu>OK</guimenu> を押します。これで &vmhost; 内にネットワークブリッジが作成され、有効化されます。</para>
      </step>
     </procedure>
    </sect4>
    <sect4 xml:id="libvirt-networks-bridged-yast-rm">
     <title>ネットワークブリッジの削除</title>
     <para>既存のネットワークブリッジを削除するには、下記の手順を行います:</para>
     <procedure>
      <step>
       <para><menuchoice><guimenu>&yast;</guimenu><guimenu>システム</guimenu><guimenu>ネットワークの設定</guimenu></menuchoice> を起動します。</para>
      </step>
      <step>
       <para><guimenu>概要</guimenu> タブで削除したいブリッジデバイスを選択します。</para>
      </step>
      <step>
       <para><guimenu>Delete</guimenu> を押してブリッジを削除し、 <guimenu>OK</guimenu> を押します。</para>
      </step>
     </procedure>
    </sect4>
   </sect3>
   <sect3 xml:id="libvirt-networks-bridged-add-brctl">
    <title>コマンドラインを利用したネットワークブリッジの管理</title>
    <para>本章では、コマンドラインを利用してネットワークブリッジを追加もしくは削除する方法を説明しています。</para>
    <sect4 xml:id="libvirt-networks-bridged-add-brctl-add">
     <title>ネットワークブリッジの追加</title>
     <para>&vmhost; 内にネットワークブリッジを追加するには、下記の手順を行います:</para>
     <procedure>
      <step>
       <para>ネットワークブリッジを作成したい &vmhost; にログインし、 &rootuser; になります。</para>
      </step>
      <step>
       <para>まずは新しいブリッジの名前を選択します。下記の例では、 <replaceable>virbr_test</replaceable> という名前で作成するものとします。</para>
<screen>&prompt.root;ip link add name <replaceable>virbr_test</replaceable> type bridge</screen>
      </step>
      <step>
       <para>&vmhost; でブリッジが作成されたことを確認します:</para>
<screen>&prompt.root;bridge vlan
[...]
virbr_test  1 PVID Egress Untagged
</screen>
       <para><literal>virbr_test</literal> という名前が現れていますが、この時点ではどの物理ネットワークインターフェイスにも結びつけられていません。</para>
      </step>
      <step>
       <para>ネットワークブリッジを起動して、ブリッジにネットワークインターフェイスを追加します:</para>
<screen>
&prompt.root;ip link set virbr_test up
&prompt.root;ip link set eth1 master virbr_test
</screen>
       <important>
        <title>ネットワークインターフェイスを使用していてはならない件について</title>
        <para>ここで指定できるネットワークインターフェイスは、他のネットワークブリッジで使用されているものであってはなりません。</para>
       </important>
      </step>
      <step>
       <para>なお、必要であれば STP (<link xlink:href="https://ja.wikipedia.org/wiki/%E3%82%B9%E3%83%91%E3%83%8B%E3%83%B3%E3%82%B0%E3%83%84%E3%83%AA%E3%83%BC%E3%83%97%E3%83%AD%E3%83%88%E3%82%B3%E3%83%AB">スパニングツリープロトコル</link>) を有効化することもできます:</para>
<screen>&prompt.root;bridge link set dev virbr_test cost 4</screen>
      </step>
     </procedure>
    </sect4>
    <sect4 xml:id="libvirt-networks-bridged-add-brctl-del">
     <title>ネットワークブリッジの削除</title>
     <para>コマンドラインを利用して &vmhost; のネットワークブリッジを削除するには、下記の手順を行います:</para>
     <procedure>
      <step>
       <para>ネットワークブリッジを削除したい &vmhost; にログインし、 &rootuser; になります。</para>
      </step>
      <step>
       <para>まずは既存のネットワークブリッジの一覧を表示させて、名前を確認します:</para>
<screen>&prompt.root;bridge vlan
[...]
virbr_test  1 PVID Egress Untagged
</screen>
      </step>
      <step>
       <para>ブリッジを削除します:</para>
<screen>&prompt.root;ip link delete dev virbr_test</screen>
      </step>
     </procedure>
    </sect4>
   </sect3>
   <sect3 xml:id="libvirt-networks-bridged-add-nm">
    <title><command>nmcli</command> を利用したネットワークブリッジの作成</title>
    <para>本章では、 &nm; が提供するコマンドラインツール <command>nmcli</command> を利用して、ネットワークブリッジを追加する方法を説明しています。</para>
    <procedure>
     <step>
      <para>まずは既存のネットワーク接続を確認します:</para>
<screen>
&prompt.sudo;nmcli connection show --active
NAME                   UUID                                  TYPE      DEVICE
Ethernet connection 1  84ba4c22-0cfe-46b6-87bb-909be6cb1214  ethernet  eth0
</screen>
     </step>
     <step>
      <para><literal>br0</literal> という名前の新しいブリッジデバイスを作成し、確認します:</para>
<screen>
&prompt.sudo;nmcli connection add type bridge ifname br0
Connection 'bridge-br0' (36e11b95-8d5d-4a8f-9ca3-ff4180eb89f7) \
successfully added.
&prompt.sudo;nmcli connection show --active
NAME                   UUID                                  TYPE      DEVICE
bridge-br0             36e11b95-8d5d-4a8f-9ca3-ff4180eb89f7  bridge    br0
Ethernet connection 1  84ba4c22-0cfe-46b6-87bb-909be6cb1214  ethernet  eth0
</screen>
     </step>
     <step>
      <para>必要であれば、ブリッジの設定を表示させてもよいでしょう:</para>
<screen>
&prompt.sudo;nmcli -f bridge connection show bridge-br0
bridge.mac-address:                     --
bridge.stp:                             yes
bridge.priority:                        32768
bridge.forward-delay:                   15
bridge.hello-time:                      2
bridge.max-age:                         20
bridge.ageing-time:                     300
bridge.group-forward-mask:              0
bridge.multicast-snooping:              yes
bridge.vlan-filtering:                  no
bridge.vlan-default-pvid:               1
bridge.vlans:                           --
</screen>
     </step>
     <step>
      <para>物理イーサネットデバイス <literal>eth0</literal> をブリッジデバイスに繋げます:</para>
<screen>&prompt.sudo;nmcli connection add type bridge-slave ifname eth0 master br0</screen>
     </step>
     <step>
      <para>あとは <literal>eth0</literal> インターフェイスを無効化し、新しいブリッジを有効化します:</para>
<screen>
&prompt.sudo;nmcli connection down "Ethernet connection 1"
&prompt.sudo;nmcli connection up bridge-br0
Connection successfully activated (master waiting for slaves) \
(D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/9)
</screen>
     </step>
    </procedure>
   </sect3>
   <sect3 xml:id="sec-xen-net-vlan">
    <title>VLAN インターフェイスの使用</title>
    <para>状況によっては、 2 台の &vmhost; 間や &vmguest; 間で、プライベートな接続が必要となる場合があります。たとえば &vmguest; を異なるネットワークセグメント内にあるホストに移行させる必要がある場合や、特定の &vmguest; のみが接続できるプライベートブリッジが必要となる場合 (異なる &vmhost; 内にあってもかまいません) などがそれにあたります。このような状況下では、 VLAN ネットワークを作成するのが最も簡単です。</para>
    <para>VLAN インターフェイスは一般に &vmhost; 内で設定を行います。この VLAN インターフェイスは異なる &vmhost; システム間の相互接続として使用できるほか、 &vmguest; のみが接続されたブリッジへの物理インターフェイスとしても設定することができます。このほか、 &vmhost; では IP アドレスを設定せずに VLAN を物理インターフェイスに接続することもできてしまいます。これにより、 &vmguest; から &vmhost; に接続できないように設定できることになります。</para>
    <para>まずは &yast; を起動して <menuchoice><guimenu>システム</guimenu><guimenu>ネットワークの設定</guimenu></menuchoice> を選択します。あとは下記の手順で VLAN インターフェイスを設定します:</para>
    <procedure>
     <title>&yast; を利用した VLAN インターフェイスの設定</title>
     <step>
      <para><guimenu>追加</guimenu> を押して新しいネットワークインターフェイスを作成します。</para>
     </step>
     <step>
      <para><guimenu>インターフェイスの追加設定</guimenu><!-- NOTE: is this exist?, changed anyway --> 内の <guimenu>デバイスの種類</guimenu> では、 <guimenu>VLAN</guimenu> を選択します。</para>
     </step>
     <step>
      <para><guimenu>VLAN ID</guimenu><!-- NOTE: is this wrong?, changed anyway --> では VLAN の ID を指定します。なお、 VLAN ID <literal>1</literal> は通常、管理用に使用します。</para>
     </step>
     <step>
      <para><guimenu>次へ</guimenu> を押します。</para>
     </step>
     <step>
      <para><guimenu>VLAN の実インターフェイス</guimenu> では、 VLAN デバイスの接続先となるインターフェイスを選択します。一覧に必要なインターフェイスが表示されていない場合は、いったんキャンセルしてから、表示させたいインターフェイスを設定してください (このとき、 IP アドレスは指定しなくてかまいません) 。</para>
     </step>
     <step>
      <para>さらに VLAN デバイスへの IP アドレス設定方法を選択します。</para>
     </step>
     <step>
      <para><guimenu>次へ</guimenu> を押して設定を完了してください。</para>
     </step>
    </procedure>
    <para>VLAN インターフェイスをブリッジの物理インターフェイスとして使用することもできます。これにより、特定の &vmhost; と &vmguest; のみを接続することができるようになりますので、そのネットワークを介して &vmguest; を移行できるようになります。</para>
    <para>場合によっては、 &yast; で IP アドレスの設定を無くすことができない場合があります。たとえば &vmguest; <!-- NOTE: is this wrong? changed anyway -->のみを接続するようなネットワークがそれにあたります。このような場合は、 IP アドレスに <literal>0.0.0.0</literal> を、サブネットマスクに <literal>255.255.255.255</literal> をそれぞれ指定してください。これにより IP アドレス無しでの設定ができるようになります。</para>
   </sect3>
  </sect2>

  <sect2 xml:id="libvirt-networks-virtual">
   <title>仮想ネットワーク</title>
   <para>&libvirt; が管理する仮想ネットワークはブリッジ型のネットワークと似ていますが、一般的には &vmhost; とのレイヤ 2 接続は行いません。 &vmhost; の物理ネットワークへの接続は、レイヤ 3 転送を利用して実現します。これは &vmhost; 側でパケット転送の機能を提供するもので、レイヤ 2 ブリッジ型ネットワークとは異なる方式になります。この種類の仮想ネットワークでは &vmguest; に対して DHCP や DNS のサービスを提供することもできます。 &libvirt; の仮想ネットワーク機能に関する詳細は、 <link xlink:href="https://libvirt.org/formatnetwork.html"/> にある <citetitle>Network XML format</citetitle> の章をお読みください。</para>
   <para>&productname; で標準的な方法で &libvirt; のインストールを行うと、 <literal>default</literal> という名前の仮想ネットワークが作成され、 DHCP と DNS の機能がそれぞれ提供されるようになります。また、この仮想ネットワークにはアドレス変換 (NAT) 機能が提供され、 &vmhost; の物理ネットワークに接続できるようになります。これはあらかじめ設定済みの形で提供されますが、管理者側で有効化する必要があります。 &libvirt; でサポートされている転送モードの詳細について、詳しくは <link xlink:href="https://libvirt.org/formatnetwork.html#elementsConnect"/> にある <citetitle>Network XML format</citetitle> ドキュメンテーションをお読みください。</para>
   <para>&libvirt; が管理する仮想ネットワークは幅広い用途に対応していて、必要な機能のほとんどに対応していますが、ラップトップなどの無線接続や動的な (間欠的な) 接続の場合には不十分です。また仮想ネットワークは、仮想ネットワークと &vmhost; のネットワークとの間でパケット転送を行うことから、 &vmhost; の接続しているネットワーク内で IP アドレス数が不足しているような環境に有用でもあります。しかしながら、サーバ用途の場合は、 &vmguest; を &vmhost; の LAN に接続するネットワークブリッジ型の構成のほうが便利ではあります。</para>
   <warning>
    <title>転送モードの有効化について</title>
    <para>&libvirt; の仮想ネットワークに対して転送モードを有効化するには、まず <filename>/proc/sys/net/ipv4/ip_forward</filename> と <filename>/proc/sys/net/ipv6/conf/all/forwarding</filename> をそれぞれ 1 に設定する必要があります。これにより、 &vmhost; をルータとして動作させることができるようになります。なお、 &vmhost; のネットワークを再起動してしまうと、これらの値はリセットされ転送機能が無効化されてしまいます。再起動後も転送モードを有効化したい場合は、 &vmhost; 内の <filename>/etc/sysctl.conf</filename> ファイルを編集して、下記の内容を追記してください:</para>
<screen>net.ipv4.ip_forward = 1</screen>
<screen>net.ipv6.conf.all.forwarding = 1</screen>
   </warning>
   <sect3 xml:id="libvirt-networks-virtual-vmm">
    <title>&vmm; を利用した仮想ネットワークの管理</title>
    <para>&vmm; を利用することで、仮想ネットワークの作成や設定、操作などを行うことができます。</para>
    <sect4 xml:id="libvirt-networks-virtual-vmm-define">
     <title>仮想ネットワークの作成</title>
     <procedure>
      <step>
       <para>まずは &vmm; を起動します。利用可能な接続が表示されますので、設定したい仮想ネットワークの名前を選択して <guimenu>詳細</guimenu> を押します。</para>
      </step>
      <step>
       <para><guimenu>接続の詳細</guimenu> ウインドウで <guimenu>仮想ネットワーク</guimenu> タブを選択します。ここには現在の接続で利用可能な全ての仮想ネットワークが表示されるほか、右側には選択した仮想ネットワークの詳細が表示されます。</para>
       <figure>
        <title>接続の詳細</title>
        <mediaobject>
         <imageobject role="fo">
          <imagedata fileref="libvirt_vmm_conndetails.png" width="45%" format="PNG"/>
         </imageobject>
         <imageobject role="html">
          <imagedata fileref="libvirt_vmm_conndetails.png" width="45%" format="PNG"/>
         </imageobject>
        </mediaobject>
       </figure>
      </step>
      <step>
       <para>新しい仮想ネットワークを追加するには、 <guimenu>追加</guimenu> を押します。</para>
      </step>
      <step>
       <para>まずは新しい仮想ネットワークの名前を指定します。</para>
       <figure>
        <title>仮想ネットワークの作成</title>
        <mediaobject>
         <imageobject role="fo">
          <imagedata fileref="libvirt_vmm_vnet_ipv4.png" width="45%" format="PNG"/>
         </imageobject>
         <imageobject role="html">
          <imagedata fileref="libvirt_vmm_vnet_ipv4.png" width="45%" format="PNG"/>
         </imageobject>
        </mediaobject>
       </figure>
      </step>
      <step>
       <para>次にネットワークモードを指定します。 <guimenu>NAT</guimenu> および <guimenu>ルーティング</guimenu> の場合は、ネットワーク通信の転送先デバイスを指定することができます。 <guimenu>NAT</guimenu> (Network Address Translation; ネットワークアドレス変換) は仮想的なネットワークアドレス領域を特定の IP アドレスに割り当てるための方式で、 1 つの IP アドレスを複数のゲストで共有することができるようになります。 <guimenu>ルーティング</guimenu> は仮想ネットワーク側からのパケットを、そのまま &vmhost; の物理ネットワークに転送する方式です。</para>
      </step>
      <step>
       <para>IPv4 ネットワークを使用する場合は <guimenu>Enable IPv4</guimenu> を選択して利用したい IPv4 ネットワークアドレスを入力します。 DHCP サーバが必要な場合は、 <guimenu>Enable DHCPv4</guimenu> を選択して、割り当てるべきアドレス範囲を指定します。</para>
      </step>
      <step>
       <para>IPv6 ネットワークを使用する場合は <guimenu>Enable IPv6</guimenu> を選択して利用したい IPv6 ネットワークアドレスを入力します。 DHCP サーバが必要な場合は、 <guimenu>Enable DHCPv6</guimenu> を選択して、割り当てるべきアドレス範囲を指定します。</para>
      </step>
      <step>
       <para>仮想ネットワークとは異なるドメイン名を設定したい場合は、 <guimenu>DNS domain name</guimenu> で <guimenu>Custom</guimenu> を選択し、ドメイン名を入力します。</para>
      </step>
      <step>
       <para><guimenu>完了</guimenu> を押すと新しい仮想ネットワークを作成することができます。 &vmhost; 側では新しい仮想ネットワークブリッジである <literal>virbr<replaceable>X</replaceable></literal> が作成され、これが新しい仮想ネットワークになります。これは <command>bridge link</command> コマンドで確認することができます。 &libvirt; では自動的に iptables のルールを追加して、新しく作成した <emphasis>virbr<replaceable>X</replaceable></emphasis> でのゲスト間の通信可否を設定します。</para>
      </step>
     </procedure>
    </sect4>
    <sect4 xml:id="libvirt-networks-virtual-vmm-start">
     <title>仮想ネットワークの起動</title>
     <para>停止済みの仮想ネットワークを起動するには、下記の手順で行います:</para>
     <procedure>
      <step>
       <para>まずは &vmm; を起動します。利用可能な接続が表示されますので、設定したい仮想ネットワークの名前を選択して <guimenu>詳細</guimenu> を押します。</para>
      </step>
      <step>
       <para><guimenu>接続の詳細</guimenu> ウインドウ内では <guimenu>仮想ネットワーク</guimenu> タブを選択します。ここには現在の接続で利用可能な、全ての仮想ネットワークが一覧表示されます。</para>
      </step>
      <step>
       <para>仮想ネットワークを起動するには、 <guimenu>開始</guimenu> を押します。</para>
      </step>
     </procedure>
    </sect4>
    <sect4 xml:id="libvirt-networks-virtual-vmm-stop">
     <title>仮想ネットワークの停止</title>
     <para>起動済みの仮想ネットワークを停止するには、下記の手順で行います:</para>
     <procedure>
      <step>
       <para>まずは &vmm; を起動します。利用可能な接続が表示されますので、設定したい仮想ネットワークの名前を選択して <guimenu>詳細</guimenu> を押します。</para>
      </step>
      <step>
       <para><guimenu>接続の詳細</guimenu> ウインドウ内では <guimenu>仮想ネットワーク</guimenu> タブを選択します。ここには現在の接続で利用可能な、全ての仮想ネットワークが一覧表示されます。</para>
      </step>
      <step>
       <para>停止させたい仮想ネットワークを選択して、 <guimenu>停止</guimenu> を押します。</para>
      </step>
     </procedure>
    </sect4>
    <sect4 xml:id="libvirt-networks-virtual-vmm-delete">
     <title>仮想ネットワークの削除</title>
     <para>&vmhost; から仮想ネットワークを削除するには、下記の手順で行います:</para>
     <procedure>
      <step>
       <para>まずは &vmm; を起動します。利用可能な接続が表示されますので、設定したい仮想ネットワークの名前を選択して <guimenu>詳細</guimenu> を押します。</para>
      </step>
      <step>
       <para><guimenu>接続の詳細</guimenu> ウインドウ内では <guimenu>仮想ネットワーク</guimenu> タブを選択します。ここには現在の接続で利用可能な、全ての仮想ネットワークが一覧表示されます。</para>
      </step>
      <step>
       <para>削除したい仮想ネットワークを選択して <guimenu>削除</guimenu> を押します。</para>
      </step>
     </procedure>
    </sect4>
    <sect4 xml:id="libvirt-networks-virtual-vmm-nsswitch">
<!-- fate#316628 -->
     <title>NAT ネットワークでの <command>nsswitch</command> を利用した IP アドレスの取得 (KVM)</title>
     <itemizedlist>
      <listitem>
       <para>&vmhost; 側に libvirt-nss をインストールします。これは libvirt 向けに NSS サポートを提供するものです:</para>
<screen>&prompt.sudo;zypper in libvirt-nss</screen>
      </listitem>
      <listitem>
       <para><filename>/etc/nsswitch.conf</filename> に <literal>libvirt</literal> を追記します:</para>
<screen>...
hosts:  files libvirt mdns_minimal [NOTFOUND=return] dns
...</screen>
      </listitem>
      <listitem>
       <para>NSCD を起動している場合は、再起動します:</para>
<screen>&prompt.sudo;systemctl restart nscd</screen>
      </listitem>
     </itemizedlist>
     <para>これでホスト側からゲストを名前で接続できるようになります。</para>
     <para>なお、 NSS モジュールの機能は完全ではありません。 <command>dnsmasq</command> が提供する <filename>/var/lib/libvirt/dnsmasq/*.status</filename> ファイルを読み込んで、 JSON レコード形式で記述されているホスト名と IP アドレスを検出します。ホスト名の変換は、 <command>dnsmasq</command> の動作している libvirt 管理下のブリッジ型ネットワークの &vmhost; でのみ動作します。</para>
    </sect4>
   </sect3>
   <sect3 xml:id="libvirt-networks-virtual-virsh">
    <title><command>virsh</command> を利用した仮想ネットワークの管理</title>
    <para>&libvirt; が提供する仮想ネットワークは、 <command>virsh</command> コマンドラインツールで管理することができます。 <command>virsh</command> で利用可能なネットワーク関連のコマンドを一覧表示するには、下記のように入力して実行します:</para>
<screen>&prompt.sudo;virsh help network
Networking (help keyword 'network'):
    net-autostart                  ネットワークの自動起動
    net-create                     XML ファイルによるネットワークの作成
    net-define                     define (but don't start) a network from an XML file
    net-destroy                    ネットワークの強制停止
    net-dumpxml                    XML 形式のネットワーク情報
    net-edit                       ネットワークの XML 設定の編集
    net-event                      Network Events
    net-info                       ネットワーク情報
    net-list                       ネットワークの一覧表示
    net-name                       ネットワーク UUID からネットワーク名への変換
    net-start                      停止状態の（定義済み）ネットワークの起動
    net-undefine                   undefine an inactive network
    net-update                     既存のネットワーク設定の一部分の更新
    net-uuid                       ネットワーク名からネットワーク UUID への変換
    net-port-list                  list network ports
    net-port-create                create a network port from an XML file
    net-port-dumpxml               network port information in XML
    net-port-delete                delete the specified network port</screen>
    <para><command>virsh</command> の特定のコマンドに対するヘルプを表示したい場合は、 <command>virsh help <replaceable>コマンド</replaceable></command> のように入力して実行してください。</para>
<screen>&prompt.sudo;virsh help net-create
  名前
    net-create - XML ファイルによるネットワークの作成

  形式
    net-create &lt;file&gt;

  詳細
    ネットワークを作成します。

  オプション
    [--file] &lt;string&gt;  ネットワーク の XML 記述を含むファイル</screen>
    <sect4 xml:id="libvirt-networks-virtual-virsh-create">
     <title>ネットワークの作成</title>
<!-- 2016-02-25 tbazant
     https://wiki.libvirt.org/page/VirtualNetworking#Creating_a_virtual_network
     https://libvirt.org/formatnetwork.html
     https://libvirt.org/sources/virshcmdref/html/sect-net-create.html
     https://libvirt.org/sources/virshcmdref/html/
     -->
     <para>新しい <emphasis>動作中</emphasis> の仮想ネットワークを作成するには、下記のように入力して実行します:</para>
<screen>&prompt.sudo;virsh net-create <replaceable>定義ファイル名.xml</replaceable></screen>
     <para>ここで、 <replaceable>定義ファイル名.xml</replaceable> には、 &libvirt; が受け入れ可能な XML 形式で記述された、仮想ネットワークの設定ファイルを指定します。</para>
     <para>有効化せずに新しい仮想ネットワークを追加したい場合は、下記のように入力して実行します:</para>
<screen>&prompt.sudo;virsh net-define <replaceable>定義ファイル名.xml</replaceable></screen>
     <para>下記には、様々な種類の仮想ネットワークの設定例を示しています。</para>
     <example xml:id="ex-libvirt-net-nat">
      <title>NAT ベースのネットワーク</title>
      <para>下記の設定は &vmguest; から外部に発信する通信を許可するネットワーク設定です。ただし、 &vmhost; 側で外部に接続することのできる環境が必要です。 &vmhost; 側にそのようなネットワークが用意されていない場合、相互に通信できるだけのネットワークになります。</para>
<screen>
&lt;network&gt;
&lt;name&gt;vnet_nated&lt;/name&gt;<co xml:id="vnet-xml-name"/>
&lt;bridge name="virbr1"/&gt;<co xml:id="vnet-xml-bridge"/>
 &lt;forward mode="nat"/&gt;<co xml:id="vnet-xml-forward"/>
 &lt;ip address="192.168.122.1" netmask="255.255.255.0"&gt;<co xml:id="vnet-xml-ip"/>
  &lt;dhcp&gt;
   &lt;range start="192.168.122.2" end="192.168.122.254"/&gt;<co xml:id="vnet-xml-dhcp"/>
   &lt;host mac="52:54:00:c7:92:da" name="host1.testing.com" \
    ip="192.168.1.23.101"/&gt;<co xml:id="vnet-xml-dhcp-host"/>
   &lt;host mac="52:54:00:c7:92:db" name="host2.testing.com" \
    ip="192.168.1.23.102"/&gt;
   &lt;host mac="52:54:00:c7:92:dc" name="host3.testing.com" \
    ip="192.168.1.23.103"/&gt;
  &lt;/dhcp&gt;
 &lt;/ip&gt;
&lt;/network&gt;
</screen>
      <calloutlist>
       <callout arearefs="vnet-xml-name">
        <para>新しい仮想ネットワークの名前です。</para>
       </callout>
       <callout arearefs="vnet-xml-bridge">
        <para>仮想ネットワークを構築する際のブリッジデバイス名を指定します。 &lt;forward&gt; (転送) モードが <literal>"nat"</literal> もしくは <literal>"route"</literal> のネットワークを作成する場合 (もしくは &lt;forward&gt; 要素を指定せず、孤立したネットワークを作成する場合) で、何も名前を指定しない場合、 &libvirt; が自動的にユニークな名前を生成して使用します。</para>
       </callout>
       <callout arearefs="vnet-xml-forward">
        <para>&lt;forward&gt; 要素を含めることで、仮想ネットワークを物理 LAN に接続することができるようになります。 <literal>mode</literal> (モード) 属性は転送方法を指定する属性で、最もよく使用されるものが "nat" (Network Address Translation (ネットワークアドレス変換); 既定値), "route" (アドレス変換を行わずに直接物理ネットワークに転送), "bridge" (&libvirt; の外部で設定されるブリッジに接続) のいずれかです。 &lt;forward&gt; 要素を何も指定しないと、その仮想ネットワークは他のネットワークから隔離 (孤立) されることになります。それ以外の転送モードについて、詳しくは <link xlink:href="https://libvirt.org/formatnetwork.html#elementsConnect"/> をお読みください。</para>
       </callout>
       <callout arearefs="vnet-xml-ip">
        <para>ネットワークブリッジに設定する IP アドレスとネットマスクです。</para>
       </callout>
       <callout arearefs="vnet-xml-dhcp">
        <para>仮想ネットワークに対して DHCP サーバ機能を有効化し、 <literal>start</literal> 属性と <literal>end</literal> 属性で指定した範囲の IP アドレスを提供します。</para>
       </callout>
       <callout arearefs="vnet-xml-dhcp-host">
        <para>指定は任意ですが、 &lt;host&gt; 要素を設定することで、内蔵の DHCP サーバに対して割り当てるべき IP アドレスを設定することもできます。この &lt;host&gt; 要素では、 IPv4 の場合は割当先のホストの MAC アドレスと DHCP サーバが割り当てるべき IP アドレス、そしてホスト名をそれぞれ設定します。 IPv6 の場合は IPv4 と少し異なり、 IPv6 では使用しない <literal>mac</literal> 属性が存在しない代わりに、 <literal>name</literal> 属性でホストを識別します。 DHCPv6 の場合、 <literal>name</literal> 属性は対象の純粋なホスト名である必要があります。なお、 IPv4 でも <literal>mac</literal> の代わりにホスト名を使用することができます。</para>
       </callout>
      </calloutlist>
     </example>
     <example>
      <title>ルーティング型のネットワーク</title>
      <para>下記の設定は、仮想ネットワーク内のトラフィックを LAN にそのまま (NAT を適用せずに) 転送する場合の例を示しています。 IP アドレスの範囲は、 &vmhost; 側のネットワークルータであらかじめ設定されていなければなりません。</para>
<screen>
&lt;network&gt;
 &lt;name&gt;vnet_routed&lt;/name&gt;
 &lt;bridge name="virbr1"/&gt;
 &lt;forward mode="route" dev="eth1"/&gt;<co xml:id="vnet-xml-route"/>
 &lt;ip address="192.168.122.1" netmask="255.255.255.0"&gt;
  &lt;dhcp&gt;
   &lt;range start="192.168.122.2" end="192.168.122.254"/&gt;
  &lt;/dhcp&gt;
 &lt;/ip&gt;
&lt;/network&gt;
</screen>
      <calloutlist>
       <callout arearefs="vnet-xml-route">
        <para>この例では、ゲスト側のトラフィックは &vmhost; 内の <systemitem>eth1</systemitem> デバイスを介して送信されます。</para>
       </callout>
      </calloutlist>
     </example>
     <example>
      <title>孤立したネットワーク</title>
      <para>この設定は、プライベートネットワークとして完全に孤立させる設定例となります。ゲスト同士や &vmhost; との間では通信ができるものの、 LAN 内のマシンからはは全く接続できなくなります。これは XML の設定内に &lt;forward&gt; 要素が存在していないためです。</para>
<screen>&lt;network&gt;
 &lt;name&gt;vnet_isolated&lt;/name&gt;
 &lt;bridge name="virbr3"/&gt;
 &lt;ip address="192.168.152.1" netmask="255.255.255.0"&gt;
  &lt;dhcp&gt;
   &lt;range start="192.168.152.2" end="192.168.152.254"/&gt;
  &lt;/dhcp&gt;
 &lt;/ip&gt;
 &lt;/network&gt;
</screen>
     </example>
     <example>
      <title>&vmhost; にある既存のブリッジの使用</title>
      <para>この設定は、 &vmhost; 内にある既存のネットワークブリッジ <literal>br0</literal> を使用する場合の例です。 &vmguest; は物理ネットワークに直接接続される形になります。 &vmguest; の IP アドレスは物理ネットワークと同じサブネットでなければなりませんが、その代わり、接続に関する制限は送受信ともになくなります。</para>
<screen>&lt;network&gt;
        &lt;name&gt;host-bridge&lt;/name&gt;
        &lt;forward mode="bridge"/&gt;
        &lt;bridge name="br0"/&gt;
&lt;/network&gt;
</screen>
     </example>
    </sect4>
    <sect4 xml:id="libvirt-networks-virtual-virsh-list">
     <title>ネットワークの一覧表示</title>
     <para>&libvirt; で利用可能な仮想ネットワークの一覧を表示するには、下記のように入力して実行します:</para>
<screen>&prompt.sudo;virsh net-list --all

 名前                 状態       自動起動      永続
----------------------------------------------------------
 crowbar              動作中     はい (yes)    はい (yes)
 vnet_nated           動作中     はい (yes)    はい (yes)
 vnet_routed          動作中     はい (yes)    はい (yes)
 vnet_isolated        停止状態   はい (yes)    はい (yes)</screen>
<!-- fate#316628: Tool to obtain IP address allocated (DHCP)
      for bridged network in KVM -->
     <para>利用可能なドメインの一覧を表示するには、下記のように入力して実行します:</para>
<screen>&prompt.sudo;virsh list
 Id    名前                           状態
----------------------------------------------------
 1     nated_sles12sp3                動作中
 ...</screen>
     <para>動作中のドメインのインターフェイス一覧を表示したい場合は、 <option>domifaddr <replaceable>ドメイン</replaceable></option> のように入力して実行します。このとき、インターフェイス名を直接指定して実行することもできます。既定では IP アドレスと MAC アドレスがそれぞれ出力されます:</para>
<screen>&prompt.sudo;virsh domifaddr nated_sles12sp3 --interface vnet0 --source lease
 名前       MAC アドレス          Protocol     Address
-------------------------------------------------------------------------------
 vnet0      52:54:00:9e:0d:2b    ipv6         fd00:dead:beef:55::140/64
 -          -                    ipv4         192.168.100.168/24</screen>
     <para>指定したドメインに関連づけられた全ての仮想インターフェイスの概要情報を表示するには、下記のように入力して実行します:</para>
<screen>&prompt.sudo;virsh domiflist nated_sles12sp3
Interface  Type       Source       Model       MAC
---------------------------------------------------------
vnet0      network    vnet_nated   virtio      52:54:00:9e:0d:2b</screen>
    </sect4>
    <sect4 xml:id="libvirt-networks-virtual-virsh-info">
     <title>ネットワークの関する詳細の取得</title>
     <para>ネットワークに関する詳細情報を取得するには、下記のように入力して実行します:</para>
<screen>&prompt.sudo;virsh net-info vnet_routed
名前:           vnet_routed
UUID:           756b48ff-d0c6-4c0a-804c-86c4c832a498
起動中:         はい (yes)
永続:           はい (yes)
自動起動:       はい (yes)
ブリッジ:         virbr5</screen>
    </sect4>
    <sect4 xml:id="libvirt-networks-virtual-virsh-start">
     <title>ネットワークの起動</title>
     <para>設定済みではあるものの、現在起動していないネットワークを起動したい場合は、まず対象の名前 (もしくは識別子や UUID) を判断します。具体的には、下記のように入力して実行します:</para>
<screen>&prompt.sudo;virsh net-list --inactive
 名前                 状態        自動起動      永続
----------------------------------------------------------
 vnet_isolated        停止状態    はい (yes)    はい (yes)</screen>
     <para>あとは下記のように入力して実行します:</para>
<screen>&prompt.sudo;virsh net-start vnet_isolated
ネットワーク vnet_isolated を起動しました</screen>
    </sect4>
    <sect4 xml:id="libvirt-networks-virtual-virsh-stop">
     <title>ネットワークの停止</title>
     <para>動作中のネットワークを停止するには、まず対象の名前 (もしくは識別子や UUID) を判断します。具体的には、下記のように入力して実行します:</para>
<screen>&prompt.sudo;virsh net-list --inactive
 名前                 状態        自動起動      永続
----------------------------------------------------------
 vnet_isolated        動作中      はい (yes)    はい (yes)</screen>
     <para>あとは下記のように入力して実行します:</para>
<screen>&prompt.sudo;virsh net-destroy vnet_isolated
ネットワーク vnet_isolated は強制停止されました</screen>
    </sect4>
    <sect4 xml:id="libvirt-networks-virtual-virsh-undefine">
     <title>ネットワークの削除</title>
     <para>停止したネットワークの設定を &vmhost; から完全に停止したい場合は、下記のように入力して実行します:</para>
<screen>&prompt.sudo;virsh net-undefine vnet_isolated
ネットワーク vnet_isolated の定義が削除されました</screen>
    </sect4>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="libvirt-host-storage">
  <title>ストレージプールの設定</title>

  <para>&vmhost; 自身から &vmguest; を管理する場合であれば、 &vmhost; のファイルシステムの任意の箇所にアクセスして仮想ハードディスクを割り当てたり作成したりすることができますし、既存のイメージを &vmguest; に割り当てたりすることができます。しかしながら、このような機能は &vmguest; をリモートから管理しようとしている場合には実現できません。このような理由から、 &libvirt; では <quote>ストレージプール</quote> と呼ばれる機能を提供して、リモートからアクセスできるようにしています。</para>

  <tip>
   <title>CD/DVD ISO イメージ</title>
   <para>リモートのクライアントから &vmhost; 内の CD/DVD イメージにアクセスできるようにするには、まずそれらのイメージをストレージプール内に配置します。</para>
  </tip>

  <para>&libvirt; では 2 種類のストレージを管理しています。それらはボリュームとプールと呼ばれます。</para>

  <variablelist>
   <varlistentry>
    <term>ストレージボリューム</term>
    <listitem>
     <para>ストレージボリュームは、ゲストに対して割り当てることのできるストレージデバイスを意味します。たとえば仮想ディスクや CD/DVD イメージのほか、フロッピィディスクイメージなども該当します。また、ストレージボリュームを物理デバイス (パーティションや論理ボリュームなど) に設定することもできますし、 &vmhost; 内のファイルとして存在させることもできます。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>ストレージプール</term>
    <listitem>
     <para>ストレージプールは &vmhost; 内のストレージリソースを意味するもので、その中にストレージボリュームが存在する形になります。デスクトップマシンにおけるネットワークストレージのような存在です。物理的には下記のいずれかの形態を取ることができます:</para>
     <variablelist>
      <varlistentry>
       <term>ファイルシステム内のディレクトリ ( <guimenu>dir</guimenu> )</term>
       <listitem>
        <para>イメージファイルを含むディレクトリの形態です。イメージファイルにはディスク形式 (raw, qcow2) のほか、 ISO イメージであってもかまいません。</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>物理ディスクデバイス ( <guimenu>disk</guimenu> )</term>
       <listitem>
        <para>物理ディスク全体をストレージプールとして使用する形態です。その中にパーティションを作成してストレージボリュームを設定し、プールへの追加を行います。</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>フォーマット済みブロックデバイス ( <guimenu>fs</guimenu> )</term>
       <listitem>
        <para>ファイルシステムのディレクトリをストレージプールとして使用する場合と同様に、特定のパーティションをストレージプールとして使用する形態です。ただし、この方式の場合は、 &libvirt; 側でデバイスのマウント処理を行います。</para>
       </listitem>
      </varlistentry>
<!-- <varlistentry>
      <term>GlusterFS device (<guimenu>gluster</guimenu>)</term>
      <listitem>
       <para>
        ...
       </para>
      </listitem>
     </varlistentry> -->
      <varlistentry>
       <term>iSCSI ターゲット (iscsi)</term>
       <listitem>
        <para>iSCSI ターゲット内にストレージプールを作成する形態です。この場合は、 &libvirt; で使用するより前に、あらかじめボリュームにログインしておく必要があります。 &yast; の <guimenu>iSCSI イニシエータ</guimenu> モジュールを利用してターゲットを検出し、ログインしておいてください。 <phrase os="sles"> 詳しくは <xref linkend="book-storage"/> をお読みください。 </phrase> iSCSI ストレージプール内でのボリューム作成はサポートされていませんが、既存の論理ユニット番号 (LUN) そのものがボリュームそのものになります。それぞれのボリューム (LUN) を使用するには、あらかじめパーティションテーブルを作成しておくか、ディスクラベルを設定しておく必要があります。いずれも存在していない場合は、 <command>fdisk</command> で設定してください:</para>
<screen>&prompt.sudo;fdisk -cu /dev/disk/by-path/ip-&wsIip;:3260-iscsi-iqn.2010-10.com.example:[...]-lun-2
デバイスには認識可能なパーティション情報が含まれていません。
新しい DOS ディスクラベルを作成しました。識別子は 0xdeadbeef です。

コマンド (m でヘルプ): w
パーティション情報が変更されました。
ディスクを同期しています。</screen>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>LVM ボリュームグループ (logical)</term>
       <listitem>
        <para>LVM のボリュームグループをプールとして使用する形態です。設定済みのボリュームグループの中から選択するか、もしくは使用したいデバイスを指定してグループを作成することができます。ストレージボリュームは、その中のパーティションとして作成されます。</para>
        <warning>
         <title>LVM ベースのプールの削除</title>
         <para>LVM ベースのプールをストレージマネージャで削除した場合、ボリュームグループについても削除が行われます。そのため、プール内にあるデータは完全に削除され、復元できなくなることに注意してください！</para>
        </warning>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>マルチパスデバイス ( <guimenu>mpath</guimenu> )</term>
       <listitem>
        <para>現時点では、マルチパスデバイスへのサポートは限定的で、ゲストに対して既存のデバイスを割り当てることだけができます。 &libvirt; 内からマルチパスデバイスのボリュームを作成する機能は提供されていません。</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>ネットワーク公開ディレクトリ ( <guimenu>netfs</guimenu> )</term>
       <listitem>
        <para>ファイルシステムのディレクトリプール (イメージファイルをディレクトリ内に配置する) と同様に、ネットワークディレクトリを指定して、そのディレクトリ内に配置する方法です。ただし、こちらの場合は &libvirt; 側でマウント処理を行います。 NFS と GlusterFS の両方に対応しています。</para>
       </listitem>
      </varlistentry>
<!-- <varlistentry>
      <term>Rados block device (<guimenu>rbd</guimenu>)</term>
      <listitem>
       <para>
        ...
       </para>
      </listitem>
     </varlistentry> -->
<!-- <varlistentry>
      <term>Sheepdog distributed storage system (<guimenu>sheepdog</guimenu>)</term>
      <listitem>
       <para>
        ...
       </para>
      </listitem>
     </varlistentry> -->
      <varlistentry>
       <term>SCSI ホストアダプタ ( <guimenu>scsi</guimenu> )</term>
       <listitem>
        <para>iSCSI ターゲットと同様に SCSI ホストアダプタを使用する方法です。この場合、デバイス名に <filename>/dev/sd<replaceable>X</replaceable></filename> ではなく、 <filename>/dev/disk/by-*</filename> を使用することをお勧めします。これは、 <filename>/dev/sd<replaceable>X</replaceable></filename> を使用してしまうと、ハードディスクの取り付けや取り外しなどで名前が変化してしまうことがあり得るためです。 iSCSI プール内のボリューム作成には対応していませんが、既存の LUN (論理ユニット番号;  Logical Unit Number) がそのままボリュームを表します。</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>
  </variablelist>

  <warning>
   <title>セキュリティ面の考慮事項について</title>
   <para>データの損失や破壊を防ぐため、 LVM ボリュームグループや iSCSI ターゲットなど、 &vmhost; のストレージプールを構成するリソースを別目的で使用してはなりません。これらに対する必要な処理は &libvirt; が行いますので、 &vmhost; から直接接続する必要はありませんし、 &vmhost; からマウントする必要もありません。</para>
   <para>また &vmhost; では、ラベルによるマウントも行わないようにしてください。ラベルによるマウントを行ってしまうと、本来は &vmguest; 側で使用すべきパーティションを &vmhost; 側が検知して、マウントしてしまう危険性があるためです。</para>
  </warning>

  <sect2 xml:id="sec-libvirt-storage-virsh">
   <title><command>virsh</command> を利用したストレージの管理</title>
   <para>コマンドラインからのストレージの管理についても、 <command>virsh</command> から行うことができます。ただし、ストレージプールの作成は現時点では &suse; のサポート対象外となっております。そのため、本章ではプールの起動／停止／削除のほか、ボリュームの管理に絞って説明しています。</para>
   <para><command>virsh</command> で利用可能なプール／ボリューム管理関連のサブコマンド一覧を表示するには、 <command>virsh help pool</command> および <command>virsh help volume</command> を実行します。</para>
   <sect3 xml:id="sec-libvirt-storage-virsh-list-pools">
    <title>ブールとボリュームの一覧表示</title>
    <para>現時点で有効化されているプールの一覧を表示するには、下記のコマンドを入力して実行します。無効化されているプールも表示したい場合は、 <option>--all</option> オプションを追加してください:</para>
<screen>&prompt.user;virsh pool-list --details</screen>
    <para>特定のプールに関する詳細を表示したい場合は、 <literal>pool-info</literal> サブコマンドを使用します:</para>
<screen>&prompt.user;virsh pool-info <replaceable>プール名</replaceable></screen>
    <para>既定では、ボリュームはプールごとに表示されます。プール内の全てのボリュームを表示したい場合は、下記のように入力して実行します:</para>
<screen>&prompt.user;virsh vol-list --details <replaceable>プール名</replaceable></screen>
    <para>現時点では、 <command>virsh</command> はゲスト側で使用されているかどうかを表示する機能は提供されていません。下記の手順を行うことで、 &vmguest; 側で使用されている全てのプール内のボリュームを表示することができます。</para>
    <procedure xml:id="pro-libvirt-storage-virsh-list-vols">
     <title>&vmhost; で使用されている全てのストレージボリュームの一覧表示</title>
     <step>
      <para>まずは下記のような内容で XSLT スタイルシートのファイルを作成します。たとえば ~/libvirt/guest_storage_list.xsl というファイル名で保存します:</para>
<screen>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:output method="text"/&gt;
  &lt;xsl:template match="text()"/&gt;
  &lt;xsl:strip-space elements="*"/&gt;
  &lt;xsl:template match="disk"&gt;
    &lt;xsl:text&gt;  &lt;/xsl:text&gt;
    &lt;xsl:value-of select="(source/@file|source/@dev|source/@dir)[1]"/&gt;
    &lt;xsl:text&gt;&amp;#10;&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</screen>
     </step>
     <step>
      <para>あとは下記のようなコマンドをシェル内で実行します。なお、ゲスト側の XML 設定は全て既定の場所 ( <filename>/etc/libvirt/qemu</filename> ) に保存されているものとします。また、 <command>xsltproc</command> は <systemitem class="resource">libxslt</systemitem> パッケージ内に含まれています。</para>
<screen>SSHEET="$HOME/libvirt/guest_storage_list.xsl"
cd /etc/libvirt/qemu
for FILE in *.xml; do
  basename $FILE .xml
  xsltproc $SSHEET $FILE
done</screen>
     </step>
    </procedure>
   </sect3>
   <sect3 xml:id="sec-libvirt-storage-virsh-start-pools">
    <title>プールの起動／停止／削除</title>
    <para><command>virsh</command> pool サブコマンドを使用することで、プールの起動と停止、削除をそれぞれ行うことができます。下記では、 <replaceable>プール名</replaceable> の箇所をプールの名前もしくは UUID に置き換えて実行してください:</para>
    <variablelist>
     <varlistentry>
      <term>プールの停止</term>
      <listitem>
<screen>&prompt.user;virsh pool-destroy <replaceable>プール名</replaceable></screen>
       <note>
        <title>プールの状態は割り当てられているボリュームとは無関係である件について</title>
        <para>既に &vmguest; に割り当てられているプール内のボリュームについては、そのプールの状態 ( <guimenu>動作中</guimenu> もしくは <guimenu>停止</guimenu> ) に関わらず、常にアクセスできる状態になります。プールの状態は、リモートから &vmguest; のボリュームを管理する場合にのみ有効となります。</para>
       </note>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>プールの削除</term>
      <listitem>
<screen>&prompt.user;virsh pool-delete <replaceable>プール名</replaceable></screen>
       <warning>
        <title>ストレージプールの削除</title>
        <para><xref linkend="deleting-storage-pools"/> をお読みください</para>
       </warning>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>プールの起動</term>
      <listitem><screen>&prompt.user;virsh pool-start <replaceable>プール名</replaceable></screen></listitem>
     </varlistentry>
     <varlistentry>
      <term>プールの自動起動の有効化</term>
      <listitem>
<screen>&prompt.user;virsh pool-autostart <replaceable>プール名</replaceable></screen>
       <para>自動起動が有効化されたプールは、 &vmhost; の起動時に自動的に起動が行われるようになります。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>プールの自動起動の無効化</term>
      <listitem><screen>&prompt.user;virsh pool-autostart <replaceable>プール名</replaceable> --disable</screen></listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 xml:id="sec-libvirt-storage-virsh-add-volumes">
    <title>ストレージプールへのボリュームの追加</title>
    <para><command>virsh</command> ではストレージプールにボリュームを追加するにあたって、 2 種類の方法を提供しています。 <literal>vol-create</literal> および <literal>vol-create-from</literal> を利用して、 XML 設定ファイルから追加する方法と、 <literal>vol-create-as</literal> のコマンドラインにパラメータを設定して追加する方法です。前者は現時点で &suse; 側でサポート対象となっていませんので、本章では <literal>vol-create-as</literal> を説明します。</para>
    <para>既存のプールにボリュームを追加するには、下記のようなコマンドを入力して実行します:</para>
<screen>&prompt.user;virsh vol-create-as <replaceable>プール名</replaceable><co xml:id="co-vol-create-as-pool"/><replaceable>名前</replaceable><co xml:id="co-vol-create-as-name"/> 12G --format<co xml:id="co-vol-create-as-capacity"/><replaceable>raw|qcow2</replaceable><co xml:id="co-vol-create-as-format"/> --allocation 4G<co xml:id="co-vol-create-as-alloc"/></screen>
    <calloutlist>
     <callout arearefs="co-vol-create-as-pool">
      <para>ボリュームを追加したいプールの名前を指定します</para>
     </callout>
     <callout arearefs="co-vol-create-as-name">
      <para>ボリュームの名前を指定します</para>
     </callout>
     <callout arearefs="co-vol-create-as-capacity">
      <para>イメージのサイズを指定します。この例では 12 ギガバイトを指定していますが、 k (キロバイト), M (メガバイト), G (ギガバイト), T (テラバイト) の各接尾辞を指定することができます。</para>
     </callout>
     <callout arearefs="co-vol-create-as-format">
      <para>ボリュームの形式を指定します。 &suse; では <literal>raw</literal> と <literal>qcow2</literal> をサポート対象としています。</para>
     </callout>
     <callout arearefs="co-vol-create-as-alloc">
      <para>任意指定のパラメータです。既定では、 <command>virsh</command> はスパースファイルという形式でイメージファイルを作成し、必要に応じて自動的にサイズが拡張されるようになりますが、ここで指定したサイズ (この例では 4 ギガバイト) を事前に割り当てておくことができます。なお、 k (キロバイト), M (メガバイト), G (ギガバイト), T (テラバイト) の各接尾辞を指定することができます。</para>
      <para>このパラメータを指定しない場合、事前の割り当ての無いスパースファイルを作成することになります。あらかじめ全てのサイズを割り当てておきたい (非スパースファイルを作成したい) 場合は、イメージのサイズと同じ値 (この例では <literal>12G</literal>) を指定してください。</para>
     </callout>
    </calloutlist>
    <sect4 xml:id="sec-libvirt-storage-virsh-add-volumes-clone">
     <title>既存のボリュームの複製</title>
     <para>プールにボリュームを追加するもう 1 つの方法として、既存のボリュームの複製という手段があります。新しいボリュームは元のボリュームと同じプール内に作成されます。</para>
<screen>&prompt.user;virsh vol-clone <replaceable>既存のボリューム名</replaceable><co xml:id="co-vol-clone-existing"/><replaceable>新しいボリューム名</replaceable><co xml:id="co-vol-clone-new"/> --pool <replaceable>プール</replaceable><co xml:id="co-vol-clone-pool"/></screen>
     <calloutlist>
      <callout arearefs="co-vol-clone-existing">
       <para>複製元となる既存のボリューム名を指定します</para>
      </callout>
      <callout arearefs="co-vol-clone-new">
       <para>新しいボリューム名を指定します</para>
      </callout>
      <callout arearefs="co-vol-clone-pool">
       <para>任意指定のパラメータです。 &libvirt; では既存のボリュームの配置先を自動的に判断しますが、それがうまくいかない場合に、このパラメータを指定してください。</para>
      </callout>
     </calloutlist>
    </sect4>
   </sect3>
   <sect3 xml:id="sec-libvirt-storage-virsh-del-volumes">
    <title>ストレージプールからのボリュームの削除</title>
    <para>プールからボリュームを恒久的に削除したい場合は、 <literal>vol-delete</literal> サブコマンドを使用します:</para>
<screen>&prompt.user;virsh vol-delete <replaceable>ボリューム名</replaceable> --pool <replaceable>プール名</replaceable></screen>
    <para><option>--pool</option> は任意指定で、通常は &libvirt; がボリュームのプールを自動的に判断しますが、それがうまくいかない場合には、このパラメータを指定してください。</para>
    <warning>
     <title>ボリューム削除時のチェックにいて</title>
     <para>ボリュームは &vmguest; 側が使用しているかどうかにかかわらず、どのような状況下であっても削除ができてしまいます。また、削除したボリュームを復元する方法はありません。</para>
     <para>ボリュームが &vmguest; 側で使用されているかどうかを判断したい場合は、 <xref linkend="pro-libvirt-storage-virsh-list-vols"/> の手順を行ってください。</para>
    </warning>
   </sect3>
   <sect3 xml:id="libvirt-storage-virsh-attach-volumes">
    <title>&vmguest; へのボリュームの割り当て</title>
    <para><xref linkend="sec-libvirt-storage-virsh-add-volumes"/> で説明している手順でボリュームを作成したら、あとは仮想マシンへの割り当てを行ってハードディスクとして使用できるようにします:</para>
<screen>&prompt.user;virsh attach-disk <replaceable>ドメイン</replaceable> <replaceable>イメージファイル</replaceable> <replaceable>接続先ディスクデバイス</replaceable></screen>
    <para>たとえば下記のようになります:</para>
<screen>&prompt.user;virsh attach-disk sles12sp3 /virt/images/example_disk.qcow2 sda2</screen>
    <para>ディスクが接続できたかどうかを確認するには、 <command>virsh dumpxml</command> コマンドの出力を確認します:</para>
<screen>&prompt.root;virsh dumpxml sles12sp3
[...]
&lt;disk type='file' device='disk'&gt;
 &lt;driver name='qemu' type='raw'/&gt;
 &lt;source file='/virt/images/example_disk.qcow2'/&gt;
 &lt;backingStore/&gt;
 &lt;target dev='sda2' bus='scsi'/&gt;
 &lt;alias name='scsi0-0-0'/&gt;
 &lt;address type='drive' controller='0' bus='0' target='0' unit='0'/&gt;
&lt;/disk&gt;
[...]</screen>
    <sect4>
     <title>ホットプラグ (活性接続) ／恒久的な変更</title>
     <para>ディスクの接続は、対象のドメインが動作中であっても停止済みであっても実施することができます。また、 <option>--live</option> と <option>--config</option> のオプションを使用することで、それぞれ下記のような動作を行うことができます:</para>
     <variablelist>
      <varlistentry>
       <term><option>--live</option></term>
       <listitem>
        <para>動作中のドメインに対してディスクをホットプラグします。接続の情報はドメインの設定ファイル内には保存されません。また、ドメインが動作中ではない場合、 <option>--live</option> オプションを指定するとエラーになります。</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><option>--config</option></term>
       <listitem>
        <para>ドメインの設定ファイルを恒久的に変更します。接続されたディスクは次回のドメイン起動以降に利用できるようになります。</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><option>--live</option> <option>--config</option></term>
       <listitem>
        <para>ディスクをホットプラグで接続すると共に、ドメインの設定ファイルを恒久的に変更します。</para>
       </listitem>
      </varlistentry>
     </variablelist>
     <tip>
      <title><command>virsh attach-device</command></title>
      <para><command>virsh attach-device</command> コマンドは <command>virsh attach-disk</command> コマンドのより一般的な形式です。このコマンドは、ドメインに対して様々な種類のデバイスを接続することができます。</para>
     </tip>
    </sect4>
   </sect3>
   <sect3 xml:id="libvirt-storage-virsh-detach-volumes">
    <title>&vmguest; からのボリュームの接続解除</title>
    <para>ドメインに対してディスクへの接続を解除したい場合は、 <command>virsh detach-disk</command> コマンドを使用します:</para>
<screen>&prompt.root;virsh detach-disk <replaceable>ドメイン</replaceable> <replaceable>接続先のディスクデバイス</replaceable></screen>
    <para>たとえば下記のようになります:</para>
<screen>&prompt.root;virsh detach-disk sles12sp3 sda2</screen>
    <para><xref linkend="libvirt-storage-virsh-attach-volumes"/> で説明しているのと同様に、こちらでも <option>--live</option> オプションや <option>--config</option> オプションで接続方式を制御することができます。</para>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-libvirt-storage-vmm">
   <title>&vmm; を利用したストレージの管理</title>
   <para>&vmm; はグラフィカルインターフェイスを提供するソフトウエアで、この中のストレージマネージャの機能を使用することで、ボリュームやプールを管理することができます。ストレージマネージャにアクセスするには、接続を選択してマウスの右ボタンを押し、表示されたメニューから <guimenu>詳細</guimenu> を選択するか、接続を選択して <menuchoice> <guimenu>編集</guimenu> <guimenu>接続の詳細</guimenu> </menuchoice> を選択します。その後 <guimenu>ストレージ</guimenu> タブを選択してください。</para>
   <informalfigure>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="virt_virt-manager_storage.png" width="60%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="virt_virt-manager_storage.png" width="60%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </informalfigure>
   <sect3 xml:id="sec-libvirt-storage-vmm-addpool">
    <title>ストレージプールの追加</title>
    <para>ストレージプールを追加するには、下記の手順を行います:</para>
    <procedure>
     <step>
      <para>左下の <guimenu>追加</guimenu> ボタンを押します。 <guimenu>新しいストレージプールを作成</guimenu> というダイアログが表示されるはずです。</para>
     </step>
     <step>
      <para>まずはプールに対する <guimenu>名前</guimenu> を入力します (名前には英数字のほか、 <literal>_</literal> , <literal>-</literal> , <literal>.</literal> の各記号を使用することができます) 。あとは <guimenu>種類</guimenu> を選択します。</para>
      <informalfigure>
       <mediaobject>
        <imageobject role="fo">
         <imagedata fileref="virt_virt-manager_storage_add.png" width="60%" format="PNG"/>
        </imageobject>
        <imageobject role="html">
         <imagedata fileref="virt_virt-manager_storage_add.png" width="60%" format="PNG"/>
        </imageobject>
       </mediaobject>
      </informalfigure>
     </step>
     <step>
      <para>あとはプールの種類に従って詳細を指定します。それぞれ下記のようになります:</para>
      <important>
       <para>ZFS プールには対応していません。</para>
      </important>
      <variablelist>
       <varlistentry>
        <term><emphasis role="bold">種類</emphasis> = <guimenu>dir</guimenu> の場合:</term>
        <listitem>
         <itemizedlist mark="bullet" spacing="normal">
          <listitem>
           <para><guimenu>Target Path</guimenu> : 既存のディレクトリを選択します。</para>
          </listitem>
         </itemizedlist>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis role="bold">種類</emphasis> = <guimenu>disk</guimenu> の場合:</term>
        <listitem>
         <itemizedlist mark="bullet" spacing="normal">
          <listitem>
           <para><guimenu>フォーマット</guimenu> : デバイスのパーティションテーブルの形式を指定します。通常は <guimenu>auto</guimenu> のままでかまいませんが、正しく検出できない場合は、 &vmhost; 側で <command>parted</command> <option>-l</option> を実行して形式を判別し、指定してください。</para>
          </listitem>
          <listitem>
           <para><guimenu>ソースパス</guimenu> : デバイスのパスを指定します。 <filename>/dev/sd<replaceable>X</replaceable></filename> のようなパスではなく、 <filename>/dev/disk/by-*</filename> のパスで指定することをお勧めします。これは、 <filename>/dev/sd<replaceable>X</replaceable></filename> を使用してしまうと、ハードディスクの取り付けや取り外しなどで名前が変化してしまうことがあり得るためです。また、パーティションではなくディスク全体を表すパスを指定してください。</para>
          </listitem>
         </itemizedlist>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis role="bold">種類</emphasis> = <guimenu>fs</guimenu> の場合:</term>
        <listitem>
         <itemizedlist mark="bullet" spacing="normal">
          <listitem>
           <para><guimenu>Target Path</guimenu> : &vmhost; 内のファイルシステムでマウント先となるディレクトリを指定します。</para>
          </listitem>
          <listitem>
           <para><guimenu>フォーマット</guimenu> : デバイスのファイルシステム形式を指定します。既定値である <literal>auto</literal> で問題なく動作するはずです。</para>
          </listitem>
          <listitem>
           <para><guimenu>ソースパス</guimenu> : デバイスファイルのパスを指定します。 <filename>/dev/sd<replaceable>X</replaceable></filename> のようなパスではなく、 <filename>/dev/disk/by-*</filename> のパスで指定することをお勧めします。これは、 <filename>/dev/sd<replaceable>X</replaceable></filename> を使用してしまうと、ハードディスクの取り付けや取り外しなどで名前が変化してしまうことがあり得るためです。</para>
          </listitem>
         </itemizedlist>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis role="bold">種類</emphasis> = <guimenu>iscsi</guimenu> の場合:</term>
        <listitem>
         <para>&vmhost; 側で下記のコマンドを入力して実行し、必要なデータを収集してください:</para>
<screen>&prompt.sudo;iscsiadm --mode node</screen>
         <para>上記のように入力して実行すると、下記のような形式で iSCSI ボリュームの一覧が出力されます。下記のうち、太字の部分が必要な情報になります:</para>
<screen><emphasis role="bold">IP_アドレス</emphasis>:PORT,TPGT <emphasis role="bold">ターゲット名_(IQN)</emphasis></screen>
         <itemizedlist mark="bullet" spacing="normal">
          <listitem>
           <para><guimenu>Target Path</guimenu> : デバイスファイルを含むディレクトリを指定します。 <literal>/dev/disk/by-path</literal> (既定値) もしくは <literal>/dev/disk/by-id</literal> のいずれかを指定してください。</para>
          </listitem>
          <listitem>
           <para><guimenu>ホスト名</guimenu> : iSCSI サーバのホスト名または IP アドレスを指定します。</para>
          </listitem>
          <listitem>
           <para><guimenu>ソース IQN</guimenu> : iSCSI のターゲット名 (IQN) を指定します。</para>
          </listitem>
          <listitem>
           <para><guimenu>イニシエーターの IQN</guimenu> : iSCSI のイニシエータ名を指定します。</para>
          </listitem>
         </itemizedlist>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis role="bold">種類</emphasis> = <guimenu>logical</guimenu> の場合</term>
        <listitem>
         <itemizedlist mark="bullet" spacing="normal">
          <listitem>
           <para><guimenu>Volgroup Name</guimenu> : 既存のボリュームグループのデバイスパスを指定します。</para>
          </listitem>
         </itemizedlist>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis role="bold">種類</emphasis> = <guimenu>mpath</guimenu> の場合:</term>
        <listitem>
         <itemizedlist mark="bullet" spacing="normal">
          <listitem>
           <para><guimenu>Target Path</guimenu> : マルチパス機能への対応は現在、全てのマルチパスデバイスを利用可能にする場合のみとなっています。そのため、ここで指定した任意の文字列は無視されますが、何らかの値を入力しないと XML パーサーが失敗してしまいます。</para>
          </listitem>
         </itemizedlist>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis role="bold">種類</emphasis> = <guimenu>netfs</guimenu> の場合:</term>
        <listitem>
         <itemizedlist mark="bullet" spacing="normal">
          <listitem>
           <para><guimenu>Target Path</guimenu> : &vmhost; 内のファイルシステムでマウント先となるディレクトリを指定します。</para>
          </listitem>
          <listitem>
           <para><guimenu>ホスト名</guimenu> : ネットワークファイルシステムを提供するサーバの IP アドレスまたはホスト名を指定します。</para>
          </listitem>
          <listitem>
           <para><guimenu>ソースパス</guimenu> : 公開されているサーバ内のディレクトリを指定します。</para>
          </listitem>
         </itemizedlist>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis role="bold">種類</emphasis> = <guimenu>rbd</guimenu> の場合:</term>
        <listitem>
         <itemizedlist>
          <listitem>
           <para><guimenu>ホスト名</guimenu> : RADOS ブロックデバイスを提供するサーバの IP アドレスまたはホスト名を指定します。</para>
          </listitem>
          <listitem>
           <para><guimenu>Source Name</guimenu> : サーバ側での RADOS ブロックデバイスの名前を指定します。</para>
          </listitem>
         </itemizedlist>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><emphasis role="bold">種類</emphasis> = <guimenu>scsi</guimenu> の場合</term>
        <listitem>
         <itemizedlist mark="bullet" spacing="normal">
          <listitem>
           <para><guimenu>Target Path</guimenu> : デバイスファイルを含むディレクトリを指定します。 <literal>/dev/disk/by-path</literal> (既定値) もしくは <literal>/dev/disk/by-id</literal> のいずれかを指定してください。</para>
          </listitem>
          <listitem>
           <para><guimenu>ソースパス</guimenu> : SCSI アダプタの名前を指定します。</para>
          </listitem>
         </itemizedlist>
        </listitem>
       </varlistentry>
      </variablelist>
      <note>
       <title>ファイル参照について</title>
       <para><guimenu>参照</guimenu> ボタンによるファイル参照機能は、リモートから接続している場合には使用できません。</para>
      </note>
     </step>
     <step>
      <para><guimenu>完了</guimenu> を押すとストレージプールを追加することができます。</para>
     </step>
    </procedure>
   </sect3>
   <sect3 xml:id="sec-libvirt-storage-vmm-manage">
    <title>ストレージプールの管理</title>
    <para>&vmm; のストレージマネージャは、プール内にボリュームを作成したり削除したりすることができます。このほか、既存のストレージプールを一時的に無効化したり恒久的に削除したりすることもできます。なお、プールの基本的な設定の変更については、 &suse; でのサポート対象外となっています。</para>
    <sect4 xml:id="sec-libvirt-storage-vmm-manage-pool">
     <title>プールの起動／停止／削除</title>
     <para>ストレージプールは、 &vmguest; をリモートから管理する際に、 &vmhost; 内に存在するブロックデバイスを &vmguest; に追加したり削除したりする機能を提供するものです。リモートからアクセスできないように一時的に停止したい場合は、ストレージマネージャ内の左下にある <guimenu>停止</guimenu> ボタンを押してください。停止されたプールは <guimenu>状態: 停止</guimenu> となり、左側の一覧ではグレーアウト表示されます。既定では新しく作成したプールは自動的に &vmhost; 側で <guimenu>自動起動</guimenu> が設定され、自動的に起動するようになります。</para>
     <para>停止されているプールを起動して、リモートからアクセスできるようにしたい場合は、ストレージマネージャ内の左下にある <guimenu>開始</guimenu> を押します。</para>
     <note>
      <title>プールの状態は割り当てられているボリュームとは無関係である件について</title>
      <para>既に &vmguest; に割り当てられているプール内のボリュームについては、そのプールの状態 ( <guimenu>動作中</guimenu> もしくは <guimenu>停止</guimenu> ) に関わらず、常にアクセスできる状態になります。プールの状態は、リモートから &vmguest; のボリュームを管理する場合にのみ有効となります。</para>
     </note>
     <para>プールに対して恒久的にアクセスを停止したい場合は、ストレージマネージャ内の左下にある <guimenu>削除</guimenu> ボタンを押します。ただし、削除は停止されたプールにのみ実施することができます。なお、プールを削除しても、 &vmhost; 内の内容が物理的に削除されることはなく、プールの設定のみが削除されます。ただし、 LVM ボリュームグループの場合は例外で、この場合は物理的にも削除されることに注意してください。</para>
     <warning xml:id="deleting-storage-pools">
      <title>ストレージプールの削除</title>
      <para>まだ &vmguest; に割り当てられているボリュームが存在するプールの場合、 <emphasis>ローカルの</emphasis> ファイルシステムディレクトリやパーティション／ディスクをベースにしたストレージプールを削除しても、ボリュームには影響しません。</para>
      <para>iSCSI, SCSI, LVM ボリュームグループ, ネットワーク公開ディレクトリの場合は、プールを削除すると &vmguest; からもアクセスができなくなります。ボリュームそれ自身は削除されませんが、 &vmhost; からリソースへのアクセスはできなくなります。</para>
      <para>iSCSI/SCSI ターゲットやネットワーク公開ディレクトリの場合、新しいプールを作成し直して同じ設定を作成するか、もしくはホストシステム側から対象のリソースを直接マウントすることで、再度アクセスできるようになります。</para>
      <para>LVM ボリュームグループベースのストレージプールの場合、 LVM のボリュームグループ設定が削除されることになりますので、ホストシステム内でも LVM ボリュームグループがアクセスできなくなります。この場合は設定の復元は不可能で、プール内のボリュームも恒久的に失われることになります。</para>
     </warning>
    </sect4>
    <sect4 xml:id="sec-libvirt-storage-vmm-manage-volume-add">
     <title>ストレージプールへのボリュームの追加</title>
     <para>&vmm; ではプールの種類がマルチパス, iSCSI, SCSI である場合を除いて、全てのストレージプール内にボリュームを作成することができます。これらのプール内のボリュームは LUN と等価な存在であり、 &libvirt; 側では変更ができません。</para>
     <procedure>
      <step>
       <para>新しいボリュームはストレージマネージャを利用して作成することができるほか、 &vmguest; に新しいストレージデバイスを追加する際に作成することもできます。いずれの場合であっても、左側のパネルでストレージプールを選択して <guimenu>新しいボリュームの作成</guimenu> を押します。</para>
      </step>
      <step>
       <para><guimenu>名前</guimenu> 欄にイメージの名前を入力して、イメージの形式を選択します。</para>
       <para>&suse; では現在、 <literal>raw</literal> および <literal>qcow2</literal> のイメージのみをサポート対象としています。また、後者は LVM ボリュームグループベースのプールの場合は選択できません。</para>
       <para>次に <guimenu>最大容量</guimenu> を指定します。ここではディスクイメージが利用可能な最大のサイズを指定します。 <literal>qcow2</literal> 形式を選択していない場合は、 <guimenu>割り当て</guimenu> の容量も設定することができます。 <guimenu>割り当て</guimenu> で指定した容量は初期の割り当てサイズとなり、 <guimenu>最大容量</guimenu> と異なる値を設定すると、スパース形式のファイルが作成され、必要に応じてサイズが拡張されるようになります。</para>
       <para><literal>qcow2</literal> 形式の場合は、 <guimenu>バッキングストア</guimenu> (<quote>バッキングファイル</quote> と呼ぶ場合もあります) を使用することもできます。これはイメージのベースとなるファイルを指定するためのもので、新しく作成した <literal>qcow2</literal> イメージには、ベースからの変更点のみが記録されるようになります。</para>
      </step>
      <step>
       <para>ボリュームの作成を開始するには <guimenu>完了</guimenu> を押します。</para>
      </step>
     </procedure>
    </sect4>
    <sect4 xml:id="sec-libvirt-storage-vmm-manage-volume-delete">
     <title>ストレージプールからのボリュームの削除</title>
     <para>ボリュームの削除はストレージマネージャからのみ実施することができます。削除したいボリュームを選択して、 <guimenu>ボリュームの削除</guimenu> を押します。確認メッセージが表示されたら <guimenu>はい</guimenu> を押してください。</para>
     <warning>
      <title>使用中であってもボリュームは削除可能である件について</title>
      <para>ボリュームは動作中の &vmguest; から使用されている状況下でも削除することができます。削除したボリュームを復元する手段はありません。</para>
      <para>対象のボリュームが &vmguest; から使用されているかどうかを確認したい場合は、ストレージマネージャ内の <guimenu>使用中</guimenu> 列を確認してください。</para>
     </warning>
    </sect4>
   </sect3>
  </sect2>
 </sect1>
</chapter>
