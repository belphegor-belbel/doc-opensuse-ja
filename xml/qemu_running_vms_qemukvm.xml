<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter [
<!ENTITY % entities SYSTEM "entity-decl.ent">
%entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha-qemu-running">
 <title>qemu-system-ARCH を利用した仮想マシンの実行</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
  </dm:docmanager>
 </info>
 <para>仮想ディスクイメージの準備 (詳しくは <xref linkend="cha-qemu-guest-inst-qemu-img"/> をお読みください) を行なったあとは、対応する仮想マシンの起動を行なうことができます。 <xref linkend="cha-qemu-guest-inst-qemu-kvm"/> では &vmguest; のインストールから実行までの簡単なコマンドを紹介してきましたが、本章では <command>qemu-system-ARCH</command> のより詳しい説明のほか、特定の作業を行なうための解決方法についても説明しています。 <command>qemu-system-ARCH</command> に用意されている全てのオプションについて説明を読みたい場合は、マニュアルページ ( <command>man 1 qemu</command> ) をご覧ください。</para>
 <sect1 xml:id="cha-qemu-running-basic">
  <title>基本的な <command>qemu-system-ARCH</command> の実行方法</title>

  <para><command>qemu-system-ARCH</command> コマンドは下記の書式で実行します:</para>

<screen>qemu-system-ARCH <replaceable>オプション</replaceable><co xml:id="co-qemu-running-basic-opts"/> <replaceable>ディスクイメージ</replaceable><co xml:id="co-qemu-running-basic-img"/></screen>

  <calloutlist>
   <callout arearefs="co-qemu-running-basic-opts">
    <para><command>qemu-system-ARCH</command> には多数のオプションが存在しています。これらのうちのほとんどは擬似ハードウエアを定義するためのパラメータで、残りはエミュレータの一般的な動作に影響があるものです。何もオプションを指定しない場合は、いずれも既定値が適用されますが、少なくともディスクイメージについては指定する必要があります。</para>
   </callout>
   <callout arearefs="co-qemu-running-basic-img">
    <para>ディスクイメージには、仮想化を行なうゲストシステムのディスクのイメージが含まれているものを指定します。 <command>qemu-system-ARCH</command> では多数のイメージ形式に対応していますので、詳しくは <command>qemu-img</command> <option>--help</option> と入力して実行してください。個別のオプションでディスクイメージを指定しない場合は、 <option>-drive file=</option> オプションで指定することもできます。</para>
   </callout>
  </calloutlist>
 </sect1>
 <sect1 xml:id="cha-qemu-running-gen-opts">
  <title>一般的な <command>qemu-system-ARCH</command> のオプション</title>

  <para>本章では <command>qemu-system-ARCH</command> の一般的なオプションのほか、仮想マシンのプロセッサやメモリ、モデルや時刻処理方式など、基本的な仮想ハードウエアに関連するオプションを説明しています。</para>

  <variablelist>
   <varlistentry>
    <term><literal>-name <replaceable>ゲストの名前</replaceable></literal></term>
    <listitem>
     <para>動作させるゲストシステムの名前を指定します。名前はウインドウのタイトル部分に表示されるほか、 VNC サーバでも使用されます。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>-boot <replaceable>オプション</replaceable></literal></term>
    <listitem>
     <para>起動時にどの順番でドライブを読み込むのかを指定します。ドライブはそれぞれ文字で表わされ、 <literal>a</literal> と <literal>b</literal> がそれぞれフロッピィディスクドライブの 1 台目と 2 台目、 <literal>c</literal> が 1 台目のハードディスク、 <literal>d</literal> が 1 台目の CD-ROM ドライブ、そして <literal>n</literal> から <literal>p</literal> までがイーサネットアダプタかのネットワーク起動を表わします。</para>
     <para>たとえば <literal>qemu-system-ARCH [...] -boot order=ndc</literal> のように指定すると、最初にネットワークからの起動を試し、次に 1 台目のCD-ROM ドライブから、最後に 1 台目のハードディスクからの起動を試すことになります。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>-pidfile <replaceable>ファイル名</replaceable></literal></term>
    <listitem>
     <para>&qemu; のプロセス識別番号 (PID) のファイルへの保存先を指定します。これは &qemu; をスクリプト内で動作させる場合に有用です。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>-nodefaults</literal></term>
    <listitem>
     <para>既定では、 &qemu; はコマンドラインから何も指定を行なわない場合、基本的な仮想デバイスを作成します。このオプションを指定すると、その機能が無効化され、グラフィックカードやネットワークカード、パラレルポートやシリアルポートなど、それぞれのデバイスを個別に手作業で指定しなければならなくなります。また、この場合 &qemu; モニタも既定では接続されなくなります。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>-daemonize</literal></term>
    <listitem>
     <para>&qemu; を起動したあと、プロセスを <quote>デーモン化</quote> します。デーモン化を行なうことで、仮想マシンの準備が整った段階で標準入出力から切り離されるようになります。</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <note>
   <title>SeaBIOS BIOS 実装について</title>
   <para>SeaBIOS は既定で使用される BIOS です。 USB デバイスのほか、任意のドライブ (CD-ROM ドライブ, フロッピィディスクドライブ, ハードディスクドライブ) から起動を行なうことができます。また、 USB マウスやキーボードにも対応し、複数の VGA カードを接続することもできます。 SeaBIOS に関する詳細は、 <link xlink:href="http://www.seabios.org/SeaBIOS">SeaBIOS の Web サイト</link> (英語) をご覧ください。</para>
  </note>

  <sect2 xml:id="cha-qemu-running-gen-opts-basic">
   <title>基本的な仮想ハードウエア構成</title>
   <para/>
   <sect3 xml:id="sec-qemu-running-gen-opts-machine">
    <title>マシンの種類</title>
    <para>擬似するマシンの種類を指定することができます。対応するマシンの種類について、詳しくは <command>qemu-system-ARCH -M help</command> を実行して確認してください。</para>
    <note>
     <title>ISA-PC について</title>
     <para><emphasis>isapc: ISA-only-PC</emphasis> の種類はサポート対象外となっております。</para>
    </note>
   </sect3>
   <sect3 xml:id="cha-qemu-running-gen-opts-basic-cpu">
    <title>CPU モデル</title>
    <para>プロセッサ (CPU) の型式を指定したい場合は、 <command>qemu-system-ARCH -cpu</command> <replaceable>型式</replaceable> のように指定して実行してください。指定可能な CPU の型式について、詳しくは <command>qemu-system-ARCH -cpu help</command> と入力して実行してください。</para>
    <para>CPU フラグに関する情報については、 <link xlink:href="http://ja.wikipedia.org/wiki/CPUID">CPUID の Wikipedia 記事</link> をお読みください。</para>
   </sect3>
   <sect3 xml:id="cha-qemu-running-gen-opts-basic-others">
    <title>その他の基本オプション</title>
    <para>下記に示すオプションは、コマンドラインから <emphasis>qemu</emphasis> を起動する場合によく使用されるオプションです。利用可能なオプションの一覧を表示したい場合は、 <emphasis>qemu-doc</emphasis> のマニュアルページをお読みください。</para>
    <variablelist>
     <varlistentry>
      <term><literal>-m <replaceable>メガバイト</replaceable></literal></term>
      <listitem>
       <para>&vmguest; に割り当てる RAM のサイズを、メガバイト単位で指定します。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-balloon virtio</literal></term>
      <listitem>
       <para>&vmguest; に割り当てる RAM のサイズを動的に変更することのできる、準仮想化デバイスを指定します。動的な割り当ての上限は <literal>-m</literal> で指定します。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-smp <replaceable>CPU_数</replaceable></literal></term>
      <listitem>
       <para>$vmguest; に提供する擬似 CPU 数を指定します。 &qemu; では PC プラットフォームの場合、最大で 255 個 (KVM アクセラレーションを使用した場合 64 個) までの CPU を指定することができます。このオプションは、 <emphasis>ソケット数</emphasis> やソケットあたりの <emphasis>コア数</emphasis> 、コアあたりの <emphasis>スレッド数</emphasis> など、 CPU 関連のパラメータを指定することもできます。</para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>下記は <command>qemu-system-ARCH</command> での指定例です:<remark>cwickert 2017-09-01 calling qemu like this will yield a warning: <quote> Image format was not specified for 'sles12sp2.raw' and probing guessed raw. Automatically detecting the format is dangerous for raw images, write operations on block 0 will be restricted. Specify the 'raw' format explicitly to remove the restrictions. </quote> To avoid this, we should specify the image format like this: "-drive format=raw,file=/images/sles.raw" This however needs to be done consistently throughout the guide, therefor I'm not changing this for now. </remark></para>
<screen>&prompt.user;qemu-system-x86_64 -name "SLES 12 SP2" -M pc-i440fx-2.7 -m 512 \
-machine accel=kvm -cpu kvm64 -smp 2 -drive /images/sles.raw</screen>
    <figure>
     <title>&vmguest; として SLES 11 SP3 を動作させた場合の &qemu; のウインドウ</title>
     <mediaobject>
      <imageobject role="fo">
       <imagedata fileref="qemu_win_sles.png" width="70%" format="PNG"/>
      </imageobject>
      <imageobject role="html">
       <imagedata fileref="qemu_win_sles.png" width="70%" format="PNG"/>
      </imageobject>
     </mediaobject>
    </figure>
    <variablelist>
     <varlistentry>
      <term><literal>-no-acpi</literal></term>
      <listitem>
       <para><xref linkend="gloss-vt-acpi"/> サポートを無効化します。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-S</literal></term>
      <listitem>
       <para>&qemu; を CPU を停止させた状態で開始します。 CPU を起動するには、 &qemu; モニタ内で <literal>c</literal> を押します。詳しくは <xref linkend="cha-qemu-monitor"/> をお読みください。</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>

  <sect2 xml:id="cha-qemu-running-gen-opts-storing-cong">
   <title>仮想デバイスの設定保存と読み込み</title>
   <variablelist>
    <varlistentry>
     <term><literal>-readconfig <replaceable>設定ファイル</replaceable></literal></term>
     <listitem>
      <para>&vmguest; を起動する際、コマンドラインでデバイスの設定オプションを指定する代わりに、設定ファイル内にそれらを保存して使用することができます。設定ファイルの作成は <literal>-writeconfig</literal> で書き込むことができるほか、手作業で作成することもできます。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>-writeconfig <replaceable>設定ファイル</replaceable></literal></term>
     <listitem>
      <para>現在の仮想マシンのデバイス設定を、テキストファイルに保存します。保存したテキストファイルは、後から <literal>-readconfig</literal> オプションで指定することができます。</para>
<screen>&prompt.user;qemu-system-x86_64 -name "SLES 12 SP2" -machine accel=kvm -M pc-i440fx-2.7 -m 512 -cpu kvm64 \
-smp 2 /images/sles.raw -writeconfig /images/sles.cfg
(exited)
&prompt.user;cat /images/sles.cfg
# qemu config file

[drive]
  index = "0"
  media = "disk"
  file = "/images/sles_base.raw"</screen>
      <para>このような仕組みにより、仮想マシンの設定をより効率的かつ整理して管理することができるようになります。</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="cha-qemu-running-gen-opts-rtc">
   <title>ゲスト側のリアルタイムクロック</title>
   <variablelist>
    <varlistentry>
     <term><literal>-rtc <replaceable>オプション</replaceable></literal></term>
     <listitem>
      <para>&vmguest; 内での RTC (リアルタイムクロック) の処理方法を指定します。既定ではゲスト側のクロックはホストシステム側から派生させて使用することになります。そのため、ホスト側のシステムクロックは、正確な外部クロック (例: NTP サービス) と同期させておくことをお勧めします。</para>
      <para>&vmguest; と &vmhost; のクロックを分離したい場合は、既定値である <literal>clock=host</literal> の代わりに <literal>clock=vm</literal> を指定してください。</para>
      <para>なお、 &vmguest; 側の起動時点の時刻を指定することもできます。時刻の指定は <literal>base</literal> オプションで行なってください:</para>
<screen>&prompt.user;qemu-system-x86_64 [...] -rtc clock=vm,base=2010-12-03T01:02:00</screen>
      <para>上記のようなタイムスタンプではなく、 <literal>utc</literal> や <literal>localtime</literal> を指定することもできます。前者の場合、 &vmguest; を現在の UTC 時刻 (Coordinated Universal Time (協定世界時; <link xlink:href="https://ja.wikipedia.org/wiki/UTC"/> )) に、後者の場合は現在のローカル時刻にそれぞれ設定されます。</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
 </sect1>
 <sect1 xml:id="cha-qemu-running-devices">
  <title>&qemu; 内でのデバイスの使用</title>

  <para>&qemu; の仮想マシンは &vmguest; を動作させるのに必要な全てのデバイスを擬似します。 &qemu; では、ネットワークカードやブロックデバイス (ハードディスク、リムーバブルドライブなど) 、 USB デバイスやキャラクタデバイス (シリアルポートやパラレルポート) 、マルチメディアデバイス (グラフィックカード、サウンドカード) などに対応しています。本章では、対応するさまざまな種類のデバイスについて、それらを設定するオプションを紹介しています。</para>

  <tip>
   <para>なお、デバイス側 (例: <literal>-drive</literal>) で特殊なドライバやドライバ設定を指定する必要がある場合、ドライバは <literal>-device</literal> オプションで設定し、ドライバを <literal>drive=</literal> で指定してください。具体的には下記のようになります:</para>
<screen>&prompt.sudo;qemu-system-x86_64 [...] -drive if=none,id=drive0,format=raw \
-device virtio-blk-pci,drive=drive0,scsi=off ...</screen>
   <para>利用可能なドライバや設定に関する情報を得たい場合は、 <option>-device ?</option> オプション、もしくは <option>-device <replaceable>ドライバ名</replaceable>,?</option> オプションを指定して実行してください。</para>
  </tip>

  <sect2 xml:id="cha-qemu-running-devices-block">
   <title>ブロックデバイス</title>
   <para>ブロックデバイスは仮想マシンを動作させるのに必須のデバイスです。一般的には固定メディアと取り外し可能メディアの 2 種類が存在し、これらを総称して <emphasis>ドライブ</emphasis> と呼んでいます。通常は、接続されているうちの 1 台にゲスト側のオペレーティングシステムがインストールされます。</para>
   <para><xref linkend="gloss-vt-vm"/> のドライブは <literal>-drive</literal> で定義します。このオプションには多数のサブオプションが存在し、それらのうちのいくつかを本章で紹介しています。全ての一覧を読みたい場合は、マニュアルページ ( <command>man 1 qemu</command> ) をご覧ください。</para>
   <variablelist>
    <title><literal>-drive</literal> オプションに対するサブオプション</title>
    <varlistentry>
     <term><literal>file=<replaceable>ファイルパス</replaceable></literal></term>
     <listitem>
      <para>このドライブで使用するディスクイメージのパスを指定します。何も指定しない場合、何も挿入されていない (リムーバブル) ドライブであるものとされます。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>if=<replaceable>インターフェイス</replaceable></literal></term>
     <listitem>
      <para>ドライブが接続されているインターフェイスの種類を指定します。現時点では、 &suse; では <literal>floppy</literal> (フロッピィディスク) , <literal>scsi</literal> (SCSI) , <literal>ide</literal> (IDE) , <literal>virtio</literal> (virtio) のみをサポート対象としています。 <literal>virtio</literal> を指定すると、準仮想化型ディスクドライバを使用します。既定値は <literal>ide</literal> です。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>index=<replaceable>コネクタ番号</replaceable></literal></term>
     <listitem>
      <para>ディスクインターフェイス (詳しくは <literal>if</literal> オプションをご覧ください) 側での、ディスクが接続されているコネクタの番号を指定します。何も指定しない場合、コネクタ番号は自動で付与されます。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>media=<replaceable>種類</replaceable></literal></term>
     <listitem>
      <para>メディアの種類を指定します。ハードディスクの場合は <literal>disk</literal> を、リムーバブル CD-ROM ドライブの場合は <literal>cdrom</literal> を指定します。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>format=<replaceable>形式</replaceable></literal></term>
     <listitem>
      <para>接続されているディスクイメージの形式を指定します。何も指定しない場合、形式を自動検出します。現時点では、 &suse; では <literal>raw</literal> , <literal>qcow2</literal> をそれぞれサポートします。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>cache=<replaceable>キャッシュ方式</replaceable></literal></term>
     <listitem>
      <para>ドライブに対するキャッシュ方法を指定します。指定可能な値は <literal>unsafe</literal> , <literal>writethrough</literal> , <literal>writeback</literal> , <literal>directsync</literal> , <literal>none</literal> のいずれかです。 <literal>qcow2</literal> イメージ形式で性能を改善したい場合は <literal>writeback</literal> を指定してください。なお <literal>none</literal> を指定するとホスト側でのキャッシュが無効化されますので、最も安全な選択となります。イメージファイルの場合、既定値は <literal>writeback</literal> となります。詳しくは <xref linkend="cha-cachemodes"/> をお読みください。</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <tip>
    <para>ブロックデバイスの設定を単純化することもできます。 &qemu; にはいくつかのショートカットが規定されていて、これらを使用することで <literal>qemu-system-ARCH</literal> のコマンドラインを短くすることができます。</para>
    <para>たとえば下記のように指定することができます:</para>
<screen>&prompt.sudo;qemu-system-x86_64 -cdrom /images/cdrom.iso</screen>
    <para>上記は、下記のような意味になります:</para>
<screen>&prompt.sudo;qemu-system-x86_64 -drive file=/images/cdrom.iso,index=2,media=cdrom</screen>
    <para>また、下記のように指定することもできます:</para>
<screen>&prompt.sudo;qemu-system-x86_64 -hda /images/imagei1.raw -hdb /images/image2.raw -hdc \
/images/image3.raw -hdd /images/image4.raw</screen>
    <para>上記は、下記のような意味になります:</para>
<screen>&prompt.sudo;qemu-system-x86_64 -drive file=/images/image1.raw,index=0,media=disk \
-drive file=/images/image2.raw,index=1,media=disk \
-drive file=/images/image3.raw,index=2,media=disk \
-drive file=/images/image4.raw,index=3,media=disk</screen>
   </tip>
   <tip>
    <title>イメージではなくホストのドライブを使用する方法について</title>
    <para>ディスクイメージを使用 (詳しくは <xref linkend="cha-qemu-guest-inst-qemu-img"/> ) する代わりに、 &vmhost; 内にある既存のディスク選択してドライブとして使用し、 &vmguest; からアクセスすることもできます。この場合は、ディスクイメージのファイルパスを指定する箇所で、ホスト側のデバイス名をそのまま記述してください。</para>
    <para>たとえばホスト側の CD-ROM ドライブにアクセスするには、下記のように指定します:</para>
<screen>&prompt.sudo;qemu-system-x86_64 [...] -drive file=/dev/cdrom,media=cdrom</screen>
    <para>ホスト側のハードディスクにアクセスするには、下記のように指定します:</para>
<screen>&prompt.sudo;qemu-system-x86_64 [...] -drive file=/dev/hdb,media=disk</screen>
    <para>なお、 &vmguest; 側が使用しているホスト側のドライブは、 &vmhost; 側からアクセスしてはなりませんし、他の &vmguest; からもアクセスしてはなりません。</para>
   </tip>
   <sect3 xml:id="kvm-freedisk">
    <title>未使用のゲスト側ディスク領域の解放</title>
    <para><xref linkend="gloss-vt-storage-sparse"/> はディスクイメージファイルの形式で、その中にデータが書き込まれていくことによって、そのディスクイメージに指定したサイズまで自動的に拡張が行なわれるものを指します。たとえばスパースディスクイメージ内に 1 GB のデータをコピーすると、そのイメージのサイズは 1 GB だけ拡張します。ですが、そのうちの 500 MB 分のデータを削除しても、既定ではイメージのサイズは自動的には縮小しません。</para>
    <para>このような理由から、 &kvm; のコマンドラインには <option>discard=on</option> というオプションが用意されるようになっています。これはハイパーバイザに対して、スパースイメージ内からデータが削除された場合、そのうちの <quote>不要な</quote> 箇所を自動的に解放する設定です。なお、このオプションはドライブインターフェイスに <literal>if=scsi</literal> を指定した場合にのみ設定することができます:</para>
<screen>&prompt.sudo;qemu-system-x86_64 [...] -drive file=/path/to/file.img,if=scsi,discard=on</screen>
    <important>
     <title>サポート状態について</title>
     <para><option>if=scsi</option> はサポート対象外となっております。このインターフェイスは <emphasis>virtio-scsi</emphasis> ではなく、 <emphasis>lsi SCSI アダプタ</emphasis> に結びつけられているためです。</para>
    </important>
   </sect3>
   <sect3 xml:id="kvm-iothreads">
    <title>IOThreads</title>
    <para>IOThreads は virtio デバイス向けのイベントループスレッドで、スケーラビリティを改善するために I/O 要求を専門で処理するスレッドです。特に SMP 型の &vmhost; 内で多数のディスクデバイスの接続された SMP 型の &vmguest; を動作させているような場合に有用です。 I/O 処理に &qemu; のメインイベントループを使用する代わりに、 IOThreads では複数の CPU に I/O 処理を分散させ、適切に設定されていれば遅延を改善することができるようになっています。</para>
    <para>IOThreads は IOThread オブジェクトを定義することで有効化することができます。あとは virtio デバイスを使用することで、 I/O イベントループ向けのオブジェクトを使用するようになります。多くの virtio デバイスで 1 つの IOThread オブジェクトを共用することもできますし、 virtio デバイスと IOThread オブジェクトを 1:1 で作成して割り当てることもできます。下記の例では、 ID <literal>iothread0</literal> で IOThread を 1 つだけ作成し、それを 2 つの virtio-blk デバイスから使用する場合の例を示しています。</para>
<screen>&prompt.user;qemu-system-x86_64 [...] -object iothread,id=iothread0\
-drive if=none,id=drive0,cache=none,aio=native,\
format=raw,file=filename -device virtio-blk-pci,drive=drive0,scsi=off,\
iothread=iothread0 -drive if=none,id=drive1,cache=none,aio=native,\
format=raw,file=filename -device virtio-blk-pci,drive=drive1,scsi=off,\
iothread=iothread0 [...]</screen>
    <para>下記の qemu コマンドラインでは、 virtio デバイスと IOThread を 1:1 で割り当てる設定を示しています:</para>
<screen>&prompt.user;qemu-system-x86_64 [...] -object iothread,id=iothread0\
-object iothread,id=iothread1 -drive if=none,id=drive0,cache=none,aio=native,\
format=raw,file=filename -device virtio-blk-pci,drive=drive0,scsi=off,\
iothread=iothread0 -drive if=none,id=drive1,cache=none,aio=native,\
format=raw,file=filename -device virtio-blk-pci,drive=drive1,scsi=off,\
    iothread=iothread1 [...]</screen>
   </sect3>
   <sect3 xml:id="kvm-virtio-blk-use-bio">
    <title>virtio-blk 向けの Bio ベースの I/O パス</title>
    <para>I/O に負荷が集中する環境の性能を改善するため、カーネルバージョン 3.7 では、 virtio-blk インターフェイスに対して新しい I/O パスが提供されるようになりました。この bio ベースのブロックデバイスドライバは I/O スケジューラを迂回して動作するため、ゲスト側の I/O パスを短くすることができますので、遅延を短くすることができるようになっています。これは特に、 SSD ディスクなどの高速なストレージデバイスで有用です。</para>
    <para>このドライバは既定では無効化されています。使用するには、下記を実施します:</para>
    <procedure>
     <step>
      <para>ゲスト側のカーネルコマンドラインに対して、 <option>virtio_blk.use_bio=1</option> を追加します。これは <menuchoice><guimenu>&yast;</guimenu><guimenu>システム</guimenu><guimenu>ブートローダ</guimenu></menuchoice> から行なうことができます。</para>
      <para>それ以外にも、 <filename>/etc/default/grub</filename> ファイルを編集して、 <option>GRUB_CMDLINE_LINUX_DEFAULT=</option> 以下に上記の内容をスペース区切りで追加してもかまいません。追加した後は、 <command>grub2-mkconfig &gt;/boot/grub2/grub.cfg</command> を実行すると、 grub2 の起動メニューに反映させることができます。</para>
     </step>
     <step>
      <para>あとはゲスト側のカーネルコマンドラインを反映させるため、再起動を行ないます。</para>
     </step>
    </procedure>
    <tip>
     <title>遅いデバイスでの Bio ベースドライバについて</title>
     <para>bio ベースの virtio-blk ドライバは、ハードディスクドライブのような遅いデバイスの場合、あまり役には立ちません。これは、 bio によるパスの短縮よりもスケジューリングの利点のほうが大きいためです。そのため、遅いデバイスでは bio ベースのドライバを使用してはなりません。</para>
    </tip>
   </sect3>
   <sect3 xml:id="sec-qemu-running-devices-block-iscsi">
    <title>iSCSI リソースへの直接アクセス</title>
    <!-- fate#320080 -->
    <para>QEMU は現在 <literal>libiscsi</literal> との統合が行なわれています。これにより、 QEMU から iSCSI デバイスに直接アクセスすることができるようになっているほか、 iSCSI デバイスを仮想マシンのブロックデバイスとして使用することもできるようになっています。この機能を使用する場合もホスト側の iSCSI イニシエータの設定は必要なく、 libvirt iSCSI ターゲットベースのストレージプールで必要となるだけです。その代わり、 QEMU は iSCSI のターゲット LUN に対して、ユーザスペースライブラリの libiscsi を利用して、直接アクセスすることになります。 iSCSI ベースのディスクデバイスは、 libvirt の XML 設定でも指定することができます。</para>
    <note>
     <title>RAW イメージ形式</title>
     <para>この機能は、 iSCSI プロトコルにさまざまな技術的制限が存在することから、 RAW イメージ形式を使用している場合にのみ使用することができます。</para>
    </note>

     <!--
       SLE12SP2 QEMU acquired a new way of accessing iscsi based
       storage.

       virt-manager does not provide a U/I to assist with this setup, so
       manual libvirt domain xml changes for a guest are required.

       Initiator names are pre-defined, based on vm uuid or name.
     -->
    <para>下記は iSCSI の接続に対する QEMU のコマンドラインインターフェイスを説明しています。</para>

    <note>
     <title>virt-manager の制限事項について</title>
     <para>libiscsi ベースのストレージのプロビジョニング機能は virt-manager インターフェイス側に公開されていませんが、ゲストの XML ファイルを直接編集することで設定を行なうことができます。このような iSCSI ベースのストレージに対するアクセスは、コマンドラインから行ないます。</para>
    </note>

    <screen>&prompt.sudo;qemu-system-x86_64 -machine accel=kvm \
  -drive file=iscsi://192.168.100.1:3260/iqn.2016-08.com.example:314605ab-a88e-49af-b4eb-664808a3443b/0,\
  format=raw,if=none,id=mydrive,cache=none \
  -device ide-hd,bus=ide.0,unit=0,drive=mydrive ...</screen>
<para>下記は iSCSI プロトコルを使用したゲストドメインの XML ファイル例の抜粋です:</para>

  <screen><![CDATA[<devices>
...
  <disk type='network' device='disk'>
    <driver name='qemu' type='raw'/>
    <source protocol='iscsi' name='iqn.2013-07.com.example:iscsi-nopool/2'>
      <host name='example.com' port='3260'/>
    </source>
    <auth username='myuser'>
      <secret type='iscsi' usage='libvirtiscsi'/>
    </auth>
    <target dev='vda' bus='virtio'/>
  </disk>
</devices>]]></screen>

  <para>下記はホストベースの iSCSI イニシエータを使用する設定例ですが、上記との違いを比較してください:</para>
  <screen><![CDATA[<devices>
...
  <disk type='block' device='disk'>
    <driver name='qemu' type='raw' cache='none' io='native'/>
    <source dev='/dev/disk/by-path/scsi-0:0:0:0'/>
    <target dev='hda' bus='ide'/>
    <address type='drive' controller='0' bus='0' target='0' unit='0'/>
  </disk>
  <controller type='ide' index='0'>
    <address type='pci' domain='0x0000' bus='0x00' slot='0x01'
             function='0x1'/>
  </controller>
</devices>]]></screen>
   </sect3>
   <sect3 xml:id="qemu-devices-block-rbd">
    <title>&qemu; での RADOS ブロックデバイスの使用</title>
     <para>RADOS Block Devices (RBD) は Ceph クラスタ内にデータを保存する仕組みです。この仕組みではスナップショットやレプリケーション、データの一貫性維持などの機能が用意されています。お使いの &kvm; 管理下の &vmguest; からは、他のブロックデバイスを使用する場合と同様の方法で使用することができます。</para>
     <para os="sles;sled">詳しくは &ses; <citetitle>&admin;</citetitle> 内にある <citetitle>Ceph as a Back-end for QEMU KVM Instance</citetitle> の章をお読みください。 &ses; のドキュメンテーションは <link xlink:href="https://documentation.suse.com/ses/"/> で公開されています。</para>
   </sect3>

  </sect2>

  <sect2 xml:id="cha-qemu-running-devices-graphic">
   <title>グラフィックデバイスとディスプレイのオプション</title>
   <para>本章では擬似ビデオカードの種類の選択のほか、 &vmguest; のグラフィカル出力へのアクセス方法に関わるオプションを説明しています。</para>
   <sect3 xml:id="cha-qemu-running-devices-graphic-vga">
    <title>ビデオカードの定義</title>
    <para>&qemu; では <literal>-vga</literal> オプションを使用して、 &vmguest; のグラフィカルな出力に使用するビデオカードの設定を行ないます。 <literal>-vga</literal> オプションでは下記のような値を指定することができます:</para>
    <variablelist>
     <varlistentry>
      <term><literal>none</literal></term>
      <listitem>
       <para>&vmguest; のビデオカードを無効化します (ビデオカードの擬似を行ないません) 。ただし、シリアルコンソール経由で動作中の &vmguest; にアクセスすることはできます。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>std</literal></term>
      <listitem>
       <para>標準的な VESA 2.0 VBE ビデオカードを擬似します。 &vmguest; で高解像度のディスプレイを使用したい場合に選択してください。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>cirrus</literal></term>
      <listitem>
       <para>Cirrus Logic GD5446 ビデオカードを擬似します。ビデオハードウエアの擬似において高い互換性を必要とする場合は、適切な選択となります。ほとんどのオペレーティングシステム (Windows 95 等でさえも) で使用することができます。</para>
       <tip>
        <para><literal>cirrus</literal> を使用する場合、最適なビデオ性能を得るには、 &vmguest; と &vmhost; で 16 ビット色を使用してください。</para>
       </tip>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 xml:id="cha-qemu-running-devices-graphic-display">
    <title>ディスプレイのオプション</title>
    <para>下記のオプションは、 &vmguest; のグラフィカル出力の表示方法を制御するためのものです。</para>
    <variablelist>
     <varlistentry>
      <term><literal>-display gtk</literal></term>
      <listitem>
       <para>GTK ウインドウ内にビデオ出力を表示します。このインターフェイスには UI 要素が表示され、ここから動作中に VM の設定や制御を行なうことができるようになります。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-display sdl</literal></term>
      <listitem>
       <para>SDL を介してビデオ出力を行ないます。通常は個別のグラフィックウインドウで表示されます。詳しくは SDL のドキュメンテーションをお読みください。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-spice <replaceable>オプション[,オプション[,...]]</replaceable></literal></term>
      <listitem>
       <para>SPICE リモートデスクトッププロトコルを有効化します。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-display vnc</literal></term>
      <listitem>
       <para>詳しくは <xref linkend="cha-qemu-running-vnc"/> をお読みください。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-nographic</literal></term>
      <listitem>
       <para>&qemu; のグラフィカル出力を無効化します。コンソールの内容は、擬似シリアルポートに転送されます。</para>
       <para><literal>-nographic</literal> を指定した仮想マシンを起動した場合、仮想コンソール内で <keycombo><keycap function="control"/><keycap>A</keycap></keycombo> <keycap>H</keycap> を押すことで、さまざまなショートカットの一覧を表示することができます。これにはたとえば、コンソールと &qemu; モニタの切り替えなどの機能があります。</para>
<screen>&prompt.user;qemu-system-x86_64 -hda /images/sles_base.raw -nographic

C-a h    print this help
C-a x    exit emulator
C-a s    save disk data back to file (if -snapshot)
C-a t    toggle console timestamps
C-a b    send break (magic sysrq)
C-a c    switch between console and monitor
C-a C-a  sends C-a
(pressed C-a c)

QEMU 2.3.1 monitor - type 'help' for more information
(qemu)</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-no-frame</literal></term>
      <listitem>
       <para>&qemu; のウインドウに対する装飾を無効化します。専用のデスクトップ作業領域を用意するような場合に便利です。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-full-screen</literal></term>
      <listitem>
       <para>&qemu; のグラフィカル出力をフルスクリーンで表示します。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-no-quit</literal></term>
      <listitem>
       <para>&qemu; のウインドウ内にある閉じるボタンを無効化し、強制的に閉じられてしまうことを防ぎます。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>-alt-grab</literal> , <literal>-ctrl-grab</literal></term>
      <listitem>
       <para>既定では、 &qemu; のウインドウ内でマウスのボタンを押すと、 <keycombo><keycap function="control"/><keycap function="alt"/></keycombo> を押すまではマウスカーソルが外に出られなくなります。このキーの組み合わせを変更し、 <keycombo><keycap function="control"/><keycap function="alt"/><keycap function="shift"/></keycombo>  ( <literal>-alt-grab</literal> ) もしくは右 <keycap function="control"/> キー ( <literal>-ctrl-grab</literal> ) に変更することができます。</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>

  <sect2 xml:id="cha-qemu-running-devices-usb">
   <title>USB デバイス</title>
   <para>&kvm; 内の &vmguest; で利用可能な USB デバイスを作成する方法には 2 つのものがあります。 1 つは &vmguest; 内に新しい擬似 USB デバイスを作成する方法、もう 1 つは既存の USB デバイスを &vmguest; に割り当てる方法です。 &qemu; 内で USB デバイスを使用するには、まず <option>-usb</option> オプションで汎用 USB ドライバを有効化する必要があります。あとは <option>-usbdevice</option> オプションで個別のデバイスを指定していきます。</para>
   <sect3 xml:id="kvm-usb-emulate">
    <title>&vmguest; 内での USB デバイスの擬似</title>
    <para>&suse; では現在、下記の種類の USB デバイスをサポートしています: <literal>disk</literal> , <literal>host</literal> , <literal>serial</literal> , <literal>braille</literal> , <literal>net</literal> , <literal>mouse</literal> , <literal>tablet</literal></para>
    <variablelist>
     <title><literal>-usbdevice</literal> オプションで指定することのできる USB デバイスの種類</title>
     <varlistentry>
      <term><literal>disk</literal></term>
      <listitem>
       <para>ファイルをベースにしたマスストレージデバイスを擬似します。ファイルの形式を自動検出させたくない場合は、 <literal>format</literal> オプションで形式を指定してください。</para>
<screen>&prompt.user;qemu-system-x86_64 [...] -usbdevice
        disk:format=raw:/virt/usb_disk.raw</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>host</literal></term>
      <listitem>
       <para>ホスト側のデバイスをパススルーします (<replaceable>バス</replaceable>.<replaceable>アドレス</replaceable> で識別します)</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>serial</literal></term>
      <listitem>
       <para>ホスト側のキャラクタデバイスに対するシリアルコンバータを定義します。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>braille</literal></term>
      <listitem>
       <para>BrlAPI を使用してブライユ点字ディスプレイを擬似し、ブライユ点字の出力を行ないます。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>net</literal></term>
      <listitem>
       <para>CDC イーサネットおよび RNDIS プロトコルに対応するネットワークアダプタを擬似します。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>mouse</literal></term>
      <listitem>
       <para>仮想 USB マウスを擬似します。このオプションは既定の PS/2 マウスの擬似を上書きする設定です。 <literal>qemu-system-ARCH [...] -usbdevice mouse</literal> を指定して起動した &vmguest; 内で下記のように実行すると、ハードウエアの状態を表示することができます:</para>
<screen>&prompt.sudo;hwinfo --mouse
20: USB 00.0: 10503 USB Mouse
[Created at usb.122]
UDI: /org/freedesktop/Hal/devices/usb_device_627_1_1_if0
[...]
Hardware Class: mouse
Model: "Adomax QEMU USB Mouse"
Hotplug: USB
Vendor: usb 0x0627 "Adomax Technology Co., Ltd"
Device: usb 0x0001 "QEMU USB Mouse"
[...]</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>tablet</literal></term>
      <listitem>
       <para>絶対座標系を使用するポインタデバイス (例: タッチスクリーン) を擬似します。このオプションは、既定の PS/2 マウスの擬似を上書きする設定となります。タブレットデバイスは、 &vmguest; を VNC プロトコル経由で操作する場合に有用です。詳しくは <xref linkend="cha-qemu-running-vnc"/> をお読みください。</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>

  <sect2 xml:id="cha-qemu-running-devices-char">
   <title>キャラクタデバイス</title>
   <para><literal>-chardev</literal> オプションを指定することで、新しいキャラクタデバイスを作成することができます。一般的には下記のような書式を使用します:</para>
<screen>qemu-system-x86_64 [...] -chardev <replaceable>バックエンドの種類</replaceable>,id=<replaceable>ID_文字列</replaceable></screen>
   <para>ここで、 <replaceable>バックエンドの種類</replaceable> には、 <literal>null</literal> , <literal>socket</literal> , <literal>udp</literal> , <literal>msmouse</literal> , <literal>vc</literal> , <literal>file</literal> , <literal>pipe</literal> , <literal>console</literal> , <literal>serial</literal> , <literal>pty</literal> , <literal>stdio</literal> , <literal>braille</literal> , <literal>tty</literal> , <literal>parport</literal> のいずれかを指定します。また、それぞれのキャラクタデバイスに対しては、最大で 127 文字までの識別 (ID) 文字列を指定しなければなりません。この識別文字列は、関連する他のディレクティブを指定する際に使用します。それぞれのバックエンドに対する全てのオプションについて、詳しくはマニュアルページ ( <command>man 1 qemu</command> ) をお読みください。下記にそれぞれの <literal>バックエンド</literal> に対する概要説明を記述します:</para>
   <variablelist>
    <varlistentry>
     <term><literal>null</literal></term>
     <listitem>
      <para>何もデータを出力せず、入力されたデータをそのまま廃棄するだけのデバイスを作成します。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>stdio</literal></term>
     <listitem>
      <para>&qemu; プロセスの標準入出力に結びつけるデバイスを作成します。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>socket</literal></term>
     <listitem>
      <para>双方向のストリームソケットを作成します。 <replaceable>path</replaceable> サブオプションを指定すると、 Unix ソケットを作成します:</para>
<screen>&prompt.sudo;qemu-system-x86_64 [...] -chardev \
socket,id=unix_socket1,path=/tmp/unix_socket1,server</screen>
      <para><replaceable>server</replaceable> サブオプションを指定すると、作成するソケットを待ち受け状態にします。</para>
      <para><replaceable>port</replaceable> を指定すると、 TCP ソケットを作成します:</para>
<screen>&prompt.sudo;qemu-system-x86_64 [...] -chardev \
socket,id=tcp_socket1,host=localhost,port=7777,server,nowait</screen>
      <para>このコマンドは、 TCP ポートの 7777 番を利用して、待ち受け側の ( <literal>server</literal> ) ソケットを作成します。 &qemu; では待ち受けるポートに対して、クライアント側からの接続を待機しないようにしています ( <literal>nowait</literal> ) 。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>udp</literal></term>
     <listitem>
      <para>&vmguest; からの全てのネットワークトラフィックを、 UDP プロトコルを介して指定したリモートホストに転送します。</para>
<screen>&prompt.sudo;qemu-system-x86_64 [...] \
-chardev udp,id=udp_fwd,host=&wsIVname;,port=7777</screen>
      <para>このコマンドは、 &vmguest; から受信したデータを、ポート 7777 から &wsIVname; 宛に送信します。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>vc</literal></term>
     <listitem>
      <para>新しい &qemu; のテキストコンソールを作成します。下記のようにすることで、仮想コンソールの幅と高さを指定することができます:</para>
<screen>&prompt.sudo;qemu-system-x86_64 [...] -chardev vc,id=vc1,width=640,height=480 \
-mon chardev=vc1</screen>
      <para>このコマンドは <literal>vc1</literal> という名前の仮想コンソールを指定したサイズで作成し、 &qemu; モニタに接続します。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>file</literal></term>
     <listitem>
      <para>&vmguest; からの全てのデータを &vmhost; 内のファイルに書き込みます。 <literal>path</literal> サブオプションを指定する必要があります。指定したファイルが存在しない場合は、作成されます。</para>
<screen>&prompt.sudo;qemu-system-x86_64 [...] \
-chardev file,id=qemu_log1,path=/var/log/qemu/guest1.log</screen>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>既定では、 &qemu; はシリアルポートとパラレルポートに対応するキャラクタデバイスを作成するほか、 &qemu; モニタ向けに特殊なコンソールを作成します。必要であれば、独自のキャラクタデバイスを作成して上述の用途で使用することができます。この場合、下記のオプションを指定しておくと良いでしょう:</para>
   <variablelist>
    <varlistentry>
     <term><literal>-serial <replaceable>キャラクタデバイス</replaceable></literal></term>
     <listitem>
      <para>上記のように指定することで、 &vmguest; の仮想シリアルポートが &vmhost; 内の <replaceable>キャラクタデバイス</replaceable> に転送されるようになります。グラフィカルモードの場合、既定では仮想コンソール ( <literal>vc</literal> ) になりますし、グラフィカルモードでない場合は <literal>stdio</literal> (標準入出力) になります。このほか、 <literal>-serial</literal> オプションには多数のサブオプションが用意されています。詳しくは <command>man 1 qemu</command> で表示することのできるマニュアルページをお読みください。</para>
      <para>なお、最大で 4 個までのシリアルポートを擬似することができます。シリアルポートを全て無効化したい場合は、 <literal>-serial none</literal> を指定してください。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>-parallel <replaceable>デバイス</replaceable></literal></term>
     <listitem>
      <para>上記のように指定することで、 &vmguest; の仮想パラレルポートが &vmhost; 内の <replaceable>デバイス</replaceable> に転送されるようになります。指定することのできるデバイスは <literal>-serial</literal> と同じです。</para>
      <tip>
       <para>&vmhost; に <phrase os="sles;sled">&sls;</phrase> <phrase os="osuse">&opensuse; Leap</phrase> を使用している場合、ハードウエア側のパラレルポートに直接接続することもできます。この場合は <filename>/dev/parportN</filename> (<literal>N</literal> はポート番号) のように指定してください。</para>
      </tip>
      <para>なお、最大で 3 個までのパラレルポートを擬似することができます。パラレルポートを全て無効化したい場合は、 <literal>-parallel none</literal> を指定してください。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>-monitor <replaceable>キャラクタデバイス</replaceable></literal></term>
     <listitem>
      <para>&qemu; のモニタを &vmhost; 内の <replaceable>キャラクタデバイス</replaceable> に転送するよう設定します。指定することのできるデバイスは <literal>-serial</literal> と同じです。グラフィカルモードの場合、既定では仮想コンソール ( <literal>vc</literal> ) になりますし、グラフィカルモードでない場合は <literal>stdio</literal> (標準入出力) になります。</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>利用可能な全てのデバイスバックエンドについて、詳しくは ( <command>man 1 qemu</command> ) で表示することのできるマニュアルページをお読みください。</para>
  </sect2>
 </sect1>
 <sect1 xml:id="cha-qemu-running-networking">
  <title>&qemu; でのネットワーク</title>

  <para><option>-device</option> とともに <literal>-netdev</literal> オプションを指定することで、ネットワークの種類を指定して &vmguest; のネットワークインターフェイスを追加することができるようになります。 <option>-netdev</option> オプションの書式は下記のとおりです:</para>

<screen>-netdev <replaceable>種類</replaceable>[,<replaceable>キー</replaceable>[=<replaceable>値</replaceable>][,...]]</screen>

  <para>現時点では、 &suse; は <literal>user</literal> , <literal>bridge</literal> , <literal>tap</literal> の種類のみをサポート対象としています。 <literal>-netdev</literal> で指定可能な全サブオプションの一覧について、詳しくはマニュアルページ ( <command>man 1 qemu</command> ) をお読みください。</para>

  <variablelist>
   <title>対応する <literal>-netdev</literal> サブオプション</title>
   <varlistentry>
    <term><literal>bridge</literal></term>
    <listitem>
     <para>指定したネットワークヘルパーを使用して TAP インターフェイスの設定を行ない、それを指定したブリッジに接続します。詳しくは <xref linkend="cha-qemu-running-networking-bridge"/> をお読みください。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>user</literal></term>
    <listitem>
     <para>ユーザモードネットワーキングを指定します。詳しくは <xref linkend="cha-qemu-running-networking-usermode"/> をお読みください。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>tap</literal></term>
    <listitem>
     <para>ブリッジもしくはルーティング型のネットワークを指定します。詳しくは <xref linkend="cha-qemu-running-networking-bridge"/> をお読みください。</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <sect2 xml:id="cha-qemu-running-networking-nic">
   <title>ネットワークインターフェイスカードの定義</title>
   <para><option>-device</option> オプションとともに <literal>-netdev</literal> オプションを指定することで、新しい擬似ネットワークカードを追加することができます:</para>
<screen>&prompt.sudo;qemu-system-x86_64 [...] \
-netdev tap<co xml:id="co-qemu-running-networking-nic-tap"/>,id=hostnet0 \
-device virtio-net-pci<co xml:id="co-qemu-running-networking-nic-drv"/>,netdev=hostnet0,vlan=1<co xml:id="co-qemu-running-networking-nic-vlan"/>,\
macaddr=&wsIVmac;<co xml:id="co-qemu-running-networking-nic-mac"/>,name=ncard1</screen>
   <calloutlist>
    <callout arearefs="co-qemu-running-networking-nic-tap">
     <para>ネットワークデバイスの種類を指定しています。</para>
    </callout>
    <callout arearefs="co-qemu-running-networking-nic-drv">
     <para>ネットワークカードの型式を指定しています。お使いのプラットフォームの &qemu; で指定可能な全てのネットワークカードの一覧を取得するには、 <command>qemu-system-ARCH -device help</command> を実行して <literal>Network devices:</literal> セクション以下をご覧ください。</para>
     <remark>cwickert 2017-09-01: still up to date?</remark>
     <para>現時点では、 &suse; は <literal>rtl8139</literal> , <literal>e1000</literal> およびその派生系である <literal>e1000-82540em</literal> , <literal>e1000-82544gc</literal> , <literal>e1000-82545em</literal> , <literal>virtio-net-pci</literal> にそれぞれ対応しています。そのドライバで指定可能なオプションの一覧を取得したい場合は、ドライバのオプションの箇所に <option>help</option> を追加してください:</para>
<screen>&prompt.sudo;qemu-system-x86_64 -device e1000,help
e1000.mac=macaddr
e1000.vlan=vlan
e1000.netdev=netdev
e1000.bootindex=int32
e1000.autonegotiation=on/off
e1000.mitigation=on/off
e1000.addr=pci-devfn
e1000.romfile=str
e1000.rombar=uint32
e1000.multifunction=on/off
e1000.command_serr_enable=on/off</screen>
    </callout>
    <callout arearefs="co-qemu-running-networking-nic-vlan">
     <para>ネットワークインターフェイスを VLAN 番号 1 に接続する指定です。主に識別用のものとなりますが、必要であれば独自の番号を設定することができます。このサブオプションを省略した場合、 &qemu; は既定値である 0 を指定したものとみなします。</para>
    </callout>
    <callout arearefs="co-qemu-running-networking-nic-mac">
     <para>ネットワークカードの Media Access Control (MAC) アドレスを指定しています。この値はネットワーク内で唯一のものでなければならないため、必ず指定しておくことをお勧めします。指定しない場合、 &qemu; は既定の MAC アドレスを使用してしまうため、同じ VLAN 内で MAC アドレスの重複を引き起こしてしまうことになります。</para>
    </callout>
   </calloutlist>
  </sect2>

  <sect2 xml:id="cha-qemu-running-networking-usermode">
   <title>ユーザモードネットワーク</title>
   <para><literal>-netdev user</literal> オプションを指定することで、 &qemu; に対してユーザモードのネットワーキングを使用するように指定することができます。これはネットワーキングモードを指定しない場合の既定であるため、下記のコマンドはいずれも同じ意味になります:</para>
<screen>&prompt.sudo;qemu-system-x86_64 -hda /images/sles_base.raw</screen>
<screen>&prompt.sudo;qemu-system-x86_64 -hda /images/sles_base.raw -netdev user,id=hostnet0</screen>
   <para>このモードは、 &vmguest; からインターネットなどの外部リソースにアクセスさせる必要があるような場合に有用です。既定では着信側のトラフィックは許可されない仕組みであるため、 &vmguest; はネットワーク内では他のマシンから見えない存在になります。また、このネットワークモードを使用する場合、管理者権限は不要となります。ユーザモードは、 &vmhost; 内のローカルディレクトリから &vmguest; をネットワークブートするような場合にも有用です。</para>
   <para>なお、このモードの場合、仮想的な DHCP サーバを利用して &vmguest; に IP アドレスが割り当てられます。 &vmhost; (DHCP サーバ) は 10.0.2.2 、そして割り当てられる IP アドレスの範囲は 10.0.2.15 以降となります。 <command>ssh</command> や <command>scp</command> などで 10.0.2.2 を指定することで、 &vmhost; に接続してファイルのやり取りを行なったりすることができます。</para>
   <sect3 xml:id="cha-qemu-running-networking-usermode-examples">
    <title>コマンドライン例</title>
    <para>本章ではユーザモードのネットワーキングの設定例をいくつか示しています:</para>
    <example xml:id="ex-qemu-net-usermode-resctrict">
     <title>制限付きユーザモードネットワーク</title>
<screen>&prompt.sudo;qemu-system-x86_64 [...] \
-netdev user<co xml:id="co-usermode-user"/>,id=hostnet0 \
-device virtio-net-pci,netdev=hostnet0,vlan=1<co xml:id="co-usermode-vlan"/>,name=user_net1<co xml:id="co-usermode-name"/>,restrict=yes<co xml:id="co-usermode-restrict"/></screen>
     <calloutlist>
      <callout arearefs="co-usermode-user">
       <para>ユーザモードネットワーキングの指定を行なっています。</para>
      </callout>
      <callout arearefs="co-usermode-vlan">
       <para>VLAN 番号 1 に接続しています。省略した場合、既定値である 0 になります。</para>
      </callout>
      <callout arearefs="co-usermode-name">
       <para>ネットワークスタックに対する分かりやすい名前を指定しています。 &qemu; モニタなどで識別する際に有用です。</para>
      </callout>
      <callout arearefs="co-usermode-restrict">
       <para>&vmguest; を孤立させる指定です。これにより &vmhost; と通信ができなくなるほか、外部ネットワークにもパケットが送信されなくなります。</para>
      </callout>
     </calloutlist>
    </example>
    <example xml:id="ex-qemu-net-usermode-iprange">
     <title>独自の IP アドレス範囲を指定したユーザモードネットワーク</title>
<screen>&prompt.sudo;qemu-system-x86_64 [...] \
-netdev user,id=hostnet0 \
-device virtio-net-pci,netdev=hostnet0,net=10.2.0.0/8<co xml:id="co-usermode-net"/>,host=10.2.0.6<co xml:id="co-usermode-host"/>,\
dhcpstart=10.2.0.20<co xml:id="co-usermode-dhcpstart"/>,hostname=tux_kvm_guest<co xml:id="co-usermode-hostname"/></screen>
     <calloutlist>
      <callout arearefs="co-usermode-net">
       <para>&vmguest; との間で使用されるネットワークの IP アドレスとネットマスク (オプション) を指定しています。既定値は 10.0.2.0/8 です。</para>
      </callout>
      <callout arearefs="co-usermode-host">
       <para>&vmguest; から見た &vmhost; のアドレスを指定しています。既定値は 10.0.2.2 です。</para>
      </callout>
      <callout arearefs="co-usermode-dhcpstart">
       <para>内蔵の DHCP サーバが割り当てる最初の IP アドレスを指定しています。このアドレスから最大で 16 個までを割り当てることができます。既定値は 10.0.2.15 です。</para>
      </callout>
      <callout arearefs="co-usermode-hostname">
       <para>内蔵 DHCP サーバが &vmguest; に対して送信する、 &vmguest; 側のホスト名を指定しています。</para>
      </callout>
     </calloutlist>
    </example>
    <example xml:id="ex-qemu-net-usermode-netboot-tftp">
     <title>ネットワーク起動と TFTP を利用したユーザモードネットワーク</title>
<screen>&prompt.sudo;qemu-system-x86_64 [...] \
-netdev user,id=hostnet0 \
-device virtio-net-pci,netdev=hostnet0,tftp=/images/tftp_dir<co xml:id="co-usermode-tftp"/>,\
bootfile=/images/boot/pxelinux.0<co xml:id="co-usermode-bootfile"/></screen>
     <calloutlist>
      <callout arearefs="co-usermode-tftp">
       <para>内蔵 TFTP (非常に基本的な機能に限定されたファイル転送プロトコル) サーバを有効化しています。 &vmguest; 側からは、指定したディレクトリがルートディレクトリとなります。</para>
      </callout>
      <callout arearefs="co-usermode-bootfile">
       <para>指定したファイルを BOOTP (IP アドレスと起動イメージの場所を提供するネットワークプロトコル、主にディスクレスマシンで使用します) ファイルとして提供する指定です。 <literal>tftp</literal> オプションとともに使用した場合、 &vmguest; はホスト内のローカルディレクトリ内のファイルからネットワーク起動できるようになります。</para>
      </callout>
     </calloutlist>
    </example>
    <example xml:id="ex-qemu-net-usermode-hostfwd">
     <title>ホスト側でのポート転送を指定したユーザモードネットワーク</title>
<screen>&prompt.sudo;qemu-system-x86_64 [...] \
-netdev user,id=hostnet0 \
-device virtio-net-pci,netdev=hostnet0,hostfwd=tcp::2222-:22</screen>
     <para>ホスト側で TCP ポート番号 2222 に届いたパケットを、 &vmguest; 側の TCP ポート番号 22 ( <systemitem class="service">SSH</systemitem> ) に転送する指定です。 &vmguest; 側で <systemitem class="daemon">sshd</systemitem> が動作していれば、</para>
<screen>&prompt.user;ssh <replaceable>ホスト</replaceable> -p 2222</screen>
     <para>のように入力することで、 &vmguest; 側の <systemitem class="daemon">SSH</systemitem> に接続することができるようになります。ここで <replaceable>ホスト</replaceable> には &vmhost; のホスト名または IP アドレスを指定します。</para>
    </example>
   </sect3>
  </sect2>

  <sect2 xml:id="cha-qemu-running-networking-bridge">
   <title>ブリッジ型ネットワーク</title>
   <para><literal>-netdev tap</literal> オプションを指定することで、 &qemu; はネットワークブリッジを作成し、ホスト側の TAP ネットワークデバイスを &vmguest; の指定 VLAN に接続することができます。これにより、ネットワークインターフェイスはネットワーク側からアクセスできるようになります。なお、この方式は既定では選択されないため、明示的に指定する必要があります。</para>
   <para>まずはネットワークブリッジを作成し、 &vmhost; の物理ネットワークインターフェイス (通常は <literal>eth0</literal>) をブリッジに追加します:</para>
   <procedure>
    <step>
     <para>&yastcc; を起動し、 <menuchoice><guimenu>システム</guimenu><guimenu>ネットワークの設定</guimenu></menuchoice> を選択します。</para>
    </step>
    <step>
     <para><guimenu>追加</guimenu> を押したあと、 <guimenu>ハードウエアダイアログ</guimenu> ウインドウ内で、 <guimenu>デバイスの種類</guimenu> のドロップダウンボックスで <guimenu>ブリッジ</guimenu> を選択します。あとは <guimenu>次へ</guimenu> を押します。</para>
    </step>
    <step>
     <para>IP アドレスを動的もしくは静的に設定したい場合はそれぞれの項目を設定します。また、必要であればその他の設定も行ないます。</para>
    </step>
    <step>
     <para><guimenu>ブリッジ接続デバイス</guimenu> のタブを選択して、ブリッジに追加するイーサネットデバイスを選択します。</para>
     <para><guimenu>次へ</guimenu> を行ないます。既に設定されているデバイスを追加する旨のメッセージが表示された場合は、 <guimenu>続行</guimenu> を押します。</para>
    </step>
    <step>
     <para>最後に <guimenu>OK</guimenu> を押して変更点を保存します。あとはブリッジが作成されていることを確認します:</para>
<screen>&prompt.user;bridge link
2: eth0 state UP : &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 master br0 \
 state forwarding priority 32 cost 100
</screen>
    </step>
   </procedure>
   <sect3 xml:id="cha-qemu-running-networking-bridge-manually">
    <title>ブリッジへの手動接続</title>
    <para>下記のようなサンプルスクリプトを使用することで、 &vmguest; を新しく作成したブリッジ <literal>br0</literal> に接続することができます。スクリプト内のコマンドはいずれも管理者権限が必要となることから、 <command>sudo</command> の仕組みを利用して実行するよう作られています。</para>
    <tip>
     <title>必要なソフトウエアについて</title>
     <para>ネットワークブリッジを管理するには、 <package>tunctl</package> パッケージをインストールしておく必要があります。</para>
    </tip>
<screen>
#!/bin/bash
bridge=br0<co xml:id="co-qemu-net-bridge-br"/>
tap=$(sudo tunctl -u $(whoami) -b)<co xml:id="co-qemu-net-bridge-tap"/>
sudo ip link set $tap up<co xml:id="co-qemu-net-bridge-up"/>
sleep 1s<co xml:id="co-qemu-net-bridge-sleep"/>
sudo ip link add name $bridge type bridge
sudo ip link set $bridge up
sudo ip link set $tap master $bridge<co xml:id="co-qemu-net-bridge-br3"/>
qemu-system-x86_64 -machine accel=kvm -m 512 -hda /images/sles_base.raw \
 -netdev tap,id=hostnet0 \
 -device virtio-net-pci,netdev=hostnet0,vlan=0,macaddr=&wsIVmac;,\
 ifname=$tap<co xml:id="co-qemu-net-bridge-ifname"/>,script=no<co xml:id="co-qemu-net-bridge-script"/>,downscript=no
sudo ip link set $tap nomaster<co xml:id="co-qemu-net-bridge-delif"/>
sudo ip link set $tap down<co xml:id="co-qemu-net-bridge-linkdown"/>
sudo tunctl -d $tap<co xml:id="co-qemu-net-bridge-deltap"/></screen>
    <calloutlist>
     <callout arearefs="co-qemu-net-bridge-br">
      <para>ブリッジデバイスの名前です。</para>
     </callout>
     <callout arearefs="co-qemu-net-bridge-tap">
      <para>新しい TAP デバイスを作成し、スクリプトを実行したユーザに権限を与えます。 TAP デバイスは仮想的なネットワークデバイスで、しばしば仮想化やエミュレーションで用いられるものです。</para>
     </callout>
     <callout arearefs="co-qemu-net-bridge-up">
      <para>新しく作成した TAP ネットワークインターフェイスを起動しています。</para>
     </callout>
     <callout arearefs="co-qemu-net-bridge-sleep">
      <para>TAP ネットワークデバイスの準備を待つため、 1 秒間の一時停止を設定しています。</para>
     </callout>
     <callout arearefs="co-qemu-net-bridge-br3">
      <para>新しい <literal>TAP</literal> デバイスをネットワークブリッジ <literal>br0</literal> に追加しています。</para>
     </callout>
     <callout arearefs="co-qemu-net-bridge-ifname">
      <para><literal>ifname=</literal> サブオプションでは、ブリッジに使用する TAP ネットワークインターフェイスの名前を指定しています。</para>
     </callout>
     <callout arearefs="co-qemu-net-bridge-script">
      <para><command>qemu-system-ARCH</command> がネットワークブリッジに接続する前に、それぞれ <literal>script</literal> と <literal>downscript</literal> の値が調べられます。 &vmhost; のファイルシステム内に該当するスクリプトが見つかった場合、 <literal>script</literal> はネットワークブリッジへの接続前に、 <literal>downscript</literal> はネットワーク環境の終了時にそれぞれ実行されます。また、既定では <filename>/etc/qemu-ifup</filename> および <filename>/etc/qemu-ifdown</filename> をそれぞれ実行します。 <literal>script=no</literal> および <literal>downscript=no</literal> を指定すると、これらのスクリプトは無効化され、必要に応じて手作業で作業を行なうことになります。</para>
     </callout>
     <callout arearefs="co-qemu-net-bridge-delif">
      <para>ネットワークブリッジ <literal>br0</literal> から TAP インターフェイスを削除しています。</para>
     </callout>
     <callout arearefs="co-qemu-net-bridge-linkdown">
      <para>TAP デバイスの状態を <literal>down</literal> (停止) に設定しています。</para>
     </callout>
     <callout arearefs="co-qemu-net-bridge-deltap">
      <para>TAP デバイスを削除しています。</para>
     </callout>
    </calloutlist>
   </sect3>
   <sect3 xml:id="qemu-bridge-helper">
    <title>qemu-bridge-helper を利用したブリッジへの接続</title>
    <para>&vmguest; をネットワークブリッジ経由でネットワークに接続する場合、もう 1 つの方法として <filename>qemu-bridge-helper</filename> というヘルパープログラムを使用する方法が用意されています。これは TAP インターフェイスを作成して指定したブリッジに接続するまでの処理を行ないます。既定のヘルパープログラムは <filename>/usr/lib/qemu-bridge-helper</filename> にあります。なお、このヘルパープログラムは setuid root ビットが設定されていて、かつ仮想化グループ ( <literal>kvm</literal> ) のメンバーのみに実行権限が与えられていますので、 <command>qemu-system-ARCH</command> コマンド自身を &rootuser; 権限で動作させる必要はありません。</para>
    <para>ヘルパーは下記のようにしてネットワークブリッジを指定した場合、自動的に呼び出されます:</para>
<screen>qemu-system-x86_64 [...] \
 -netdev bridge,id=hostnet0,vlan=0,br=br0 \
 -device virtio-net-pci,netdev=hostnet0</screen>
    <para>TAP デバイスの設定／設定解除を行なうプログラムを用意することで、独自のプログラムを実行することもできます。ヘルパープログラムを指定するには、 <option>helper=<replaceable>ヘルパープログラムのパス</replaceable></option> のように指定してください:</para>
<screen>qemu-system-x86_64 [...] \
 -netdev bridge,id=hostnet0,vlan=0,br=br0,helper=/path/to/bridge-helper \
 -device virtio-net-pci,netdev=hostnet0</screen>
    <tip>
     <para><literal>qemu-bridge-helper</literal> に対してアクセス権限を設定するには、 <filename>/etc/qemu/bridge.conf</filename> ファイルを作成してください。たとえば下記のようなディレクティブを設定したものとすると、</para>
<screen>allow br0</screen>
     <para><command>qemu-system-ARCH</command> コマンドが &vmguest; をネットワークブリッジに追加する際、 <literal>br0</literal> を指定できるようになります。</para>
    </tip>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="cha-qemu-running-vnc">
  <title>VNC を利用した &vmguest; の表示</title>

  <para>既定の &qemu; では GTK (クロスプラットフォーム型のツールキットライブラリ) ウインドウを作成し、 &vmguest; のグラフィカルな出力を表示します。 <remark condition="clarity"> 2014-08-06 - fs: feedback from brogers: We should explain the "display xxx" command line syntax to present the various display options before diving into the vnc details. </remark> <literal>-vnc</literal> オプションを指定すると、 &qemu; は VNC ディスプレイを作成して接続を待ち受けるようになり、その VNC ディスプレイ内にグラフィカルな出力を行なうようになります。</para>

  <tip>
   <para>VNC セッションで &qemu; の仮想マシンを操作する場合、 <literal>-usbdevice tablet</literal> オプションを指定しておくとよいでしょう。</para>
   <para>これに加えて、 <literal>en-us</literal> 以外のキーボードレイアウトを使用したい場合は、 <literal>-k</literal> オプションで指定してください。</para>
  </tip>

  <para><literal>-vnc</literal> の最初のサブオプションには、 <emphasis>ディスプレイ</emphasis> 番号を指定しなければなりません。 <literal>-vnc</literal> オプションでは、下記のような形式でディスプレイ番号を指定します:</para>

  <variablelist>
   <varlistentry>
    <term><literal><replaceable>ホスト</replaceable>:<replaceable>ディスプレイ</replaceable></literal></term>
    <listitem>
     <para><replaceable>ディスプレイ</replaceable> のディスプレイへの接続を、 <replaceable>ホスト</replaceable> で指定したホストからの接続のみに制限します。 VNC セッションで使用する TCP ポート番号は通常、 5900 + <replaceable>ディスプレイ</replaceable> になります。また、 <replaceable>ホスト</replaceable> を指定しない場合、任意のマシンから接続できるようになります。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>unix:<replaceable>パス</replaceable></literal></term>
    <listitem>
     <para>Unix ドメインソケットを利用して VNC サーバの待ち受けを行ないます。 <replaceable>パス</replaceable> には Unix ソケットの場所を指定します。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>none</literal></term>
    <listitem>
     <para>VNC サーバの機能を準備しますが、サーバ自身の開始は行なわないようにします。この場合、 &qemu; モニタから開始することができます。詳しくは <xref linkend="cha-qemu-monitor"/> をお読みください。</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>ディスプレイ値の後にカンマ区切りで下記のような追加オプションを指定することができます:</para>

  <variablelist>
   <varlistentry>
    <term><literal>reverse</literal></term>
    <listitem>
     <para><emphasis>逆</emphasis> 接続と呼ばれる方式を利用して、 VNC クライアントに接続を行ないます。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>websocket</literal></term>
    <listitem>
     <para>VNC Websocket 接続専用に追加の TCP 待ち受けポートを用意します。 VNC WebSocket では、 5700 + <replaceable>ディスプレイ</replaceable> の TCP ポートを使用します。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>password</literal></term>
    <listitem>
     <para>クライアントから接続があった場合、パスワードベースの認証を求めます。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>tls</literal></term>
    <listitem>
     <para>VNC サーバと通信を行なう際、クライアント側で TLS を利用するよう求めます。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>x509=<replaceable>証明書ディレクトリ</replaceable></literal></term>
    <listitem>
     <para><literal>tls</literal> を指定した場合にのみ使用されます。 TLS セッションのネゴシエーションに使用する x509 の視覚情報を求めるようにします。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>x509verify=<replaceable>証明書ディレクトリ</replaceable></literal></term>
    <listitem>
     <para><literal>tls</literal> を指定した場合にのみ使用されます。 TLS セッションのネゴシエーションに使用する x509 の視覚情報を求めるようにします。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>sasl</literal></term>
    <listitem>
     <para>クライアントが VNC サーバに接続する際、 SASL による認証を求めるようにします。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>acl</literal></term>
    <listitem>
     <para>x509 クライアント証明書や SASL のパーティを確認する際、アクセス制御リストの機能を有効化します。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>lossy</literal></term>
    <listitem>
     <para>有損失圧縮 (gradient, JPEG など) を使用するようにします。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>non-adaptive</literal></term>
    <listitem>
     <para>適応符号化機能を無効化します。既定では適応符号化機能は有効化されています。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>share=[allow-exclusive|force-shared|ignore]</literal></term>
    <listitem>
     <para>ディスプレイの共有ポリシーを設定します。</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <note>
   <para>ディスプレイオプションについてさらに詳しく知るには、 <emphasis>qemu-doc</emphasis> のマニュアルページをお読みください。</para>
  </note>

  <para>VNC の使用例:</para>

<screen>&prompt.user;qemu-system-x86_64 [...] -vnc :5
# (クライアント側で:)
&prompt.user2;vncviewer &wsII;:5 &amp;</screen>

  <figure>
   <title>&qemu; VNC セッション</title>
   <mediaobject>
    <imageobject role="fo">
     <imagedata fileref="qemu_sles_vnc.png" width="70%" format="PNG"/>
    </imageobject>
    <imageobject role="html">
     <imagedata fileref="qemu_sles_vnc.png" width="70%" format="PNG"/>
    </imageobject>
   </mediaobject>
  </figure>

  <sect2 xml:id="cha-qemu-running-vnc-secure">
   <title>VNC 接続の認証設定</title>
   <para>既定の VNC サーバでは、何も認証を求めません。ここまでの例で設定を行なうと、ネットワーク内の任意のマシンから &qemu; の VNC セッションに接続し、画面を表示して操作ができるようになってしまいます。</para>
   <para>VNC のクライアントとサーバの間で認証を必要とするよう設定したい場合、さまざまなレベルでそれを設定することができます。単純にパスワードのみで保護することができるほか、 x509 証明書認証や SASL 認証を設定したり、これらを組み合わせて使用することもできます。いずれも &qemu; のコマンド 1 つで実現することができます。</para>
   <para><!-- X509 の証明書の生成方法について、詳しくは <xref linkend="app-kvm-certificates"/> をお読みください。また、 --> &vmhost; とクライアントの間での x509 認証の設定方法については、 <xref linkend="sec-libvirt-connect-remote-tls"/> と <xref linkend="sec-libvirt-connect-remote-tls-client"/> をそれぞれお読みください。</para>
   <para>Remmina VNC ビューアでは高度な認証機構に対応しているため、下記の例に従って仮想マシンを起動し、 Remmina で接続することで、 &vmguest; のグラフィカル出力を表示することができます。なお下記の例では、ホスト内の　<filename>/etc/pki/qemu</filename> ディレクトリ内に、 <filename>ca-cert.pem</filename> (証明機関の証明書), <filename>server-cert.pem</filename> (サーバの証明書), <filename>server-key.pem</filename> (サーバの機密鍵) の各ファイルが配置されているものとします。クライアント側では Remmina の起動時に設定を行なうことができることから、任意のディレクトリに証明書を配置して使用することができます。</para>
   <example xml:id="ex-running-vnc-secure-pwd">
    <title>パスワード認証</title>
<screen>qemu-system-x86_64 [...] -vnc :5,password -monitor stdio</screen>
    <para>&vmguest; のグラフィカル出力を VNC ディスプレイ番号 5 (通常は TCP ポート 5905) に出力します。 <literal>password</literal> サブオプションは、シンプルなパスワードベースの認証を有効化するための設定です。既定ではパスワードが何も設定されないため、起動後に &qemu; モニタから <command>change vnc password</command> コマンドでパスワードを設定する必要があります:</para>
<screen>QEMU 2.3.1 monitor - type 'help' for more information
(qemu) change vnc password
Password: ****
</screen>
    <para>ここでは <literal>-monitor stdio</literal> を指定していますが、これは入出力を転送せずに &qemu; モニタを使用することができないことによるものです。</para>
   </example>
   <figure>
    <title>Remmina での認証ダイアログ</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="qemu_vnc_pwd.png" width="70%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="qemu_vnc_pwd.png" width="70%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
   <example xml:id="ex-running-vnc-secure-x509">
    <title>x509 証明書認証</title>
    <para>&qemu; の VNC サーバが TLS 暗号化を行ない、 x509 の証明書を使用するように設定します。サーバはクライアントに対して証明書の提示を求め、証明機関の証明書に適合するかどうかを確認します。この認証方式を使用するには、内部用の証明機関を構築する必要があります。</para>
<screen>qemu-system-x86_64 [...] -vnc :5,tls,x509verify=/etc/pki/qemu</screen>
   </example>
   <example xml:id="ex-running-vnc-secure-pwd-x509">
    <title>x509 証明書とパスワードによる認証</title>
    <para>TLS による暗号化と x509 証明書による認証に加えて、パスワード認証を追加で設定することもできます。これにより、クライアントに対して 2 階層の認証を設定することになります。なお、下記のコマンドを実行したあと、 &qemu; モニタでパスワードを忘れずに設定してください:</para>
<screen>qemu-system-x86_64 [...] -vnc :5,password,tls,x509verify=/etc/pki/qemu \
-monitor stdio</screen>
   </example>
   <example xml:id="ex-running-vnc-secure-sasl">
    <title>SASL 認証</title>
    <para>Simple Authentication and Security Layer (SASL) はインターネットプロトコル向けの認証およびデータセキュリティフレームワークです。 PAM や Kerberos, LDAP など、さまざまな認証機構を組み合わせることができます。 SASL では独自のユーザデータベースを使用する仕組みであるため、 &vmhost; 内にユーザアカウントを作成する必要はありません。</para>
    <para>セキュリティ上の理由から、 SASL 認証を使用する場合は、 TLS 暗号化と x509 証明書認証を併用することをお勧めします:</para>
<screen>qemu-system-x86_64 [...] -vnc :5,tls,x509,sasl -monitor stdio</screen>
   </example>
  </sect2>
 </sect1>
</chapter>
