<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter [
<!ENTITY % entities SYSTEM "entity-decl.ent">
%entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha-libvirt-managing">
 <title>基本的な &vmguest; の管理</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
  </dm:docmanager>
 </info>
 <para>&vmguest; の起動や停止など、ほとんどの管理作業はグラフィカルなアプリケーションである &vmm; とコマンドラインである <command>virsh</command> の両方で実施することができます。ただし、 VNC 経由でのグラフィカルコンソールへのアクセスは、グラフィカルユーザインターフェイスでのみアクセスすることができます。</para>
 <note>
  <title>リモートの &vmhost; 内にある &vmguest; の管理について</title>
  <para>&vmhost; 内で動作させる場合、 &libvirt; のツールである &vmm;, <command>virsh</command> , <command>virt-viewer</command> の各ツールを利用することで、ホスト内で動作する &vmguest; を管理することができます。ただし、リモートの &vmhost; にある &vmguest; を管理することもできます。この場合、 &libvirt; にリモートから接続できるように設定する必要があります。詳しくは <xref linkend="cha-libvirt-connect"/> をお読みください。</para>
  <para>&vmm; でリモートのホストに接続するには、まずは <xref linkend="sec-libvirt-connect-connecting-vmm"/> での説明に従って、接続を設定する必要があります。また、 <command>virsh</command> や <command>virt-viewer</command> でリモートのホストに接続する場合は、 <option>-c</option> オプションで接続 URI を指定する必要があります (たとえば <command>virsh -c qemu+tls://&wsIIIname;/system</command> や <command>virsh -c xen+ssh://</command> など) 。接続 URI の書式は、使用する接続の種類とハイパーバイザによって異なります。詳しくは <xref linkend="sec-libvirt-connect-connecting"/> をお読みください。</para>
  <para>なお、本章内でのコマンド例では、いずれも接続 URI を略しています。</para>
 </note>
 <sect1 xml:id="sec-libvirt-managing-list">
  <title>&vmguest; の一覧表示</title>

  <para>&vmhost; 内で &libvirt; を利用して管理されている全 &vmguest; の一覧表示</para>

  <sect2 xml:id="sec-libvirt-managing-list-vmm">
   <title>&vmm; を利用した &vmguest; の一覧表示</title>
   <para>&vmm; のメインウインドウには、接続している &vmhost; 内にある全ての &vmguest; が一覧表示されています。それぞれの行にはマシンの名前のほか、状態 ( <guimenu>実行中</guimenu> , <guimenu>一時停止中</guimenu> , <guimenu>シャットオフ</guimenu> ) がアイコンとテキストで、そして CPU の使用率を表わすバーも表示されています。</para>
  </sect2>

  <sect2 xml:id="sec-libvirt-managing-list-virsh">
   <title><command>virsh</command> による &vmguest; の一覧表示</title>
   <para>&vmguest; の一覧を表示するには、 <command>virsh</command> <option>list</option> コマンドを使用します:</para>
   <variablelist>
    <varlistentry>
     <term>実行中の全ゲストの表示</term>
     <listitem>
<screen>&prompt.user;virsh list</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>実行中と停止中の両方の全ゲストの表示</term>
     <listitem>
<screen>&prompt.user;virsh list --all</screen>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>詳細およびさらなるオプションについては、 <command>virsh help list</command> または <command>man 1 virsh</command> で表示されるマニュアルページをお読みください。</para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-libvirt-managing-console">
  <title>コンソール経由での &vmguest; へのアクセス</title>

  <para>&vmguest; は VNC 接続でアクセスすることができる (グラフィカルコンソールの場合) ほか、ゲスト側のオペレーティングシステムで対応している必要がありますが、シリアルコンソール経由でアクセスすることもできます。</para>

  <sect2 xml:id="sec-libvirt-managing-console-vnc">
   <title>グラフィカルコンソールの表示</title>
   <para>&vmguest; のグラフィカルコンソールを表示することで、物理マシンに VNC 接続しているのと同じように仮想マシンを扱うことができるようになります。また、接続先の VNC サーバで認証を求めるよう設定している場合、ユーザ名 (必要であれば) とパスワードの入力を求められます。</para>
   <para>VNC コンソール内でマウスのボタンを押すと、マウスカーソルは <quote>捕捉</quote> 状態になり、コンソールの外側には移動できなくなります。捕捉を解除するには、 <keycombo> <keycap function="alt"/> <keycap function="control"/> </keycombo> を押してください。</para>
   <tip>
    <title>マウスカーソルの捕捉回避について</title>
    <para>マウスカーソルがコンソール内に捕捉されず、 &vmguest; のウインドウの内側と外側を自由に行き来できるようにしたい場合は、 &vmguest; にタブレット入力デバイスを追加してください。詳しくは <xref linkend="sec-libvirt-config-input"/> をお読みください。</para>
   </tip>
   <para><keycombo> <keycap function="control"/> <keycap function="alt"/> <keycap function="delete"/> </keycombo> などの特殊なキー入力は、ホスト側で処理されてしまい、 &vmguest; には配送されません。これらの特殊なキー入力を &vmguest; 側に受け渡すには、 VNC ウインドウ内にある <guimenu>キーの送信</guimenu> メニューの中から、送信したいキーを選択してください。なお、 <guimenu>キーの送信</guimenu> メニューは &vmm; と <command>virt-viewer</command> を利用している場合にのみ使用することができます。 &vmm; では、 <xref linkend="tip-libvirt-inst-vmm-sticky"/> で説明している手順で、 <quote>sticky key</quote> を使用することもできます。</para>
   <note>
    <title>対応する VNC ビューアについて</title>
    <para>仕様上は VNC に対応していれば、全てのビューアから &vmguest; に接続することができます。ただし、ゲストへのアクセスに際して SASL 認証を使用している場合や TLS/SSL 接続を設定しているような場合、利用できる VNC ビューアは限られてきます。 <command>tightvnc</command> や <command>tigervnc</command> などの一般的な VNC ビューアには、 SASL 認証の機能も、 TLS/SSL 接続への対応も用意されていません。 &vmm; と <command>virt-viewer</command> の組み合わせ以外で唯一対応しているものは、 Remmina (詳しくは<xref linkend="vnc-remmina"/> をお読みください) のみとなります。</para>
   </note>
   <sect3 xml:id="sec-libvirt-managing-console-vnc-vmm">
    <title>&vmm; を利用したグラフィカルコンソールの表示</title>
    <procedure>
     <step>
      <para>&vmm; 内にある &vmguest; の項目を選択して、マウスの右ボタンを押します。</para>
     </step>
     <step>
      <para>ポップアップメニューから <guimenu>開く</guimenu> を選択します。</para>
     </step>
    </procedure>
   </sect3>
   <sect3 xml:id="sec-libvirt-managing-vnc-viewer">
    <title><command>virt-viewer</command> を利用したグラフィカルコンソールの表示</title>
    <para><command>virt-viewer</command> はシンプルな VNC ビューアで、 &vmguest; のコンソール用にいくつかの機能が追加されています。たとえば <quote>wait</quote> モードを指定して起動すると、接続を行なう前に &vmguest; が開始されるのを待つようになります。また、 &vmguest; が再起動された場合、自動的に再接続する機能も用意されています。</para>
    <para><command>virt-viewer</command> では、 &vmguest; の指定を名前のほか、 ID や UUID で指定することができます。 <command>virsh</command> <option>list --all</option> を実行すると、これらのデータを表示することができます。</para>
    <para>実行中や一時停止中のゲストに接続する場合は、 ID や UUID 、もしくは名前で選択することができます。シャットオフされている &vmguest; の場合は、 ID が付与されていませんので、 UUID や名前で選択してください。</para>
    <variablelist>
     <varlistentry>
      <term>ID <literal>8</literal> のゲストに接続:</term>
      <listitem>
<screen>&prompt.user;virt-viewer 8</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>sles12</literal> という名前の停止中のゲストに接続; ゲストの起動が行なわれるまで待機する設定:</term>
      <listitem>
<screen>&prompt.user;virt-viewer --wait sles12</screen>
       <para><option>--wait</option> オプションを指定すると、 &vmguest; が実行中でない場合、接続が保留状態になります。ゲストが起動すると、ビューアが表示されるようになります。</para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>詳しくは <command>virt-viewer</command> <option>--help</option> もしくは <command>man 1 virt-viewer</command> をお読みください。</para>
    <note>
     <title>SSH 経由のリモート接続でのパスワード入力について</title>
     <para>SSH 経由で接続しているホストに対して <command>virt-viewer</command> で接続を開く場合、 SSH のパスワードは 2 回入力する必要があります。最初の 1 回は &libvirt; での認証に、もう 1 回は VNC サーバとの認証になります。なお、 2 回目のパスワードは、 virt-viewer の開始時にコマンドラインで指定する必要があります。</para>
    </note>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-libvirt-managing-console-serial">
   <title>シリアルコンソールへの接続</title>
   <para>仮想マシンのグラフィカルコンソールに接続するには、 &vmguest; にアクセスするクライアント側でも、グラフィカル環境を用意する必要があります。グラフィカルな環境を必要としない場合や、使用したくない場合は、 <command>virsh</command> でシリアルコンソール経由でシェルにアクセスすることができます。 &vmguest; のシリアルコンソールにアクセスするには、下記のようなコマンドを入力して実行します:</para>
<screen>&prompt.user;virsh console sles12</screen>
   <para><command>virsh console</command> には 2 種類のオプションフラグが存在しています。 <option>--safe</option> を指定すると、コンソールに対して排他アクセスを行なおうとします。 <option>--force</option> を指定すると、接続を行なう前に既存の接続を全て切断します。いずれの機能とも、ゲスト側のオペレーティングシステムでの対応が必要となります。</para>
   <para>&vmguest; に対してシリアルコンソール経由でアクセスするには、ゲスト側のオペレーティングシステムがシリアルコンソールに対応し、適切に設定されている必要があります。詳しくはゲスト側のオペレーティングシステムのマニュアルをお読みください。</para>
   <tip>
    <title>&sle; や &opensuse; のゲストに対するシリアルコンソールの有効化について</title>
    <para>&sle; や &opensuse; の場合、シリアルコンソールへのアクセスは既定で無効化されています。有効化したい場合は、下記のようにします:</para>
    <variablelist>
     <varlistentry>
      <term>&slsa; 12 / &opensuse;</term>
      <listitem>
       <para>&yast; ブートローダモジュールを起動して、 <guimenu>カーネルのパラメータ</guimenu> タブに切り替えます。あとは <guimenu>オプションのカーネルコマンドラインパラメータ</guimenu> の欄に、 <literal>console=ttyS0</literal> を追加します。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>&slsa; 11</term>
      <listitem>
       <para>&yast; ブートローダモジュールを起動して、シリアルコンソールを有効化したい起動項目を選択します。選択を行なったら <guimenu>編集</guimenu> を押し、 <guimenu>オプションのカーネルコマンドラインパラメータ</guimenu> の欄に <literal>console=ttyS0</literal> を追加します。これに加えて、 <filename>/etc/inittab</filename> ファイルを編集し、下記の行のコメント文字を外します:</para>
<screen>#S0:12345:respawn:/sbin/agetty -L 9600 ttyS0 vt102</screen>
      </listitem>
     </varlistentry>
    </variablelist>
   </tip>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-libvirt-managing-status">
  <title>&vmguest; の状態変更 (開始／停止／一時停止)</title>

  <para>&vmguest; の開始や停止、一時停止は、 &vmm; もしくは <command>virsh</command> で行なうことができます。また、 &vmhost; の起動時に &vmguest; を自動的に開始するように設定することもできます。</para>

  <para>なお、 &vmguest; をシャットダウンする際は、正常な手順でシャットダウンを行なうか、もしくは強制的にシャットダウンを行なうかを選択することができます。強制的なシャットダウンはコンピュータの電源を抜く行為と同じであり、正常な手順でシャットダウンができない場合にのみ実施すべきものです。また、強制的なシャットダウンを行なうと、 &vmguest; 内のファイルシステムを破壊してしまうことがあるほか、データを失ってしまうこともあります。</para>

  <tip>
   <title>正常なシャットダウンについて</title>
   <para>正常にシャットダウンを行なうには、 &vmguest; 側が <xref linkend="gloss-vt-acpi"/> に対応するよう設定されていなければなりません。 &vmm; でゲストを作成している場合、 &vmguest; の ACPI 対応は自動的に設定されます。</para>
   <para>ゲスト側のオペレーティングシステムにも依存しますが、 ACPI が利用できれば正常にシャットダウンできるというわけではありません。本番環境で使用する場合は、あらかじめ正常にシャットダウンできること、および再起動できることを確認してからご使用ください。なお、 &opensuse; や &sled; などでは、シャットダウンや再起動を行なうのに &pk; による認可を必要とするように設定することもできます。このポリシーが全ての &vmguest; で無効化されていることを確認してください。</para>
   <para>Windows XP や Windows Server 2003 のゲストインストール時に ACPI を有効化した場合、 &vmguest; の設定のみを変更しただけでは設定不足となります。詳しくは下記をお読みください:</para>
   <itemizedlist>
    <listitem>
     <para><!-- NOTE: not available anymore?? --><link xlink:href="https://support.microsoft.com/en-us/kb/314088"/></para>
    </listitem>
    <listitem>
     <para><!-- NOTE: not available anymore?? --><link xlink:href="https://support.microsoft.com/en-us/kb/309283"/></para>
    </listitem>
   </itemizedlist>
   <para>なお、 &vmguest; 側の設定にかかわらず、ゲスト側のオペレーティングシステム内からシャットダウンを行なうことで、正常なシャットダウンを実現することができます。</para>
  </tip>

  <sect2 xml:id="sec-libvirt-managing-status-vmm">
   <title>&vmm; を利用した &vmguest; の状態変更</title>
   <para>&vmguest; の状態変更は &vmm; のメインウインドウのほか、 VNC ウインドウからも行なうことができます。</para>
   <procedure>
    <title>&vmm; ウインドウ内からの状態変更</title>
    <step>
     <para>&vmguest; の項目を選択して、マウスの右ボタンを押します。</para>
    </step>
    <step>
     <para>表示されたポップアップメニューから、 <guimenu>実行</guimenu> , <guimenu>一時停止</guimenu> のいずれか、もしくは <guimenu>シャットダウン</guimenu> 内にある選択肢のいずれかを選択します。</para>
    </step>
   </procedure>
   <procedure>
    <title>VNC ウインドウからの状態変更</title>
    <step>
     <para><xref linkend="sec-libvirt-managing-console-vnc-vmm"/> に示されている手順に従って、 VNC ウインドウを表示します。</para>
    </step>
    <step>
     <para>ツールバー内、もしくは <guimenu>仮想マシン</guimenu> メニュー内にある <guimenu>実行</guimenu> , <guimenu>一時停止</guimenu> のいずれか、もしくは <guimenu>シャットダウン</guimenu> 内にある選択肢のいずれかを選択します。</para>
    </step>
   </procedure>
   <sect3 xml:id="sec-libvirt-managing-status-vmm-autostart">
    <title>&vmguest; の自動起動</title>
    <para>&vmhost; の起動時にゲストを自動的に開始するように設定することができます。この機能は既定では有効化されておらず、それぞれの &vmguest; に対して個別に設定する必要があります。全ての仮想マシンを一括で有効化することはできません。</para>
    <procedure>
     <step>
      <para>&vmm; で設定したい &vmguest; の項目を選んでダブルクリックし、コンソールを表示します。</para>
     </step>
     <step>
      <para><menuchoice> <guimenu>表示</guimenu> <guimenu>詳細</guimenu></menuchoice> を選んで、 &vmguest; の設定ウインドウを表示します。</para>
     </step>
     <step>
      <para><guimenu>ブートオプション</guimenu> を選択し、表示された <guimenu>ホスト起動時に仮想マシンを起動する</guimenu> を選択します。</para>
     </step>
     <step>
      <para><guimenu>適用</guimenu> を押して新しい設定を保存します。</para>
     </step>
    </procedure>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-libvirt-managing-status-virsh">
   <title><command>virsh</command> を利用した &vmguest; の状態変更</title>
   <para>下記の例では、 <quote>sles12</quote> という名前の &vmguest; の状態を変更しています。</para>
   <variablelist>
    <varlistentry>
     <term>開始</term>
     <listitem>
<screen>&prompt.user;virsh start sles12</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>一時停止</term>
     <listitem>
<screen>&prompt.user;virsh suspend sles12</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>復元 (一時停止からの再開)</term>
     <listitem>
<screen>&prompt.user;virsh resume sles12</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>再起動</term>
     <listitem>
<screen>&prompt.user;virsh reboot sles12</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>正常なシャットダウン</term>
     <listitem>
<screen>&prompt.user;virsh shutdown sles12</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>強制シャットダウン</term>
     <listitem>
<screen>&prompt.user;virsh destroy sles12</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>自動開始の有効化</term>
     <listitem>
<screen>&prompt.user;virsh autostart sles12</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>自動開始の無効化</term>
     <listitem>
<screen>&prompt.user;virsh autostart --disable sles12</screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-libvirt-manage-save">
  <title>&vmguest; の状態保存と状態復元</title>

  <para>&vmguest; の状態保存を行なうことで、ゲストのメモリの内容を保存することができます。この操作はコンピュータの <emphasis>ハイバネーション</emphasis> (休止状態) に似た操作です。状態保存された &vmguest; の復元を行なうことで、その時点の状態に戻すこともできます。</para>

  <para>状態保存を行なうと、 &vmguest; は一時停止状態になり、その時点でのメモリ内容をディスクに保存したあと、 &vmguest; が停止されます。ただし、この操作では &vmguest; のディスクのコピーが作成されるわけではありません。また、仮想マシンの状態保存にかかる時間は、割り当てているメモリ量に依存して決まります。状態保存を行なうと、 &vmguest; に割り当てていたメモリが &vmhost; 側に戻され、利用できるようになります。</para>

  <para>状態復元の操作は、以前に状態保存しておいた &vmguest; のメモリ状態を読み込んで、実行中の状態に戻す操作です。ここではゲストの起動処理は発生せず、状態を保存した時点の状態に戻します。この操作は、ハイバネーションからの復帰に似ています。</para>

  <para>なお、 &vmguest; の状態は専用のファイルに保存されます。そのため、保存先のディスクには十分な空き容量があることを確認してください。下記のコマンドをゲスト内で実行すると、おおよそ必要な容量を計算することができます (メガバイト単位で表示されます):</para>

<screen>&prompt.user;free -mh | awk '/^Mem:/ {print $3}'</screen>

  <warning xml:id="adm-vm-restore">
   <title>保存後の復元作業について</title>
   <para>&vmguest; の状態保存を行なった後は、必ず状態復元を行なうものとし、通常の起動や開始は行なってはなりません。通常の起動や開始を行なってしまうと、マシンの仮想ディスクが途中の状態のまま起動することになってしまうほか、状態保存のファイルとも整合性が取れなくなってしまうため、状態復元を行なうと致命的なエラーが発生することになります。</para>
   <para>状態保存された &vmguest; を正しく使用し続けるには、状態復元を忘れずに実施してください。また、 <command>virsh</command> で状態保存を行なった場合は、 &vmm; で状態を復元することができません。この場合は <command>virsh</command> で復元を行なってください。</para>
  </warning>

  <important>
   <title>&vmguest; がディスクタイプ <literal>raw</literal> , <literal>qcow2</literal> のいずれかで無いと実施できない問題について</title>
   <para>&vmguest; の状態保存や状態復元を行なうには、 &vmguest; が <literal>raw</literal> ( <filename>.img</filename> ) もしくは <emphasis>qcow2</emphasis> の種類の仮想ディスクを使用している必要があります。</para>
  </important>

  <sect2 xml:id="sec-libvirt-manage-save-vmm">
   <title>&vmm; を利用した状態保存と状態復元</title>
   <procedure>
    <title>&vmguest; の状態保存</title>
    <step>
     <para>&vmguest; の VNC 接続ウインドウを表示します。また、ゲストが動作中であることを確認します。</para>
    </step>
    <step>
     <para><menuchoice> <guimenu>仮想マシン</guimenu> <guimenu>シャットダウン</guimenu> <guimenu>保存</guimenu> </menuchoice> を選択します。</para>
    </step>
   </procedure>
   <procedure>
    <title>&vmguest; の状態復元</title>
    <step>
     <para>&vmguest; の VNC 接続ウインドウを表示します。また、ゲストが動作中でないことを確認します。</para>
    </step>
    <step>
     <para><menuchoice> <guimenu>仮想マシン</guimenu> <guimenu>復元</guimenu> </menuchoice> を選択します。</para>
     <para>&vmguest; を &vmm; から状態保存していると、ゲストの <guimenu>実行</guimenu> オプションが表示されなくなります。ただし、 <xref linkend="adm-vm-restore"/> で説明しているとおり、 <command>virsh</command> で状態保存を行なっている場合に注意してください。</para>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec-libvirt-manage-save-virsh">
   <title><command>virsh</command> による状態保存と状態復元</title>
   <para>&vmguest; の状態保存を行なうには、 <command>virsh</command> <option>save</option> に続いて <!-- NOTE: VM name/ID is also requires --> 仮想マシン名 (もしくは ID) と保存先のファイルを指定します。</para>
   <variablelist>
    <varlistentry>
     <term><literal>opensuse13</literal> という名前のゲストを状態保存</term>
     <listitem>
<screen>&prompt.user;virsh save opensuse13 /virtual/saves/opensuse13.vmsav</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>ID が <literal>37</literal> のゲストを状態保存</term>
     <listitem>
<screen>&prompt.user;virsh save 37 /virtual/saves/opensuse13.vmsave</screen>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>&vmguest; の状態を復元するには、 <command>virsh</command> <option>restore</option> コマンドを使用します:</para>
<screen>&prompt.user;virsh restore /virtual/saves/opensuse13.vmsave</screen>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-libvirt-managing-snapshots">
  <title>スナップショットの作成と管理</title>

  <para>&vmguest; のスナップショット機能は、 CPU やメモリ、デバイスの状態のほか、書き込み可能な全てのディスクの内容を含む、完全な仮想マシンのスナップショットです。仮想マシンのスナップショット機能を使用するには、接続されている全てのハードディスクが qcow2 形式である必要があるほか、少なくとも 1 つ以上のディスクが書き込み可能である必要があります。</para>

  <para>スナップショットを使用することで、その時点でのマシンの状態を自由に復元できるようになります。これは特に、設定を誤ってしまった場合の巻き戻しや、多数のパッケージをインストールしてしまった場合の取り消しに便利な仕組みです。また、 &vmguest; がシャットオフ中に採取されたスナップショットを適用した場合は、適用後に起動を行なう必要があります。また、スナップショットの適用を行なうと、現時点での状態が破棄されます。</para>

  <note>
   <para>スナップショット機能は &kvm; の &vmhost; にのみ対応しています。</para>
  </note>

  <sect2 xml:id="libvirt-snapshots-terminology">
   <title>用語</title>
   <para>スナップショットの種類を説明するにあたって、下記のいくつかの用語を使用しています:</para>
   <variablelist>
    <varlistentry>
     <term>内部スナップショット</term>
     <listitem>
      <para>スナップショットを元の &vmguest; の qcow2 ファイル内に保存する方式です。このファイルには、スナップショットで保存された情報と、スナップショットを採取してからの変更点の両方が記録されます。内部スナップショットの利点としては、必要な全ての情報が 1 つのファイル内に保存されていて、マシン間で複製や移動を行なう手間が省けるという点にあります。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>外部スナップショット</term>
     <listitem>
      <para>外部スナップショットでは、元の qcow2 ファイルを保存して読み込み専用とし、それとは別に新しく qcow2 ファイルを作成してそこに変更点を記録します。元のファイルは 'バッキング' もしくは 'ベース' ファイルと呼ばれ、新しく作成したほうのファイルは 'オーバーレイ' もしくは '派生' ファイルと呼ばれます。外部スナップショットは、 &vmguest; のバックアップを作成する際に便利です。ただし、外部スナップショットは &vmm; ではサポートしておらず、 <command>virsh</command> でも直接削除することができません。 &qemu; での外部スナップショットについて、詳しくは <xref linkend="cha-qemu-guest-inst-qemu-img-effect"/> をお読みください。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>動作中スナップショット</term>
     <listitem>
      <para>&vmguest; の動作中に採取するスナップショットを意味します。内部スナップショット形式での動作中スナップショットの場合、デバイスとメモリ、ディスクの各状態を保存することができます。 <command>virsh</command> を利用した外部スナップショット形式での動作中スナップショットの場合は、メモリとディスクのうちいずれか、もしくはその両方の状態を保存することができます。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>オフラインスナップショット</term>
     <listitem>
      <para>&vmguest; がシャットオフ (シャットダウン) されている間に採取するスナップショットを意味します。ゲストが動作していない状態で採取することから、メモリも使用されていない状態になりますので、矛盾を一切発生させずに採取することができるようになります。</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec-libvirt-managing-snapshots-vmm">
   <title>&vmm; を利用したスナップショットの作成と管理</title>
   <important>
    <title>内部スナップショットのみのサポートについて</title>
    <para>&vmm; では動作中スナップショットであってもオフラインスナップショットであっても、内部スナップショットにしか対応していません。</para>
   </important>
   <para>&vmm; でスナップショットの管理ビューを表示するには、まず <xref linkend="sec-libvirt-managing-console-vnc-vmm"/> の手順で VNC のウインドウを表示します。その後、 <menuchoice> <guimenu>表示</guimenu> <guimenu>スナップショット</guimenu> </menuchoice> を選択するか、ツールバーから <guimenu>仮想マシンのスナップショットを管理</guimenu> を選択します。</para>
   <informalfigure>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="virt_vmm_snapshots_list.png" width="75%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="virt_vmm_snapshots_list.png" width="75%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </informalfigure>
   <para>選択した &vmguest; に対する既存のスナップショットの一覧が、ウインドウの左側に表示されます。現時点での最新のスナップショットには、緑色のチェックマークが付けられます。ウインドウの右側には、左側で選択しているスナップショットの詳細が表示されます。詳細にはスナップショットのタイトルとタイムスタンプのほか、採取時点での &vmguest; の状態や説明などが表示されます。また、動作中スナップショットである場合には、その時点でのスクリーンショットも表示されます。なお、 <guimenu>詳細</guimenu> の内容については、この表示から変更することができます。それ以外のスナップショットデータについては、変更できません。</para>
   <sect3 xml:id="sec-libvirt-managing-snapshots-vmm-add">
    <title>スナップショットの作成</title>
    <para>&vmguest; に対して新しいスナップショットを採取するには、下記の手順を実施します:</para>
    <procedure>
     <step>
      <para>オフラインスナップショットを採取する場合は、まず &vmguest; をシャットダウンします。</para>
     </step>
     <step>
      <para>VNC ウインドウ内の左下にある <guimenu>新しいスナップショットを作成</guimenu> ボタンを押します。</para>
      <para><guimenu>スナップショットを作成</guimenu> ウインドウが表示されます。</para>
     </step>
     <step>
      <para><guimenu>名前</guimenu> 欄にスナップショットの名前を入力します。必要であれば、 <guimenu>詳細</guimenu> 欄に詳細を記述します。名前は作成後に変更することはできません。後からスナップショットの状況がわかるような名前を入力してください。</para>
     </step>
     <step>
      <para><guimenu>完了</guimenu> を押すと採取が行なわれます。</para>
     </step>
    </procedure>
   </sect3>
   <sect3 xml:id="sec-libvirt-managing-snapshots-vmm-delete">
    <title>スナップショットの削除</title>
    <para>選択した &vmguest; のスナップショットを削除するには、下記の手順を実施します:</para>
    <procedure>
     <step>
      <para>VNC ウインドウ内の左下にある <guimenu>選択したスナップショットを削除</guimenu> ボタンを押します。</para>
     </step>
     <step>
      <para>削除の確認メッセージが表示されますので、 <guimenu>はい</guimenu> を押します。</para>
     </step>
    </procedure>
   </sect3>
   <sect3 xml:id="sec-libvirt-managing-snapshots-vmm-start">
    <title>スナップショットの開始</title>
    <para>選択したスナップショットで開始するには、下記の手順を実施します:</para>
    <procedure>
     <step>
      <para>VNC ウインドウ内の左下にある <guimenu>選択したスナップショットを実行</guimenu> ボタンを押します。</para>
     </step>
     <step>
      <para>開始の確認メッセージが表示されますので、 <guimenu>はい</guimenu> を押します。</para>
     </step>
    </procedure>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-libvirt-managing-snapshots-virsh">
   <title><command>virsh</command> を利用したスナップショットの作成と管理</title>
   <para>特定の <!-- NOTE: "domain" is confusing in this situation, &vmguest; is better --> &vmguest; (下記では <replaceable>admin_server</replaceable>) に対するスナップショットの全一覧を表示するには、 <literal>snapshot-list</literal> コマンドを使用します:</para>
<screen><!-- NOTE: "sle-ha-node1" should be "admin_server" -->&prompt.user;virsh snapshot-list --domain admin_server
 名前                              作成時間                  状態
--------------------------------------------------------------------
 sleha_12_sp2_b2_two_node_cluster  2016-06-06 15:04:31 +0200 shutoff
 sleha_12_sp2_b3_two_node_cluster  2016-07-04 14:01:41 +0200 shutoff
 sleha_12_sp2_b4_two_node_cluster  2016-07-14 10:44:51 +0200 shutoff
 sleha_12_sp2_rc3_two_node_cluster 2016-10-10 09:40:12 +0200 shutoff
 sleha_12_sp2_gmc_two_node_cluster 2016-10-24 17:00:14 +0200 shutoff
 sleha_12_sp3_gm_two_node_cluster  2017-08-02 12:19:37 +0200 shutoff
 sleha_12_sp3_rc1_two_node_cluster 2017-06-13 13:34:19 +0200 shutoff
 sleha_12_sp3_rc2_two_node_cluster 2017-06-30 11:51:24 +0200 shutoff
 sleha_15_b6_two_node_cluster      2018-02-07 15:08:09 +0100 shutoff
 sleha_15_rc1_one-node             2018-03-09 16:32:38 +0100 shutoff</screen>
   <para>現時点での最新のスナップショットを表示するには、 <literal>snapshot-current</literal> コマンドを使用します:</para>
<screen>&prompt.user;virsh snapshot-current --domain admin_server
Basic installation incl. SMT for CLOUD4
</screen>
   <para>特定のスナップショットに関する詳細を表示するには、 <literal>snapshot-info</literal> コマンドを使用します:</para>
<screen>&prompt.user;virsh snapshot-info --domain admin_server \
   -name  "Basic installation incl. SMT for CLOUD4"
名前:           Basic installation incl. SMT for CLOUD4
ドメイン:       admin_server
カレント:       はい (yes)
状態:           shutoff
場所:           内部
親:             Basic installation incl. SMT for CLOUD3-HA
子:             0
子孫:           0
メタデータ:     はい (yes)
</screen>
   <sect3 xml:id="sec-libvirt-managing-snapshots-virsh-add">
    <title>内部スナップショットの作成</title>
    <para>&vmguest; に対して内部スナップショットを採取するには、それが動作中スナップショットであってもオフラインスナップショットであっても、 <literal>snapshot-create-as</literal> コマンドを使用します:</para>
<screen>&prompt.user;virsh snapshot-create-as --domain admin_server<co xml:id="virsh-snapshot-add-domain"/> --name "Snapshot 1"<co xml:id="virsh-snapshot-add-name"/> \
--description "First snapshot"<co xml:id="virsh-snapshot-add-description"/></screen>
    <calloutlist>
     <callout arearefs="virsh-snapshot-add-domain">
      <para><!-- NOTE: "domain" is confusing in this situation, &vmguest; is better --> &vmguest; の名前を指定します。必ず指定します。</para>
     </callout>
     <callout arearefs="virsh-snapshot-add-name">
      <para>スナップショットの名前を指定します。後からスナップショットの状況がわかるような名前を入力してください。</para>
     </callout>
     <callout arearefs="virsh-snapshot-add-description">
      <para>スナップショットの説明を指定します。指定しなくてもかまいません。</para>
     </callout>
    </calloutlist>
   </sect3>
   <sect3 xml:id="sec-libvirt-managing-snapshots-virsh-add-ext">
    <title>外部スナップショットの作成</title>
    <para><command>virsh</command> を使用することで、ゲストのメモリ状態またはディスク状態、もしくはその両方を外部スナップショットとして採取することができます。</para>
    <para>ゲストのディスク状態の外部スナップショットを採取するには、それが動作中であってもオフラインであっても、 <option>--disk-only</option> オプションを指定します:</para>
<screen>&prompt.user;virsh snapshot-create-as --domain admin_server --name \
 "Offline external snapshot" --disk-only</screen>
    <para><option>--diskspec</option> オプションを指定することで、外部スナップショットのファイル作成方法を制御することができます:</para>
<screen>&prompt.user;virsh snapshot-create-as --domain admin_server --name \
 "Offline external snapshot" \
 --disk-only --diskspec vda,snapshot=external,file=/path/to/snapshot_file</screen>
    <para>ゲストのメモリ状態の外部スナップショットを採取するには、 <option>--live</option> および <option>--memspec</option> オプションを指定します:</para>
<screen>&prompt.user;virsh snapshot-create-as --domain admin_server --name \
 "Offline external snapshot" --live \
 --memspec snapshot=external,file=/path/to/snapshot_file</screen>
    <para>ゲストのディスクとメモリ状態の両方を外部スナップショットとして採取するには、 <option>--live</option> , <option>--diskspec</option> , <option>--memspec</option> の各オプションを組み合わせて指定します:</para>
<screen>&prompt.user;virsh snapshot-create-as --domain admin_server --name \
 "Offline external snapshot" --live \
 --memspec snapshot=external,file=/path/to/snapshot_file
 --diskspec vda,snapshot=external,file=/path/to/snapshot_file</screen>
    <para>詳しくは <command>man 1 virsh</command> 内の <citetitle>SNAPSHOT COMMANDS</citetitle> セクション (英語) をお読みください。</para>
   </sect3>
   <sect3 xml:id="sec-libvirt-managing-snapshots-virsh-delete">
    <title>スナップショットの削除</title>
    <para>外部スナップショットは <command>virsh</command> では削除できません。 &vmguest; の内部スナップショットを削除し、占有していたディスク領域を解放するには、 <literal>snapshot-delete</literal> コマンドを使用します:</para>
<screen>&prompt.user;virsh snapshot-delete --domain admin_server --snapshotname "Snapshot 2"</screen>
   </sect3>
   <sect3 xml:id="sec-libvirt-managing-snapshots-virsh-start">
    <title>スナップショットの開始</title>
    <para>指定したスナップショットで開始するには、 <literal>snapshot-revert</literal> コマンドを使用します:</para>
<screen>&prompt.user;virsh snapshot-revert --domain admin_server --snapshotname "Snapshot 1"</screen>
    <para>現在のスナップショット (&vmguest; を最後にシャットダウンした状態) を開始する場合は、スナップショットの名前ではなく、 <option>--current</option> オプションを指定すれば十分です:</para>
<screen>&prompt.user;virsh snapshot-revert --domain admin_server --current</screen>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-libvirt-managing-delete">
  <title>&vmguest; の削除</title>

  <para>既定では、 <command>virsh</command> による &vmguest; の削除では、 XML 形式の設定ファイルのみを削除します。接続されているストレージは既定では削除されませんので、他の &vmguest; に接続しなおして使用することもできます。 &vmm; を使用する場合は、同時にストレージファイルも削除することができます。これにより、ゲストを完全に削除することができます。</para>

  <sect2 xml:id="sec-libvirt-managing-delete-vmm">
   <title>&vmm; を利用した &vmguest; の削除</title>
   <procedure>
    <step>
     <para>&vmm; 内にある &vmguest; の項目を選択して、マウスの右ボタンを押します。</para>
    </step>
    <step>
     <para>表示されたコンテキストメニューから、 <guimenu>削除</guimenu> を選択します。</para>
    </step>
    <step>
     <para>確認メッセージが表示されますので、再度 <guimenu>削除</guimenu> ボタンを押します。これにより、 &vmguest; を恒久的に削除することができます。また、削除は取り消すことができません。</para>
     <para>仮想ディスクについても同時に削除したい場合は、 <guimenu>関連するストレージファイルを削除する</guimenu> を選択します。こちらについても削除を取り消すことはできません。</para>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec-libvirt-managing-delete-virsh">
   <title><command>virsh</command> を利用した &vmguest; の削除</title>
   <para>&vmguest; を削除するには、まずシャットダウンしておく必要があります。動作中の場合、ゲストを削除することができません。シャットダウンに関する情報については、 <xref linkend="sec-libvirt-managing-status"/> をお読みください。</para>
   <para><command>virsh</command> を使用して &vmguest; を削除するには、 <command>virsh</command> <option>undefine</option> <replaceable>VM_名</replaceable> のように入力して実行します。</para>
<screen>&prompt.user;virsh undefine sles12</screen>
   <para>接続されているストレージファイルを自動的に削除するオプションは用意されていません。 libvirt でストレージファイルを管理している場合は、 <xref linkend="sec-libvirt-storage-virsh-del-volumes"/> の手順に従って削除を行なってください。</para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-libvirt-admin-migrate">
  <title>&vmguest; の移行 (マイグレーション)</title>

  <para>仮想化を利用する際の大きな利点のうちの 1 つとして、 &vmguest; の可搬性があげられます。 &vmhost; をメンテナンスなどの理由でダウンさせる必要がある場合や、ホストの負荷が大きすぎるような場合や、容易にゲストを他の &vmhost; に移行させることができます。なお、 &kvm; と &xen; の両方が <quote>ライブ</quote> マイグレーションに対応し、 &vmguest; を動作させ続けながら移行を行なうことができます。</para>

  <sect2 xml:id="libvirt-admin-live-migration-requirements">
   <title>移行要件</title>
   <para>&vmguest; を他の &vmhost; に移行させる場合、下記の要件を満たす必要があります:</para>
   <itemizedlist>
    <listitem>
     <para>移行元と移行先のシステムが、同じアーキテクチャであることが推奨されます。</para>
    </listitem>
    <listitem>
     <para>移行元と移行先の両方のマシンから、同じストレージデバイスにアクセスできなければなりません (たとえば NFS や iSCSI などを使用します) 。また、両方のマシンでストレージプールを設定しなければなりません。詳しくは <xref linkend="cha-libvirt-storage"/> をお読みください。</para>
     <para>移行時に CD-ROM やフロッピィディスクのメディアが挿入されている場合は、それらも両方のマシンからアクセスできなければなりません。ただし、この場合は移行時に前もって <xref linkend="sec-libvirt-config-cdrom-media-change"/> の手順に従い、メディアを取り出しておくことができます。</para>
    </listitem>
    <listitem>
     <para>&libvirtd; を両方の &vmhost; で動作させる必要があるほか、移行元と移行先の間で &libvirt; の接続ができる環境でなければなりません (双方向での接続が必要です) 。詳しくは <xref linkend="sec-libvirt-connect-remote"/> をお読みください。</para>
    </listitem>
    <listitem>
     <para>移行先のホストでファイアウオール機能が動作している場合、移行を許可するためにポートを開いておく必要があります。移行処理時にポートを指定しなかった場合、 &libvirt; は 49152 から 49215 までの範囲でポートを選択します。 <emphasis>移行先のホスト</emphasis> でファイアウオールを設定し、この範囲のポートを開いておくか、移行時に明示的に指定するポートを開いておいてください。</para>
    </listitem>
    <listitem>
     <para><!-- NOTE: "Host and target" means "source/dest VM host"? -->移行元と移行先のマシンがネットワーク内の同じサブネットに属している必要があります。そうでないと、移行後にネットワークが正しく動作しなくなってしまいます。</para>
    </listitem>
    <listitem>
     <para>移行に参加する全ての &vmhost; の qemu ユーザの UID が同じ値でなければならないほか、 kvm, qemu, libvirt の各グループについて GID が同じ値でなければなりません。</para>
    </listitem>
    <listitem>
     <para>移行先のホストで、同じ名前の実行中もしくは一時停止中の &vmguest; が存在していてはなりません。また、同じ名前のシャットダウン済みの &vmguest; が存在した場合、設定は上書きされます。</para>
    </listitem>
    <listitem>
     <para><emphasis>ホスト CPU</emphasis> を除く全ての CPU モデルが &vmguest; の移行に対応しています。</para>
    </listitem>
    <listitem>
     <para>ディスクデバイスの種類が <xref linkend="gloss-vt-acronym-sata"/> である場合、移行を行なうことができません。</para>
    </listitem>
    <listitem>
     <para>ファイルシステムのパススルー機能を使用している場合、移行を行なうことができません。</para>
    </listitem>
    <listitem>
     <para>&vmhost; と &vmguest; の両方で、適切な時刻維持を設定する必要があります。詳しくは <xref linkend="sec-kvm-managing-clock"/> をお読みください。</para>
    </listitem>
    <listitem>
     <para>ホストからゲストに対して、物理的なデバイスを受け渡していてはなりません。具体的には、 PCI パススルーや <xref linkend="vt-io-sriov"/> を利用している場合、移行を行なうことができません。ライブマイグレーションに対応させる必要がある場合は、ソフトウエアによる仮想化 (準仮想化もしくは完全仮想化) をお使いください。</para>
    </listitem>
    <listitem>
     <para>キャッシュモードの設定は、移行処理に際して重要な設定となります。詳しくは <xref linkend="sec-cache-mode-live-migration"/> をお読みください。</para>
    </listitem>
    <listitem os="sles;sled">
     <para>&vmguest; を一方のホストから他方のホストにライブマイグレーションで移行する場合、移行元と移行先のオペレーティングシステムがそれぞれ下記のものであれば、異なっている場合でも完全サポートの対象となります:</para>
     <itemizedlist>
      <listitem>
<!-- fate#324058 -->
       <para>&slsa; 12 SP2 から &slsa; 15 に</para>
      </listitem>
      <listitem>
       <para>&slsa; 12 SP3 から &slsa; 15 に</para>
      </listitem>
      <listitem>
       <para>&slsa; 12 SP4 から &slsa; 15 (リリース後)</para>
      </listitem>
     </itemizedlist>
<!-- fate#320425 -->
     <para os="sles;sled">バージョンを戻す方向での移行 (たとえば &slsa; 12 SP1 や SP2 などから 12 へ、もしくは &slsa; SP2 から SP1 へ) は、サポート対象外となります。</para>
    </listitem>
    <listitem>
     <para>両方のホストでイメージディレクトリが同じパスである必要があります。</para>
    </listitem>
    <listitem>
     <para>全てのホストで同じレベルのマイクロコードを適用している必要があります (特に spectre マイクロコードアップデート) 。これは全てのホストで最新の &productname; の更新を適用することで、容易に解決することができます。</para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 xml:id="sec-libvirt-admin-migrate-virtmanager">
   <title>&vmm; を利用した移行</title>
   <para>&vmm; を利用して &vmguest; の移行を行なう場合、どのマシンからそれを実施してもかまいません。移行元のマシンで &vmm; を動作させて移行してもかまいませんし、移行先や全く無関係なコンピュータで &vmm; を利用して移行してもかまいません。ただし、無関係なコンピュータを利用する場合は、移行元と移行先の両方にリモート接続できる環境を用意する必要があります。</para>
   <procedure>
    <step>
     <para>まずは &vmm; を起動し、移行元のホストと移行先のホストの両方に接続します。移行元でも移行先でもないコンピュータで &vmm; を起動する場合、両方のホストへの接続ができる環境をご用意ください。</para>
    </step>
    <step>
     <para>移行対象の &vmguest; を選択してマウスの右ボタンを押し、 <guimenu>移行</guimenu> を選択します。なお、 &vmguest; が実行中であるか、一時停止中であることを確認してください。シャットダウン (シャットオフ) されているコンピュータに対しては、ゲストを移行することができません。</para>
     <tip>
      <title>移行速度の向上について</title>
      <para>移行速度を向上させるには、 &vmguest; を一時停止させる方法があります。これは従来のバージョンの &vmm; における <quote>オフラインマイグレーション</quote> と等価な意味を持ちます。</para>
     </tip>
    </step>
    <step>
     <para><guimenu>移行先のホスト</guimenu> を選択します。移行先のホストが一覧に現われていない場合は、ホストに接続されているかどうかを確認してください。</para>
     <para>リモートのホストに接続する際の既定のオプションを変更するには、 <guimenu>接続</guimenu> 以下にある <guimenu>モード</guimenu> と <guimenu>アドレス</guimenu> (IP アドレスもしくはホスト名) 、そして <guimenu>ポート</guimenu> をそれぞれ変更します。 <guimenu>ポート</guimenu> を指定した場合、 <guimenu>アドレス</guimenu> も指定しなければなりません。</para>
     <para><guimenu>詳細なオプション</guimenu> を選択すると、移行処理を恒久的に行なう (既定値) か一時的に行なう (<guimenu>一時的に移動</guimenu>) かを選択することができます。</para>
     <para>また、必要であれば <guimenu>安全ではない場合を許可する</guimenu> を選択することもできます。この場合、 &vmhost; のキャッシュを無効化せずに移行を行なうことになります。これにより移行処理を高速化することができますが、 <literal>cache=&quot;none&quot;</literal> / <literal>0_DIRECT</literal> を使用せずに &vmguest; のストレージに対して矛盾せずにアクセスできる設定が必要となります。</para>
     <note>
      <title>帯域幅オプションについて</title>
      <para>新しいバージョンの &vmm; では、移行時の帯域設定オプションの設定が削除されています。帯域幅を指定して移行したい場合は、 <command>virsh</command> をお使いください。</para>
     </note>
    </step>
    <step>
     <para>移行を開始するには、 <guimenu>マイグレーション</guimenu> を押します。</para>
     <para>移行が完了すると、 <guimenu>移行</guimenu> ウインドウが閉じられ、 &vmguest; が &vmm; ウインドウ内の新しいホストの下に表示されることになります。ただし、移行元の &vmguest; はそのまま残されます (シャットダウン状態になります) 。</para>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec-libvirt-admin-migrate-virsh">
   <title><command>virsh</command> を利用した移行</title>
   <para><command>virsh</command> <option>migrate</option> で &vmguest; の移行を行なう場合、ホスト内でコマンドを実行する必要があることから、 &vmhost; のシェルに直接接続する必要があります。移行コマンドは下記のようになります:</para>
<screen>&prompt.user;virsh migrate [OPTIONS] <replaceable>VM_の_ID_または名前</replaceable> <replaceable>接続_URI</replaceable> [--migrateuri tcp://<replaceable>ホスト名:ポート</replaceable>]</screen>
   <para>最もよく使用されるオプションは下記のとおりです。完全な一覧を読みたい場合は、 <command>virsh help migrate</command> を実行してください。</para>
   <variablelist>
    <varlistentry>
     <term><option>--live</option></term>
     <listitem>
      <para>ライブマイグレーションを行ないます。指定しない場合、ゲストは移行時に一時停止状態になります ( <quote>オフラインマイグレーション</quote> ) 。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>--suspend</option></term>
     <listitem>
      <para>オフラインマイグレーションを行ない、移行先のホストでは &vmguest; を再開しないようにします。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>--persistent</option></term>
     <listitem>
      <para>既定では、移行した &vmguest; は一時的な移行として扱われ、移行先のホストで &vmguest; をシャットダウンすると、設定を自動的に削除する用になります。このオプションを指定すると、移行処理を恒久的なものにすることができます。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>--undefinesource</option></term>
     <listitem>
      <para>これを指定した場合、移行処理が成功すると、移行元のホスト内での &vmguest; の定義を削除するようになります (ただし、ゲストに接続されていた仮想ディスクについては、削除が <emphasis>行なわれません</emphasis> ) 。</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>下記の例では、移行元のホストを &wsIVname; 、移行先のホストを &wsIname; とし、 &vmguest; の名前が <literal>opensuse131</literal> (ID <literal>37</literal>) であるものとして記述しています。</para>
   <variablelist>
    <varlistentry>
     <term>既定のパラメータによるオフラインマイグレーション</term>
     <listitem>
<screen>&prompt.user;virsh migrate 37 qemu+ssh://&exampleuser_plain;@&wsIname;/system</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>既定のパラメータによる一時的なライブマイグレーション</term>
     <listitem>
<screen>&prompt.user;virsh migrate --live opensuse131 qemu+ssh://&exampleuser_plain;@&wsIname;/system</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>恒久的なライブマイグレーション (成功時に移行元の VM 定義を削除する設定)</term>
     <listitem>
<screen>&prompt.user;virsh migrate --live --persistent --undefinesource 37 \
qemu+tls://&exampleuser_plain;@&wsIname;/system</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>ポート 49152 を使用したオフラインマイグレーション</term>
     <listitem>
<screen>&prompt.user;virsh migrate opensuse131 qemu+ssh://&exampleuser_plain;@&wsIname;/system \
--migrateuri tcp://@&wsIname;:49152</screen>
     </listitem>
    </varlistentry>
   </variablelist>
   <note>
    <title>暫定移行と恒久移行の違いについて</title>
    <para>既定では、 <command>virsh migrate</command> コマンドは移行先のホスト内に、一時的な (暫定的な) コピーを作成します。移行元のホストには、元のゲストがシャットダウン状態で残されます。一時的なコピーは、ゲストをシャットダウンするとサーバから削除されてしまいます。</para>
    <para>移行先のホストに恒久的なコピーを作成したい場合は、 <option>--persistent</option> オプションを指定してください。ただし、この場合も移行元のホストには、元のゲストをシャットダウンしたものが残ります。なお、 <option>--persistent</option> オプションと <option>--undefinesource</option> オプションを指定することで、移行先に恒久的なコピーを作成し、移行元のホストからは削除することができます。</para>
    <para>なお、 <option>--persistent</option> を指定せずに <option>--undefinesource</option> を指定することは避けておくことをお勧めします。この場合、移行が完了した時点で移行元のゲストが削除され、移行先ではシャットダウンを行なうことでゲストの設定が削除されてしまうためです。</para>
   </note>
  </sect2>

<!-- Step by step example -->

  <sect2 xml:id="sec-libvirt-migrate-stepbstep">
   <title>手順例</title>
   <para/>
   <sect3 xml:id="sec-migrate-stepbstep-export">
    <title>ストレージのエクスポート</title>
    <para>まずはホスト間でゲストのイメージを共有するため、ストレージのエクスポートを行ないます。エクスポートは NFS サーバを構築することで実現することができます。下記の例では、 10.0.1.0/24 のネットワーク内にある全てのマシンに対して、 <filename>/volume1/VM</filename> というディレクトリを共有しています。ここでは &sle; の NFS サーバを使用するものとします。 root ユーザで <filename>/etc/exports</filename> ファイルを編集し、下記の内容を追加します:</para>
<screen>/volume1/VM 10.0.1.0/24  (rw,sync,no_root_squash)</screen>
    <para>NFS サーバを再起動します:</para>
<screen>&prompt.sudo;systemctl restart nfsserver
&prompt.sudo;exportfs
/volume1/VM      10.0.1.0/24</screen>
   </sect3>
   <sect3 xml:id="sec-migrate-stepbstep-pool">
    <title>宛先のホストにおけるプールの定義</title>
    <para>&vmguest; の移行に使用するそれぞれのホストでは、ゲストのイメージを含んでいるボリュームにアクセスすることができるよう、プールを定義しなければなりません。ここでは NFS サーバが 10.0.1.99 にあり、共有が <filename>/volume1/VM</filename> というディレクトリに存在し、これを <filename>/var/lib/libvirt/images/VM</filename> ディレクトリにマウントする場合の例です。プール名は <emphasis>VM</emphasis> という名前であるものとします。プールを定義するには、 <filename>VM.xml</filename> というファイルを作成し、下記の内容を記述します:</para>
<screen>&lt;pool type='netfs'&gt;
  &lt;name&gt;VM&lt;/name&gt;
  &lt;source&gt;
    &lt;host name='10.0.1.99'/&gt;
    &lt;dir path='/volume1/VM'/&gt;
    &lt;format type='auto'/&gt;
  &lt;/source&gt;
  &lt;target&gt;
    &lt;path&gt;/var/lib/libvirt/images/VM&lt;/path&gt;
    &lt;permissions&gt;
      &lt;mode&gt;0755&lt;/mode&gt;
      &lt;owner&gt;-1&lt;/owner&gt;
      &lt;group&gt;-1&lt;/group&gt;
    &lt;/permissions&gt;
  &lt;/target&gt;
  &lt;/pool&gt;</screen>
    <para>あとはこの内容を &libvirt; に読み込ませるため、 <command>pool-define</command> コマンドを使用します:</para>
<screen>&prompt.root;virsh pool-define VM.xml</screen>
    <para>なお、 <command>virsh</command> コマンドを直接使用してプールを定義することもできます:</para>
<screen>&prompt.root;virsh pool-define-as VM --type netfs --source-host 10.0.1.99 \
     --source-path /volume1/VM --target /var/lib/libvirt/images/VM
プール VM が定義されました</screen>
    <para>以後のコマンドは、 <command>virsh</command> に何もパラメータを指定せずに実行した場合に提供される、 <command>virsh</command> の対話型シェルを利用して設定しています。あとはプールをホストの起動時に自動的に開始させる (autostart オプション) ようにします:</para>
<screen><prompt>virsh # </prompt>pool-autostart VM
プール VM が自動起動としてマークされました</screen>
    <para>autostart を無効化したい場合は、下記のように入力して実行します:</para>
<screen><prompt>virsh # </prompt>pool-autostart VM --disable
プール VM の自動起動マークが解除されました</screen>
    <para>あとはプールが存在しているかどうかを調べます:</para>
<screen><prompt>virsh # </prompt>pool-list --all
 名前                 状態       自動起動
-------------------------------------------
 default              動作中     はい (yes)
 VM                   動作中     はい (yes)

<prompt>virsh # </prompt>pool-info VM
名前:           VM
UUID:           42efe1b3-7eaa-4e24-a06a-ba7c9ee29741
状態:           動作中
永続:           はい (yes)
自動起動:       はい (yes)
容量:           2.68 TiB
割り当て:       2.38 TiB
利用可能:       306.05 GiB</screen>
    <warning>
     <title>全ての宛先ホストでプールが存在する必要性について</title>
     <para>このプールは、 &vmguest; を移行できるようにするため、各ホストでそれぞれ定義しておかなければなりません。ご注意ください。</para>
    </warning>
   </sect3>
   <sect3 xml:id="sec-migrate-stepbstep-volume">
    <title>ボリュームの作成</title>
    <para>ここまでの手順で、プールの定義は完了しています。あとはディスクイメージを含むボリュームを作成します:</para>
<screen><prompt>virsh # </prompt>vol-create-as VM sled12.qcow2 8G --format qcow2
ボリューム sled12.qcow2 が作成されました</screen>
    <para>ここで指定したボリューム名は、 virt-install でゲストをインストールする際に使用することができます。</para>
   </sect3>
   <sect3 xml:id="sec-migrate-stepbstep-guest">
    <title>&vmguest; の作成</title>
    <para>ここまでの手順を行なってきたら、あとは <command>virt-install</command> で &productname; の &vmguest; を作成するだけです。 <emphasis>VM</emphasis> プールを <command>--disk</command> オプションで指定します。また、後から移行処理を行なうことを考慮して、 <emphasis>cache=none</emphasis> オプションを設定しておくことをお勧めします。これを設定しておかないと、移行時に <command>--unsafe</command> オプションを付けなければならなくなるためです。</para>
<screen>&prompt.root;virt-install --connect qemu:///system --virt-type kvm --name \
   sled12 --memory 1024 --disk vol=VM/sled12.qcow2,cache=none --cdrom \
   /mnt/install/ISO/SLE-12-Desktop-DVD-x86_64-Build0327-Media1.iso --graphics \
   vnc --os-variant sled12
Starting install...
Creating domain...</screen>
   </sect3>
   <sect3 xml:id="sec-migrate-stepbstep-migrate">
    <title>&vmguest; の移行</title>
    <para>これで移行処理を行なうことができるようになります。移行元の &vmhost; で移行先を指定しながら <command>migrate</command> コマンドを実行します。</para>
<screen>virsh # migrate --live sled12 --verbose qemu+ssh://<replaceable>IP/ホスト名</replaceable>/system
Password:
マイグレーション: [ 12 %]</screen>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="cha-libvirt-admin-monitor">
  <title>監視</title>

  <para/>

  <sect2 xml:id="cha-libvirt-admin-monitor-virt-manager">
   <title>&vmm; を利用した監視</title>
   <para>&vmm; を起動して &vmhost; に接続すると、動作中のゲストの CPU 使用率が表示されます。</para>
   <para>このツールでは、ディスクやネットワークの使用率に関する情報も表示することができます。ただし、あらかじめ <guimenu>設定</guimenu> で機能を有効化しておかなければなりません:</para>
   <procedure>
    <step>
     <para><command>virt-manager</command> を起動します。</para>
    </step>
    <step>
     <para><menuchoice><guimenu>編集</guimenu> <guimenu>設定</guimenu></menuchoice> を選択します。</para>
    </step>
    <step>
     <para><guimenu>全般</guimenu> から <guimenu>ポーリング</guimenu> のタブに切り替えます。</para>
    </step>
    <step>
     <para>悲痛に応じて、監視したい項目を選択します。それぞれ <guimenu>ディスク I/O の取得</guimenu> , <guimenu>ネットワーク I/O の取得</guimenu> , <guimenu>メモリーの統計を取得する</guimenu> です。</para>
    </step>
    <step>
     <para>また、必要であれば <guimenu>状態の更新間隔</guimenu> の値も調整します。</para>
    </step>
    <step>
     <para><guimenu>設定</guimenu> ダイアログを閉じます。</para>
    </step>
    <step>
     <para>あとは <menuchoice> <guimenu>表示</guimenu> <guimenu>グラフ</guimenu> </menuchoice> 以下にある項目を選択して、グラフを表示させてください。</para>
    </step>
   </procedure>
   <para>すると、ディスクやネットワークの統計情報が、 &vmm; のメインウインドウ内に表示されるようになります。</para>
   <para>より詳しいデータを閲覧したい場合は、 VNC ウインドウからご確認ください。 VNC ウインドウの表示方法は <xref linkend="sec-libvirt-managing-console-vnc"/> で説明しています。ツールバーから <guimenu>仮想マシンの情報を表示</guimenu> を押すか、もしくは <menuchoice><guimenu>表示</guimenu><guimenu>詳細</guimenu></menuchoice> を選択してください。統計情報は左側のメニュー内にある <guimenu>性能</guimenu> を選択すると、表示されるようになります。</para>
  </sect2>

  <sect2 xml:id="cha-libvirt-admin-monitor-virt-top">
   <title><command>virt-top</command> を利用した監視</title>
   <para><command>virt-top</command> はよく知られたプロセス監視ツールである <command>top</command> に似たコマンドラインツールです。 <command>virt-top</command> は libvirt を利用して、さまざまなハイパーバイザで動作する &vmguest; の統計情報を表示することができます。 <command>xentop</command> のようなハイパーバイザ固有のツールではなく、 <command>virt-top</command> のような汎用ツールの使用をお勧めします。</para>
   <para>既定では、 <command>virt-top</command> は実行中の全ての &vmguest; に対する統計情報を表示します。ここにはメモリの使用率 ( <literal>%MEM</literal> ) のほか、 CPU の使用率 ( <literal>%CPU</literal> ) とゲストの動作時間 ( <literal>TIME</literal> ) が表示されます。データは定期的に自動更新されます (既定では 3 秒間隔で更新されます) 。下記の例では、 &vmhost; 内に合計 7 つの &vmguest; が存在し、それらのうちの 4 つが停止されている状況を示しています:</para>
<screen>virt-top 13:40:19 - x86_64 8/8CPU 1283MHz 16067MB 7.6% 0.5%
7 domains, 3 active, 3 running, 0 sleeping, 0 paused, 4 inactive D:0 O:0 X:0
CPU: 6.1%  Mem: 3072 MB (3072 MB by guests)

   ID S RDRQ WRRQ RXBY TXBY %CPU %MEM    TIME   NAME
    7 R  123    1  18K  196  5.8  6.0   0:24.35 sled12_sp1
    6 R    1    0  18K    0  0.2  6.0   0:42.51 sles12_sp1
    5 R    0    0  18K    0  0.1  6.0  85:45.67 opensuse_leap
    -                                           (Ubuntu_1410)
    -                                           (debian_780)
    -                                           (fedora_21)
    -                                           (sles11sp3)</screen>
   <para>既定での並び順は ID 順です。柿の木ー入力を行なうことで、並び順を変更することができます:</para>
   <simplelist>
    <member><keycombo><keycap function="shift"/><keycap>P</keycap></keycombo> : CPU の使用率</member>
    <member><keycombo><keycap function="shift"/><keycap>M</keycap></keycombo> : ゲストに割り当てているメモリ量</member>
    <member><keycombo><keycap function="shift"/><keycap>T</keycap></keycombo> : 時間</member>
    <member><keycombo><keycap function="shift"/><keycap>I</keycap></keycombo> : ID</member>
   </simplelist>
   <para>その他の情報をもとに並べ替えを行ないたい場合は、 <keycombo> <keycap function="shift"/> <keycap>F</keycap> </keycombo> を押して、表示される一覧から項目を選択してください。並び順を逆にしたい場合は、 <keycombo> <keycap function="shift"/> <keycap>R</keycap> </keycombo> を押します。</para>
   <para><command>virt-top</command> では、 &vmguest; のデータをさまざまな形で表示することができます。これらは下記のキー入力を行なうことで、即時に変更することができます:</para>
   <simplelist>
    <member><keycap>0</keycap> : 既定の表示</member>
    <member><keycap>1</keycap> : 物理 CPU の表示</member>
    <member><keycap>2</keycap> : ネットワークインターフェイスの表示</member>
    <member><keycap>3</keycap> : 仮想ディスクの表示</member>
   </simplelist>
   <para><command>virt-top</command> には表示を変更するためのさまざまなキー入力や、プログラムの動作を変更するためのさまざまなコマンドラインが用意されています。詳しくは <command>man 1 virt-top</command> をお読みください。</para>
  </sect2>

  <sect2 xml:id="cha-libvirt-admin-monitor-kvm-stat">
   <title><command>kvm_stat</command> を利用した監視</title>
   <para><command>kvm_stat</command> は、 &kvm; の性能イベントを追跡する際に使用するツールです。 <filename>/sys/kernel/debug/kvm</filename> を監視する仕組みであるため、まずは debugfs をマウントする必要があります。 &productname; では既定でマウントされるように設定されていますが、何らかの理由でマウントされていない場合は、下記のように実行してマウントしてください:</para>
<screen>&prompt.sudo;mount -t debugfs none /sys/kernel/debug</screen>
   <para><command>kvm_stat</command> は、下記に示す 3 種類の動作モードが用意されています:</para>
<screen>kvm_stat                    # 1 秒間隔で更新
kvm_stat -1                 # 1 秒間情報採取して出力
kvm_stat -l &gt; kvmstats.log  # ログ形式で 1 秒間隔で更新
                            # (表計算プログラムなどに取り込むことができます)</screen>
   <example>
    <title><command>kvm_stat</command> の出力例</title>
<screen>kvm statistics

 efer_reload                  0       0
 exits                 11378946  218130
 fpu_reload               62144     152
 halt_exits              414866     100
 halt_wakeup             260358      50
 host_state_reload       539650     249
 hypercalls                   0       0
 insn_emulation         6227331  173067
 insn_emulation_fail          0       0
 invlpg                  227281      47
 io_exits                113148      18
 irq_exits               168474     127
 irq_injections          482804     123
 irq_window               51270      18
 largepages                   0       0
 mmio_exits                6925       0
 mmu_cache_miss           71820      19
 mmu_flooded              35420       9
 mmu_pde_zapped           64763      20
 mmu_pte_updated              0       0
 mmu_pte_write           213782      29
 mmu_recycled                 0       0
 mmu_shadow_zapped       128690      17
 mmu_unsync                  46      -1
 nmi_injections               0       0
 nmi_window                   0       0
 pf_fixed               1553821     857
 pf_guest               1018832     562
 remote_tlb_flush        174007      37
 request_irq                  0       0
 signal_exits                 0       0
 tlb_flush               394182     148</screen>
   </example>
   <para>これらの値の解釈方法について、詳しくは <link xlink:href="http://clalance.blogspot.com/2009/01/kvm-performance-tools.html"/> (英語) をお読みください。</para>
  </sect2>
 </sect1>
</chapter>
