<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter [
<!ENTITY % entities SYSTEM "entity-decl.ent">
%entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha.tuning.systemtap">
<!--taroth 2011-08-18: this chapter documents systemtap 1.0, for SLES 11 SP2
        we ship systemtap 1.5-->
<!--
    http://sourceware.org/systemtap/wiki/

    http://en.wikipedia.org/wiki/Systemtap
    http://sourceware.org/systemtap/
    http://sourceware.org/systemtap/documentation.html
    http://sourceware.org/systemtap/langref/
-->
<!--taroth 2011-10-17: commenting for now (systemtap 1.5), to be updated later-->
<!--<para>
  There are two different setups for using &stap;:
 </para>
 <variablelist>
  <varlistentry>
   <term><xref linkend="sec.tuning.systemtap.setup.classic" xrefstyle="select:title"/>
   </term>
   <listitem>
    <para>
     Have the &stap; script compiled and the resulting kernel modules
     inserted on the same machine. This requires the machine to have the
     kernel debugging information installed.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><xref linkend="sec.tuning.systemtap.setup.client-server" xrefstyle="select:title"/>
   </term>
   <listitem>
    <para>
     If the machine you want to probe does not have any development tools or
     kernel debugging information installed for any reason, you can make use
     of this setup. It allows you to compile a &stap; module on a machine
     other than the one on which it will be run.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>-->
<!--taroth 2013-11-22: http://doccomments.provo.novell.com/admin/viewcomment/14466-->
 <title>&stap;: システムデータのフィルタリングと分析</title>
 <info>
      <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
        <dm:bugtracker>
          </dm:bugtracker>
      </dm:docmanager>
    </info>
    <!--taroth 2011-08-18: this chapter documents systemtap 1.0, for SLES 11 SP2
        we ship systemtap 1.5-->
<!--
    http://sourceware.org/systemtap/wiki/

    http://en.wikipedia.org/wiki/Systemtap
    http://sourceware.org/systemtap/
    http://sourceware.org/systemtap/documentation.html
    http://sourceware.org/systemtap/langref/
-->
 <para>&stap; は、稼働中の Linux システムで動作状況を調査するためのコマンドラインインターフェイスとスクリプト言語を提供する仕組みです。特にカーネルの動作状況を詳細に収集することができます。 &stap; のスクリプトは &stap; スクリプト言語で記述され、これを C 言語のカーネルモジュールにコンパイルして、カーネル内に挿入します。スクリプトはデータを抽出するだけでなく、フィルタや要約を行なうこともできるため、複雑な性能問題や機能面の問題を分析することができるようになっています。また、 &stap; では <command>netstat</command> , <command>ps</command> , <command>top</command> , <command>iostat</command> などのツールの出力に似た情報を提供しますが、収集した情報に対してフィルタリングや分析などのオプションを適用することができます。</para>
<!--taroth 2011-10-17: commenting for now (systemtap 1.5), to be updated later-->
<!--<para>
  There are two different setups for using &stap;:
 </para>
 <variablelist>
  <varlistentry>
   <term><xref linkend="sec.tuning.systemtap.setup.classic" xrefstyle="select:title"/>
   </term>
   <listitem>
    <para>
     Have the &stap; script compiled and the resulting kernel modules
     inserted on the same machine. This requires the machine to have the
     kernel debugging information installed.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><xref linkend="sec.tuning.systemtap.setup.client-server" xrefstyle="select:title"/>
   </term>
   <listitem>
    <para>
     If the machine you want to probe does not have any development tools or
     kernel debugging information installed for any reason, you can make use
     of this setup. It allows you to compile a &stap; module on a machine
     other than the one on which it will be run.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>-->
 <sect1 xml:id="sec.tuning.systemtap.concept">
  <title>考え方の概要</title>

  <para>&stap; スクリプトを動作させると、 &stap; セッションが起動します。また、スクリプトが実行されるまでの間に、いくつかのパスが実行されます。その後、スクリプトはカーネルモジュールとしてコンパイルされ、読み込まれます。スクリプトを以前に実行していて、システムコンポーネント (コンパイラやカーネルのバージョン、ライブラリパスやスクリプトの内容) に変更がない場合、 &stap; は再度スクリプトをコンパイルするようなことはありません。その代わり、 &stap; のキャッシュ ( <filename>~/.systemtap</filename> ) 内に保存されている <filename>*.c</filename> と <filename>*.ko</filename> のデータを使用します。</para>
  <para>タップの動作が完了すると、モジュールの読み込みも解除されます。たとえば <xref linkend="sec.tuning.systemtap.setup"/> にあるテストスクリプトと、対応する説明をお読みください。 <!--taroth 2011-10-17: systemtap 1.5, orginal linkend: sec.tuning.systemtap.setup.classic--></para>

  <sect2 xml:id="sec.tuning.systemtap.concept.scripts">
   <title>&stap; スクリプト</title>
   <para>&stap; は &stap; スクリプト ( <filename>*.stp</filename> ) を利用して行なう仕組みです。スクリプト内では収集する情報の種類のほか、収集後に何をすべきかを指定しています。スクリプトは &stap; スクリプト言語と呼ばれる、 AWK や C 言語に似た言語で作成します。言語の詳しい定義については <link xlink:href="http://sourceware.org/systemtap/langref/"/> (英語) をお読みください。また、スクリプト例については <link xlink:href="http://www.sourceware.org/systemtap/examples/"/> をご覧ください。</para>
   <para>&stap; スクリプトの考え方のベースとして、 <literal>イベント</literal> とそれに対応した <literal>ハンドラ</literal> があります。 &stap; がスクリプトを実行すると、 &stap; はまず特定のイベントを待機します。そのイベントが発生すると、 Linux カーネルはサブルーチンとして指定されたハンドラを実行し、元の処理に戻ります。このような仕組みであることから、イベントはスクリプトを実行する際のトリガー (起動条件) と考えることができます。また、ハンドラは指定したデータをそのまま記録することができるほか、特定の書式でそれを出力することもできます。</para>
   <para>&stap; 言語にはいくつかのデータ型 (整数, 文字列, およびそれらの連想配列) と、完全な制御構造 (ブロック, 条件分岐, ループ, 関数) が用意されています。また、文法は軽量な構造で、文末のセミコロンは省略することができますし、詳細なデータ型指定を行なう必要もありません (データ型は自動的に推測およびチェックされます) 。</para>
   <para>&stap; スクリプトとその文法に関する詳細については、 <xref linkend="sec.tuning.systemtap.syntax"/> のほか、 <command>stapprobes</command> と <command>stapfuncs</command> の各マニュアルページをお読みください。マニュアルページは <systemitem class="resource">systemtap-docs</systemitem> パッケージ内に含まれています。</para>
  </sect2>

  <sect2 xml:id="sec.tuning.systemtap.concept.tapsets">
   <title>タップセット</title>
   <para><remark>sknorr, 2014-08-21: "tapsets are a library" sounds wrong... to me, it would make more sense if there was a "library of tapsets," i.e. a collection of systemtap scripts.</remark> タップセットは、あらかじめ記述されたプローブや関数を含むライブラリで、 &stap; のスクリプト内から使用することができます。 &stap; のスクリプトを実行すると、 &stap; はスクリプト内のプローブイベントとハンドラが、タップセットライブラリ内に存在していないかどうかを確認します。 &stap; はスクリプトを C 言語に翻訳する前に、対応するプローブや関数を読み込みます。 &stap; スクリプト自身のように、タップセットにも同じファイル拡張子 <filename>*.stp</filename> が設定されています。 <!--The standard library of tapsets is located in /usr/share/systemtap/tapset/ by default.--></para>
   <para>ただし、 &stap; スクリプトとは異なり、タップセットは直接実行するためのものではありません。タップセットは他のスクリプトに定義を与える存在であり、タップセットライブラリはユーザに対して、イベントや関数の定義をやりやすくするために設計されているものです。タップセットは関数に対して別名を提供し、ユーザ側からイベントとして指定することができるようになります。そのため、カーネルのバージョンによって異なるようなカーネルの関数を、より簡単に指定することができるようになります。</para>
  </sect2>

  <sect2 xml:id="sec.tuning.systemtap.concept.cmd">
   <title>コマンドと権限</title>
   <para>&stap; に付属するメインのコマンドは、 <command>stap</command> と <command>staprun</command> の 2 種類です。これらを実行するには &rootuser; の権限を使用するか、もしくは <systemitem class="groupname">stapdev</systemitem> または <systemitem class="groupname">stapusr</systemitem> のメンバーである必要があります。</para>
   <variablelist>
    <varlistentry>
     <term><command>stap</command></term>
     <listitem>
      <para>&stap; のフロントエンドです。 &stap; スクリプトのファイルを指定するか、もしくは標準入力から読み込むことで実行することができます。スクリプトは C 言語のコードに翻訳され、コンパイルされて動作中の Linux カーネル内でモジュールとして読み込みが行なわれます。これにより、必要なシステムトレースやプローブ関数を実行することができるようになります。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><command>staprun</command></term>
     <listitem>
      <para>&stap; のバックエンドです。 &stap; のフロントエンドが作成したカーネルモジュールを、読み込んだり読み込みを解除したりすることができます。 <!--runs instrumentation modules--></para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>それぞれのコマンドに対するオプションを知りたい場合は、 <option>--help</option> オプションを指定して実行してください。詳しくは <command>stap</command> と <command>staprun</command> の各マニュアルページをお読みください。</para>
<!--taroth 2011-10-17: commenting for now (systemtap 1.5), to be updated later-->
<!--  <para>
    Apart from the commands above which are used in a setup where you build
    the kernel modules on the same machine that you want to probe, there is
    also a specific set of commands for a client-server setup:
    <remark>taroth 2011-10-07: deprecated, according to systemtap 1.5 RN
     (http://www.sourceware.org/ml/systemtap/2011-q2/msg00218.html)</remark><command>systemtap-client</command> and
    <command>stap-server</command>, the latter containing several
    subcommands. This set of commands allows you to compile a &stap; module
    on a machine other than the one on which it will be run. For more
    information about this specific setup and the commands involved, refer
    to <xref linkend="sec.tuning.systemtap.setup"/> and to the
    <command>stap-server</command> and <command>stap-client</command> man
    pages.
   </para>-->
<para><!-- bsc#992981 --> &rootuser; の権限を与えずに一般ユーザの権限で &stap; を実行させたい場合は、対象のユーザを下記の &stap; グループのいずれかに所属するように設定してください。これらのグループは既定の &productname; では作成されていませんので、必要に応じて作成し、アクセス権を調整してください。また、お使いの環境でセキュリティへの影響に問題がなければ、 <command>staprun</command> コマンドのパーミッションを調整してもかまいません。</para>
   <variablelist>
    <varlistentry>
     <term><systemitem class="groupname">stapdev</systemitem></term>
     <listitem>
      <para>このグループのメンバーであれば、 <command>stap</command> コマンドで &stap; スクリプトを実行することができるほか、 <command>staprun</command> コマンドで計装モジュールを実行することもできます。なお、 <command>stap</command> コマンドの実行には、スクリプトをカーネルモジュールにコンパイルする処理と、コンパイルしたカーネルモジュールをカーネルに読み込む処理が含まれますので、実質的には &rootuser; のアクセスと同等の権限を持つことになります。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem class="groupname">stapusr</systemitem></term>
     <listitem>
      <para>このグループのメンバーは、 <command>staprun</command> コマンドで計装モジュールを実行する権限のみを持ちます。これに加えて、 <filename>/lib/modules/<replaceable>カーネルバージョン</replaceable>/systemtap/</filename> 内にあるモジュールのみを実行することができます。このディレクトリは &rootuser; が所有しなければならず、かつ &rootuser; ユーザのみが書き込むことができるようにしなければなりません。</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec.tuning.systemtap.concept.dir">
   <title>主要なファイルとディレクトリ</title>
   <para>下記では、 &stap; で使用される主なファイルとディレクトリについて、概要を説明しています。</para>
   <variablelist>
    <varlistentry>
     <term><filename>/lib/modules/<replaceable>カーネルバージョン</replaceable>/systemtap/</filename></term>
     <listitem>
      <para>&stap; の計装モジュールが含まれるディレクトリです。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><filename>/usr/share/systemtap/tapset/</filename></term>
     <listitem>
      <para>タップセットの標準ライブラリが含まれるディレクトリです。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><filename>/usr/share/doc/packages/systemtap/examples</filename></term>
     <listitem>
      <para>様々な用途に対応した &stap; スクリプトの例を配置しているディレクトリです。なお、このディレクトリは <systemitem class="resource">systemtap-docs</systemitem> パッケージをインストールした場合にのみ作成されます。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><filename>~/.systemtap/cache</filename></term>
     <listitem>
      <para>キャッシュされた &stap; ファイルを含むデータディレクトリです。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><filename>/tmp/stap*</filename></term>
     <listitem>
      <para>&stap; ファイルの一時ディレクトリです。 C 言語に変換されたコードのほか、カーネルオブジェクトなどが含まれます。</para>
     </listitem>
    </varlistentry>
   </variablelist>
<!--taroth 2011-10-17: commenting for now (systemtap 1.5), to be updated later-->
<!-- <para>
    If you use the &stap; client-server setup, the following directories are
    also important:
   </para>
   <variablelist>
    <varlistentry>
     <term><filename>/etc/systemtap/ssl/server</filename>
     </term>
     <listitem>
      <para>
       Public &stap; server certificate and key database. Used if the &stap;
       server is set up under &rootuser;'s account.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><filename>/etc/systemtap/ssl/client</filename>
     </term>
     <listitem>
      <para>
       &stap; client-side certificate database. Only located in this
       directory if a &stap; server is authorized as trusted for
       <emphasis>all</emphasis> &stap; clients running on this machine.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><filename>~/.systemtap/ssl/server</filename>
     </term>
     <listitem>
      <para>
       Private &stap; server certificate and key database. Used if the
       &stap; server is not running under a &rootuser; account, but under a
       regular user's account. Usually, a dedicated user named
       <systemitem class="username">stap-server</systemitem> is created for
       that purpose.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><filename>~/.systemtap/ssl/client</filename>
     </term>
     <listitem>
      <para>
       Client-side certificate database, located in a regular user's home
       directory. Only located in this directory if a &stap; server has been
       authorized as trusted for &stap; clients run by this specific user.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><filename>/var/log/stap-server.log
    </filename>
     </term>
     <listitem>
      <para>
       Default &stap; server log file.
      </para>
     </listitem>
    </varlistentry>
    </variablelist>-->
  </sect2>
 </sect1>
 <sect1 xml:id="sec.tuning.systemtap.setup">
  <title>インストールと設定</title>

  <para><!--taroth 2011-10-17: commenting for now (systemtap 1.5), to be updated later--> <!--Depending on your preferred setup, check the sections below for an overview of the packages you need.--> &stap; を動作させるにはカーネルに関する情報が必要となることから、カーネル関連の追加パッケージをインストールしなければなりません。また、 &stap; でプローブを設定したいカーネルごとに、それぞれ下記のパッケージをインストールする必要があります。さらに、下記のパッケージをインストールする場合は、プローブを設定したいカーネルのフレーバー (下記では <literal>*</literal> と記してあります) とバージョンが厳密に一致したパッケージをインストールする必要があります。</para>

  <important>
   <title>デバッグ情報 (debuginfo) パッケージのリポジトリについて</title>
   <para>お使いのシステムでオンライン更新を有効にしていれば、 &productname; &productnumber; に対応する <literal>*-Debuginfo-Updates</literal> という名前のオンラインリポジトリ内に、 <quote>debuginfo</quote> パッケージが存在しています。このリポジトリを有効にするには、 &yast; をお使いください。</para>
  </important>

<!--taroth 2011-10-17: commenting for now (systemtap 1.5): original location of the para-->

<!--<para>
   To get access to the man pages and to a helpful collection of example
   &stap; scripts for various purposes, additionally install the
   <systemitem class="resource"
   >systemtap-docs</systemitem> package.
  </para>-->

<!--taroth 2011-10-17: commenting for now (systemtap 1.5), to be updated later-->

<!--<sect2 id="sec.tuning.systemtap.setup.classic">
   <title>Classic Setup and Initial Test</title>
-->

  <para><!--For this setup,...--> 従来型の &stap; 設定を行なう場合は、下記のパッケージをインストールしてください (&yast; もしくは <command>zypper</command> を利用してインストールします。</para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para><systemitem class="resource">systemtap</systemitem></para>
   </listitem>
   <listitem>
    <para><systemitem class="resource">systemtap-server</systemitem></para>
   </listitem>
   <listitem>
    <para><systemitem class="resource">systemtap-docs</systemitem> (任意)</para>
   </listitem>
   <listitem>
    <para><systemitem class="resource">kernel-*-base</systemitem></para>
   </listitem>
<!--taroth 2011-10-07: just for the records: debuginfo pkgs are
           internally available from DVD3-->
   <listitem>
    <para><systemitem class="resource">kernel-*-debuginfo</systemitem></para>
   </listitem>
   <listitem>
    <para><systemitem class="resource">kernel-*-devel</systemitem></para>
   </listitem>
   <listitem>
    <para><systemitem class="resource">kernel-source-*</systemitem></para>
   </listitem>
   <listitem>
    <para><systemitem class="resource">gcc</systemitem></para>
   </listitem>
  </itemizedlist>

<!--taroth 2011-10-17: moved para here, change to original location after update
    for systemtap 1.5 is done-->

  <para>マニュアルページや &stap; のスクリプト例など、様々な目的でのヘルプ情報を必要とする場合は、これらに加えて <systemitem class="resource">systemtap-docs</systemitem> パッケージもインストールしてください。</para>

  <para>マシン内に必要なパッケージを全てインストールできていて、 &stap; を使用するための準備が整っているかどうかを確認するには、下記のコマンドを &rootuser; で実行します:</para>

<screen>&prompt.root;stap -v -e 'probe vfs.read {printf("read performed
"); exit()}'</screen>

  <para>上記のコマンドを実行すると、スクリプトを実行して現在動作しているカーネルに対してプローブを設定し、出力を返します。出力が下記のような内容になっていれば、 &stap; は問題なく配置できたことになります:</para>

<screen><?dbsuse-fo font-size="0.71em"?>Pass <co xml:id="co.tuning.stap.pass1"/>: parsed user script and 59 library script(s) in 80usr/0sys/214real ms.
Pass <co xml:id="co.tuning.stap.pass2"/>: analyzed script: 1 probe(s), 11 function(s), 2 embed(s), 1 global(s) in
 140usr/20sys/412real ms.
Pass <co xml:id="co.tuning.stap.pass3"/>: translated to C into
 "/tmp/stapDwEk76/stap_1856e21ea1c246da85ad8c66b4338349_4970.c" in 160usr/0sys/408real ms.
Pass <co xml:id="co.tuning.stap.pass4"/>: compiled C into "stap_1856e21ea1c246da85ad8c66b4338349_4970.ko" in
 2030usr/360sys/10182real ms.
Pass <co xml:id="co.tuning.stap.pass5"/>: starting run.
 read performed
Pass <xref linkend="co.tuning.stap.pass5"/>: run completed in 10usr/20sys/257real ms. </screen>

  <calloutlist>
   <callout arearefs="co.tuning.stap.pass1">
    <para>スクリプトと <filename>/usr/share/systemtap/tapset/</filename> 内にある既存のタップセットライブラリをチェックしています。タップセットとはあらかじめ作成されたプローブや関数を集めたライブラリで、 &stap; スクリプト内から使用できる仕組みです。</para>
   </callout>
   <callout arearefs="co.tuning.stap.pass2">
    <para>スクリプトのコンポーネントを調べています。</para>
   </callout>
   <callout arearefs="co.tuning.stap.pass3">
    <para>スクリプトを C 言語に変換しています。その後、作成された C 言語のソースコードを C コンパイラに通して、カーネルモジュールを作成しています。変換後の C 言語ソースコード ( <filename>*.c</filename> ) とカーネルモジュール ( <filename>*.ko</filename> ) が、 <filename>~/.systemtap</filename> にある &stap; キャッシュ内に保管されます。</para>
   </callout>
   <callout arearefs="co.tuning.stap.pass4">
    <para>モジュールを読み込んだあと、スクリプト内に指定されている全てのプローブ (イベントおよびハンドラ) をカーネル内のフックとして設置し、有効化しています。この例で使用しているプローブは、仮想ファイルシステム (Virtual File System; VFS) の読み込み処理になります。任意のプロセッサ内で対象のイベントが発生すると、対応するハンドラが実行 (この例では、 <literal>read performed</literal> と表示しています) され、エラー無しに終了しています。</para>
   </callout>
   <callout arearefs="co.tuning.stap.pass5">
    <para>&stap; のセッションが終了すると、プローブは無効化され、カーネルモジュールの読み込みも解除されます。</para>
   </callout>
  </calloutlist>

  <para>テスト時に何らかのエラーメッセージが表示された場合、まずは出力された内容をご確認ください。出力された内容に必要なパッケージに関する情報が書かれている場合は、まず必要なパッケージが正しくインストールされていることを確認してください。また、カーネルをインストールした場合は、システムを再起動して新しいカーネルを読み込む必要があります。  <remark>jw 2010-09-23, while I am at it: I have two useful smoke tests, to verify if an installation is working, see http://docserv.suse.de/HOWTO/systemtap If you install systemtap on an older system, the debuginfo and devel packages are likely to be newer than your installed kernel. Finding the correct versions for a given kernel might be challenging. I usually circumvent this by upgrading the kernel. </remark></para>

<!-- </sect2>-->

<!-- <sect2 id="sec.tuning.systemtap.setup.client-server">
   <title>Client-Server Setup</title>
   <remark>taroth 2011-10-07: argh, this section needs a major revamp with systemtap 1.5... see the
    systemtap 1.5 RN: "The following deprecated tools have been removed: stap-client
    stap-authorize-server-cert stap-authorize-signing-cert stap-find-or-start-server
    stap-find-servers Use the &#8722;&#8722;use-server, &#8722;&#8722;trust-server and &#8722;&#8722;list-servers options of stap
    instead."</remark>
   <para>
    A &stap; compile server listens for connections from &stap; clients on a
    secure SSL network port and accepts requests to run the &stap;
    front-end. The server advertises its presence and configuration on the
    local network using avahi (a free Zeroconf implementation that allows
    programs to publish and discover services and hosts in a local network
    without any specific configuration). The compile server broadcasts its
    IP address, port, and details about the Linux kernel it runs. Thus, the
    &stap; client can automatically detect a compile server on the network
    that is compatible to the client's kernel version.
   </para>
   <para>
    As &stap; exposes kernel internal data structures and potentially
    private user information, it provides several layers of security:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      A separate front-end (<command>stap</command>) and back-end
      (<command>staprun</command>), with only the front-end requiring access
      to kernel information packages for compiling the &stap; script into C
      code and for creating a kernel module. For more information, refer to
      <xref linkend="sec.tuning.systemtap.concept.cmd"/>.
     </para>
    </listitem>
<!-\-taroth 2010-06-01: commenting for this release; based on tonyj's answer-\->
<!-\-<listitem>
     <para>
      <remark>taroth 2010-05-12: tonyj: should we mention this already as it only seems to be fully
      integrated with &stap; 1.1 or higher (SLE 11 SP1 ships with &stap; 1.0) -
       tonyj 2010-05-25: Dunno. Does it work? I've not personally tested it.  If it kinda works you
      could mention it w/ caveat that it is experimental in 1.0 of course I doubt
      this will prevent bug reports</remark>
      A new (experimental) <command>stap</command> option:
      <option>minus minus unprivileged</option> that allows non-&rootuser; users to
      run <command>stap</command> (with certain restrictions).
     </para>
    </listitem>-\->
    <listitem>
     <para>
      An encrypted network connection between &stap; client and server via
      SSL. The SSL connection is based on certificates and key pairs
      consisting of public and private keys.
     </para>
    </listitem>
    <listitem>
     <para>
      Users or system administrators can authorize &stap; servers on the
      network as <quote>trusted</quote>.
     </para>
    </listitem>
    <listitem>
     <para>
      Use of &stap; groups with different privileges. For more information,
      refer to <xref
    linkend="sec.tuning.systemtap.concept.cmd"/>.
     </para>
    </listitem>
   </itemizedlist>
   <sect3 id="sec.tuning.systemtap.setup.inst">
    <title>Installing &stap;</title>
    <para>
     For this setup, install the following packages (using &yast; or
     Zypper):
    </para>
    <variablelist>
     <varlistentry>
      <term>Client</term>
      <listitem>
       <itemizedlist>
        <listitem>
         <para>
          <systemitem class="resource">systemtap</systemitem>
         </para>
        </listitem>
        <listitem>
         <para>
          <systemitem class="resource">systemtap-docs</systemitem> (optional) </para>
        </listitem>
       </itemizedlist>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Server</term>
      <listitem>
       <itemizedlist>
        <listitem>
         <para>
          <systemitem class="resource">systemtap</systemitem>
         </para>
        </listitem>
        <listitem>
         <para>
          <systemitem class="resource">systemtap-server</systemitem>
         </para>
        </listitem>
        <listitem>
         <para>
          <systemitem class="resource">kernel-*-debuginfo</systemitem>
         </para>
        </listitem>
        <listitem>
         <para>
          <systemitem class="resource">kernel-*-devel</systemitem>
         </para>
        </listitem>
        <listitem>
         <para>
          <systemitem class="resource">kernel-source-*</systemitem>
         </para>
        </listitem>
        <listitem>
         <para>
          <systemitem class="resource">gcc</systemitem>
         </para>
        </listitem>
       </itemizedlist>
      </listitem>
     </varlistentry>
    </variablelist>
<!-\-taroth 2010-06-01: commenting for this release; based on tonyj's answer-\->
<!-\-<para> Instead of running the &stap; compile server and client on two individual machines,
     you can also set up both on the same machine. <remark>taroth 2010-05-18: tonyj, would this
      setup also make sense in a real world scenario? or just for testing purposes? - tonyj
      2010-05-25: The only non-testing case I can think of is for minus minus unpriviliged</remark>
      </para>-\->
   </sect3>
   <sect3 id="sec.tuning.systemtap.setup.server">
    <title>Setting Up the Server</title>
    <para>
     You have two choices for setting up the &stap; compile server: you can
     run it as &rootuser; or as non-&rootuser; user. This has implications
     on the certificate management on server- and client-side and on the
     process of establishing a given compile server as trusted by a given
     client. For the SSL connection between the compile server and the
     &stap; client, you need to create a certificate for authentication.
     Depending on how the &stap; compile server is set up (as &rootuser; or
     as non-&rootuser;), the location of the server certificate differs.
     When set up as &rootuser; user, the certificate is stored in a database
     at <filename>/etc/systemtap/ssl/server</filename>. However, when the
     compile server is set up as non-&rootuser; (usually by the user
     <systemitem
      class="username">stap-server</systemitem>), the
     server certificate is stored in a database in the
     <literal>systemtap-server</literal> user's home directory:
     <filename>~/.systemtap/ssl/server</filename>.
    </para>
    <procedure id="pro.tuning.stap.setup.server.non-root">
     <title>Running the Compile Server as Non-&rootuser; User</title>
     <para>
      For this setup, it is advisable to create a dedicated system group and
      user for the compile server.
     </para>
     <step>
      <para>
       Log in as &rootuser;.
      </para>
     </step>
     <step id="step.stap.setup.server.homedir">
      <para>
       Create a home directory for the compile server user, for example:
      </para>
<screen>mkdir /var/lib/stapserver</screen>
     </step>
     <step>
      <para>
       Add a system group for the operation of the compile server. In the
       following example, the group is named <literal>stap-server</literal>
       and the group ID (GID) is <literal>155</literal>, but you can also
       specify a different group name or GID:
      </para>
<screen>groupadd -g 155 -r stap-server</screen>
     </step>
     <step>
      <para>
       Add a user belonging to the group you created before and specify the
       user's home directory:
      </para>
<screen>useradd -c "&stap; Compile Server" -u 155 -g stap-server -d \ /var/lib/stapserver -m -r -s /sbin/nologin stap-server</screen>
      <para>
       The command above will create a user named
       <systemitem class="username"
        >stap-server</systemitem> with
       the user ID <literal>155</literal>. The user's finger information is
       specified with <option>-c</option> and the options
       <option>-g</option> and <literal>-d</literal> specify the user's main
       group (<literal>stap-server</literal>) and their home directory you
       created in <xref linkend="step.stap.setup.server.homedir"/>,
       respectively. The user account will be a system account (specified
       with <option>-r</option>) and the user will not be able to log in, as
       their login shell is set to <filename>/sbin/nologin</filename> with the
       <option>-s</option> option.
      </para>
     </step>
     <step>
      <para>
       Change the owner and the group for the home directory to use:
      </para>
<screen>chown -R stap-server.stap-server /var/lib/stapserver/</screen>
     </step>
     <step>
      <para>
       Run a shell as user
       <systemitem class="username">stap-server</systemitem> and pass the
       <command>stap-gen-cert</command> command to generate a &stap;
       certificate:
      </para>
<screen>su -s /bin/sh - stap-server -c  /usr/bin/stap-gen-cert</screen>
      <para>
       You are prompted to set a password for the &stap; server certificate
       and key database.
      </para>
     </step>
     <step>
      <para>
       Enter a password for the &stap; server certificate and confirm it.
      </para>
      <para>
       This generates a certificate (<filename>stap.cert</filename>) that is
       stored in the <literal>systemtap-server</literal> user's home
       directory&mdash;in this case:
       <filename>/var/lib/stapserver/.systemtap/ssl/server</filename>.
      </para>
     </step>
<!-\-taroth 2010-06-01: if I understodd tonyj correctly, this step is only executed on the
      client, not on the server machine-\->
<!-\-<step>
      <para>
       Add the server certificate to the given client-side certificate
       database:
      </para>
<screen>/usr/bin/stap-authorize-server-cert </screen>
      <para>
       This creates the <filename>/etc/systemtap/ssl/</filename> directory,
       also containing the <filename>client</filename> subdirectory. That makes
       that server a trusted server for clients using that database.
      </para>
     </step>
-\->
     <step>
      <para>
       Start the compile server with:
      </para>
<screen>su -s /bin/sh - stap-server -c /usr/bin/stap-start-server</screen>
      <para>
       Upon first start of the compile server, this creates a client-side
       certificate database in the <literal>systemtap-server</literal>
       user's home directory (<filename>~/.systemtap/ssl/client</filename>)
       to which the server's certificate has now automatically been added.
       Thus, a server started by the user
       <systemitem class="username"
        >stap-server</systemitem> is
       automatically trusted by clients run by that user.
      </para>
     </step>
    </procedure>
    <procedure id="pro.tuning.stap.setup.server.root">
     <title>Running the Compile Server as &rootuser; User</title>
     <para>
      Compared to <xref linkend="pro.tuning.stap.setup.server.non-root"/>,
      this setup is much simpler but it has security implications.
     </para>
     <warning>
      <title>Security Risk</title>
      <para>
       In the following setup, the compile server certificate is stored in
       <filename>/etc/systemtap/ssl/server</filename>, together with the
       client-side database located at
       <filename>/etc/systemtap/ssl/client</filename>. As these files are
       accessible for anyone, anyone can run the
       <command>stap-client</command> command, thus potentially exposing
       kernel internal data structures and private user information.
      </para>
     </warning>
     <step>
      <para>
       Log in as &rootuser;.
      </para>
     </step>
     <step>
      <para>
       Create a &stap; certificate by executing the following command:
      </para>
<screen>/usr/bin/stap-gen-cert</screen>
      <para>
       You are prompted to set a password for the &stap; server certificate
       and key database.
      </para>
     </step>
     <step>
      <para>
       Enter a password and confirm it.
      </para>
      <para>
       The certificate (<filename>stap.cert</filename>) is generated. In
       contrast to the setup as non-&rootuser;, it is stored in a database
       located at <filename>/etc/systemtap/ssl/server</filename>.
      </para>
     </step>
     <step>
      <para>
       Start a &stap; server on the local host by using the following
       command:
      </para>
<screen>/usr/bin/stap-start-server</screen>
      <para>
       At the same time, a client-side certificate database is created at
       <filename>/etc/systemtap/ssl/client</filename>. The server
       certificate is automatically added to the client-side certificate
       database.
      </para>
     </step>
    </procedure>
    <para>
     The client-side certificate database created for &rootuser; is also the
     global client-side database for all clients on the host. Thus, a server
     started by root is automatically trusted by clients run by
     <emphasis>any</emphasis> user on that host: Any user can now compile
     kernel modules on the compile server using the
     <command>stap-client</command> command. For more information about the
     security implications, see the <citetitle>Safety and
     Security</citetitle> section of the <command>stap-server</command> man
     page.
    </para>
   </sect3>
   <sect3 id="sec.tuning.systemtap.setup.client">
    <title>Setting Up the Client</title>
    <para>
     To be able to invoke <command>stap-client</command> from another host,
     you need to copy the certificate that has been created on the server to
     the client and to authorize the compile server as trusted for the
     client. The location of the original server certificate to copy depends
     on how the &stap; compile server has been set up. For the authorization
     process you can choose to either authorize the compile server as
     trusted for <emphasis>all</emphasis> &stap; clients running on that
     machine or only for clients that are run by a
     <emphasis>specific</emphasis> user.
    </para>
    <procedure id="pro.tuning.stap.setup.">
     <step>
      <para>
       Log in to the client machine.
      </para>
     </step>
     <step>
      <para>
       If you have set up the compile server as non-&rootuser;, copy the
       server certificate to the client machine as follows:
      </para>
<screen>scp root@<replaceable>SERVERNAME</replaceable>:~stap-server/.systemtap/ssl/server/stap.cert \ /tmp/stap.cert</screen>
     </step>
     <step>
      <para>
       If you have set up the compile server as &rootuser;, copy the server
       certificate to the client machine as follows:
      </para>
<screen>scp root@<replaceable>SERVERNAME</replaceable>:/etc/systemtap/ssl/server/stap.cert /tmp/stap.cert</screen>
     </step>
     <step>
      <para>
       If you want to authorize the compile server as trusted for all &stap;
       clients running on that machine (no matter by which user), execute
       the following command as &rootuser;:
      </para>
<screen>/usr/bin/stap-authorize-server-cert /tmp/stap.cert</screen>
      <para>
       In this case, the server certificate will be added to the client-side
       certificate database
       (<filename>/etc/systemtap/ssl/client</filename>).
      </para>
     </step>
     <step>
      <para>
       If you want to authorize the compile server only as trusted for
       &stap; clients on that machine that are run by a specific user,
       execute the following command as regular user:
      </para>
<screen>/usr/bin/stap-authorize-server-cert /tmp/stap.cert</screen>
      <para>
       In that case, the server certificate will be added to the client-side
       certificate database for that user (
       <filename>~/.systemtap/ssl/client</filename>).
      </para>
     </step>
     <step>
      <para>
       Remove the copied certificate from the <filename>/tmp</filename>
       directory:
      </para>
<screen> rm /tmp/stap.cert</screen>
     </step>
    </procedure>
   </sect3>
   <sect3 id="sec.tuning.systemtap.setup.use">
    <title>Using the Client</title>
    <para>
     After you have set up the &stap; compile server and client as described
     in the previous sections, you can use the
     <command>stap-client</command> program. It is analogous to the
     <command>stap</command> front-end, except that it tries to find a
     compatible &stap; compile server on the local network. It then uses
     this server for compiling the &stap; script into a module, loading the
     kernel module and enabling the probes (passes 1-4 of a &stap; session).
     If requested, pass 5 actions are performed on the local host using
     <command>staprun</command>. For more information about a &stap; session
     and the individual passes, see
     <xref
     linkend="sec.tuning.systemtap.setup.classic"/>.
    </para>
    <note>
     <title>Executing <command>stap-client</command></title>
     <para>
      You can run <command>stap-client</command> either as &rootuser; or as
      non-&rootuser;. If run as non-&rootuser;, the underlying
      <command>staprun</command> command needs to be <literal>suid</literal>
      and the user executing <command>stap-client</command> must be a member
      of the <systemitem class="groupname"
       >stapdev</systemitem>
      group. For more information, refer to
      <xref
       linkend="sec.tuning.systemtap.concept.cmd"/>.
     </para>
    </note>
    <para>
     Usually, a running &stap; compile server on the local network
     advertises its presence using avahi and is automatically detected by
     the &stap; client. The following procedure illustrates how to make use
     of the &stap; client-server setup and covers the most common commands
     and options needed for that.
    </para>
    <procedure id="pro.tuning.stap.usage">
     <step>
      <para>
       To make sure that a compatible &stap; server is running on your local
       network, execute the following command on the &stap; client:
      </para>
<screen>stap-find-servers</screen>
      <para>
       This invokes avahi-browse to find servers. The details of any servers
       found are echoed to standard output. If this command does not return
       anything, no compatible &stap; server can be found on your network.
      </para>
     </step>
     <step>
      <para>
       In this case, log in to the compile server and run
      </para>
<screen>stap-start-server</screen>
      <para>
       This starts avahi-publish-service in the background. The server
       listens for connections on a random port and advertises its presence
       on the local network using the avahi daemon. If the server is started
       successfully, the process ID of the server is echoed to standard
       output.
      </para>
      <para>
       Note that <command>stap-start-server</command> does not work for the
       initial setup as described in
       <xref linkend="pro.tuning.stap.setup.server.root"/>, where
       <command>/usr/bin/stap-serverd</command> is used instead.
       <command>stap-start-server</command> puts the server in the
       background&mdash;thus, you would not see the prompt asking for the
       server certificate password.
      </para>
<screen>ps -ef | grep avahi</screen>
      <para>
       should now return an output similar to the following:
      </para>
<screen><?dbsuse-fo font-size="0.63em"?>avahi 3300     1  0 15:14 ?      00:00:00 avahi-daemon: running [linux-48zp.local]
root  4687  4655  0 18:03 ttyS0  00:00:00 avahi-publish-service Systemtap Compile Se
root  4700  4160  0 18:05 ttyS0  00:00:00 grep avahi</screen>
     </step>
     <step>
      <para>
       To run a simple test, execute the following command on the &stap;
       client:
      </para>
<screen>stap-client -e 'probe begin { printf("Hello"); exit(); }'</screen>
      <para>
       This compiles and executes a simple example on any compatible &stap;
       server found on the local network. If the test is successful, it
       prints <quote>Hello</quote> to standard output.
      </para>
     </step>
    </procedure>
    <para>
     Instead of using any compatible server found on the network, you can
     also determine which &stap; server to contact and use. To do so, run
     the <command>stap-client</command> command with the
     <option>&#8722;&#8722;server</option> option. It lets you specify the host name or
     IP address of the &stap; server, optionally also a port (which is
     useful fore connecting to non-local servers). For more information and
     details about the other available commands and options, refer to the
     <command>stap-server</command> and <command>stap-client</command> man
     pages.
    </para>
    <remark>taroth 2010-05-18: avoiding to mention the usage of &#8722;&#8722;unprivileged here as this is only
    in experimental state for stap version 1.0 (included in SLE 11 SP1) and adds additional layer of
    complexity...</remark>
<!-\- You might be asking why the client cert exists at all on the server, why
   not just run stap directly.  Because of &dash;&dash;unpriviliged

   # /usr/bin/stap-authorize-signing-cert ~stap-server/.systemtap/ssl/server/stap.cert

   or

   # /usr/bin/stap-authorize-signing-cert /etc/systemtap/ssl/server/stap.cert

   In both cases this creates the /etc/systemtap/staprun directory.

   Members of the group stapusr are limited (by stapdev) to scripts in
   /lib/modules/VERSION/systemtap (see stap man page).  You've mentioned this
   already in your doc. However, members of the stapusr group can run
   stap-client &dahs;&dash;unpriviliged and if the script doesn't use any priviliged
   features it will sign it (using what you generated when you executed
   /usr/bin/stap-authorize-signing-cert result) and stap will load it.

   See "UNPRIVILEGED USERS" in the stap-client man page.-\->
   </sect3>
   <sect3 id="sec.tuning.systemtap.setup.trouble">
    <title>Troubleshooting</title>
    <para>
     There are several things that can go wrong when using the &stap;
     client-server setup. If you have difficulties establishing a connection
     between &stap; client and server or running
     <command>stap-client</command>, proceed according to the following
     list.
    </para>
    <variablelist>
     <varlistentry>
      <term>Compatible &stap; Compile Server Available?</term>
      <listitem>
       <para>
        If <command>stap-client</command> reports that it is unable to find
        a server, check if a compatible &stap; compile server is available:
       </para>
<screen>stap-find-servers</screen>
       <para>
        If this command does not return anything, no compatible &stap;
        server can be found on your network.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>&stap; Compile Server Running?</term>
      <listitem>
       <para>
        To make sure that the &stap; compile server is running, log in to
        the server and run
       </para>
<screen>stap-server-start</screen>
       <para>
        If the server is started successfully, the process ID of the server
        is echoed to standard output.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Avahi Installed?</term>
      <listitem>
       <para>
        The &stap; client-server setup depends on avahi for automatically
        announcing the presence and configuration of any &stap; servers in
        the network and on client-side for automatically detecting a
        compatible server. As a consequence, the following packages are
        usually automatically installed together with the
        <systemitem class="resource"
        >systemtap-server</systemitem>
        and
        <systemitem class="resource"
        >systemtap-client</systemitem>
        packages:
       </para>
       <itemizedlist>
        <listitem>
         <para>
          <systemitem class="resource">avahi</systemitem>
         </para>
        </listitem>
        <listitem>
         <para>
          <systemitem class="resource">avahi-utils</systemitem>
         </para>
        </listitem>
       </itemizedlist>
       <para>
        Check if the packages are installed with
       </para>
<screen>rpm -qa | grep avahi</screen>
       <para>
        If not, install them with &yast; or Zypper.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Avahi Daemon Running?</term>
      <listitem>
       <para>
        Check if the avahi daemon is running:
       </para>
<screen>/etc/init.d/avahi-daemon status</screen>
       <para>
        If not, start it with
       </para>
<screen>/etc/init.d/avahi-daemon start</screen>
       <para>
        Also check if the avahi daemon was configured to be started
        automatically at runlevels 3 and 5:
       <remark>taroth 2014-03-07: systemd</remark></para>
<screen>chkconfig -l avahi-daemon</screen>
       <para>
        This should return the following output:
       </para>
<screen>avahi-daemon              0:off  1:off  2:off  3:on   4:off  5:on   6:off</screen>
       <para>
        If not, configure this option with
        <remark>taroth 2014-03-07: systemd</remark> </para>
<screen>chkconfig avahi-daemon 35</screen>
       <para/>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Virtual Machine: Bridged Network?</term>
      <listitem>
       <para>
        If you are running &stap; in a virtual machine setup, make sure the
        network has been bridged, otherwise broadcasting via avahi will not
        work.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Certificate Not Found?</term>
      <listitem>
       <para>
        If running an <command>stap-client</command> command fails because
        the certificate database was not found, check if you have set up the
        &stap; client correctly. For details, refer to
        <xref linkend="sec.tuning.systemtap.setup.client"/>.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>-->
 </sect1>
 <sect1 xml:id="sec.tuning.systemtap.syntax">
  <title>スクリプトの文法</title>

  <para>&stap; のスクリプトは、下記に示す 2 つのコンポーネントから構成されています:</para>

  <variablelist>
   <varlistentry>
    <term><xref linkend="sec.tuning.systemtap.syntax.events" xrefstyle="select:title"/></term>
    <listitem>
     <para>カーネル内のどのイベントでスクリプトを実行するのかを表わしている箇所です。特定の関数内に入ったタイミングや特定の関数を出たタイミング、もしくはタイマーの経過後やセッションの開始および停止などに設定することができます。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><xref linkend="sec.tuning.systemtap.syntax.handlers" xrefstyle="select:title"/></term>
    <listitem>
     <para>特定のイベントが発生した際に実行すべきスクリプトを表わしている箇所です。これは通常、イベント内の情報を抽出したり、それらを内部の変数に格納したり、結果を出力したりする処理を行ないます。</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>イベントとそれに対応するハンドラをまとめて、 <literal>プローブ</literal> と呼びます。 &stap; のイベントは <literal>プローブポイント</literal> 、対応するハンドラは <literal>プローブボディ</literal> とも呼びます。</para>

  <para>コメントは &stap; スクリプト内の任意の箇所に配置することができます。コメントの書式は、 <literal>#</literal>, <literal>/* */</literal> , <literal>//</literal> のいずれかです。</para>

  <sect2 xml:id="sec.tuning.systemtap.syntax.probe">
   <title>プローブの書式</title>
   <para>&stap; のスクリプトには複数のプローブを設定することができます。プローブは下記の書式で作成します:</para>
<screen>probe <replaceable>イベント名</replaceable> {<replaceable>ステートメント</replaceable>}</screen>
   <para>それぞれのプローブには対応するステートメントブロックを設定します。ステートメントブロックは <literal>{ }</literal> で括らなければならず、かつイベントごとに実行すべきステートメントを含むものとします。</para>
   <example xml:id="ex.tuning.stap.simple">
    <title>シンプルな &stap; スクリプト</title>
    <para>下記はシンプルな &stap; スクリプトの例です。</para>
<screen>probe<co xml:id="co.tuning.stap.probe"/> begin<co xml:id="co.tuning.stap.event.begin"/>
{<co xml:id="co.tuning.stap.handler.start"/>
   printf<co xml:id="co.tuning.stap.handler.function.printf"/> ("hello world
")<co xml:id="co.tuning.stap.handler.string"/>
   exit ()<co xml:id="co.tuning.stap.handler.function.exit"/>
}<co xml:id="co.tuning.stap.handler.end"/></screen>
    <calloutlist>
     <callout arearefs="co.tuning.stap.probe">
      <para>プローブの開始位置です。</para>
     </callout>
     <callout arearefs="co.tuning.stap.event.begin">
      <para>イベント <literal>begin</literal> (&stap; セッションの開始) の指定です。</para>
     </callout>
     <callout arearefs="co.tuning.stap.handler.start">
      <para><literal>{</literal> で示されているとおり、ハンドラ定義の開始位置です。</para>
     </callout>
     <callout arearefs="co.tuning.stap.handler.function.printf">
      <para>ハンドラ内での最初の関数です。この例では <literal>printf</literal> 関数を使用しています。</para>
     </callout>
     <callout arearefs="co.tuning.stap.handler.string">
      <para><literal>printf</literal> 関数で出力すべき文字列を指定しています。末尾には改行 ( <literal>/n</literal> ) が書かれています。</para>
     </callout>
     <callout arearefs="co.tuning.stap.handler.function.exit">
      <para>ハンドラ内での 2 つめの関数です。この例では <literal>exit()</literal> 関数を使用しています。なお、 &stap; スクリプトは <literal>exit()</literal> 関数を実行するまでは、動作し続けることに注意してください。この関数を実行する前にスクリプトの実行を停止したい場合は、 <keycombo> <keycap function="control"/> <keycap>C</keycap> </keycombo> を押します。</para>
     </callout>
     <callout arearefs="co.tuning.stap.handler.end">
      <para><literal>}</literal> で示されているとおり、ハンドラ定義の終了位置です。 </para>
     </callout>
    </calloutlist>
    <para>イベント <literal>begin</literal> <xref linkend="co.tuning.stap.event.begin" xrefstyle="select:label nopage"/> (&stap; セッションの開始) が発生すると、 <literal>{ }</literal> で括られたハンドラを実行します。ここでは、 <literal>printf</literal> 関数 <xref linkend="co.tuning.stap.handler.function.printf" xrefstyle="select:label nopage"/> になります。この場合、 <literal>hello world</literal> という文字列に加えて改行 <xref linkend="co.tuning.stap.handler.string" xrefstyle="select:label nopage"/> を出力しています。出力が終わると、スクリプトは終了します。</para>
   </example>
   <para>ステートメント内に複数の記述が存在する場合、 &stap; ではそれらを順次実行します。言い換えると、複数のステートメントを記述するにあたって、特殊な区切り文字や終端などを入れる必要はありません。 &stap; 内では一般に、ステートメントブロックは C プログラミング言語と同じ書式になっています。</para>
  </sect2>

  <sect2 xml:id="sec.tuning.systemtap.syntax.events">
   <title>&stap; イベント (プローブポイント)</title>
   <para>&stap; にはいくつかの内蔵イベントが用意されています。</para>
   <para>一般的なイベント名はドットで区切った <!-- NOTE: to understand easily; DNS-like --> DNS のような命名体系になっています。この仕組みにより、名前をツリー構造で管理できるようになっています。また、ドット区切り内の各コンポーネントには、文字列や数値によるパラメータを設定できるようになっていて、見た目では関数のような表現になっています。また、コンポーネントに <literal>*</literal> を指定した場合、複数のプローブポイントにマッチするようなイベント名にすることができます。また、プローブポイントの後には <literal>?</literal> が付けられることもあります。この場合、それが任意指定のものであることを示し、展開に失敗した場合もエラーが無視されるようになります。 <remark>tonyj 2010-05-8: Maybe an example? There are lots of them in syscalls.stp tapset (/usr/share/ systemptap/tapset/syscalls.stp). - taroth 2010-05-10: for next revision, no time left now</remark> また、プローブポイントの後ろに <literal>!</literal> を付けた場合、任意指定でかつ十分な存在であることを示します。</para>
   <para>&stap; では 1 つのプローブに対して複数のイベントを設定することができます。複数のイベントを指定する場合、イベント間は ( <literal>,</literal> ) で区切ります。また、 1 つのプローブに対して複数のイベントが指定された場合、 &stap; はいずれかのイベントが発生した場合に、指定のハンドラを実行することになります。</para>
   <para>一般的には、イベントは下記のような分類に分けることができます:</para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>同期型イベント: 任意のプロセスが、カーネルコード内の特定の箇所に達した場合に発生するイベントです。これは他のイベントに対して参照ポイント (インストラクションアドレス) を与え、ここから多くのコンテキスト情報を取得できるようになります。</para>
     <para>同期型イベントの例として、 <literal>vfs.<replaceable>ファイル操作</replaceable></literal> があります。これは仮想ファイルシステム (Virtual File System; VFS) 内の <replaceable>ファイル操作</replaceable> イベントを表わすもので、たとえば <xref linkend="sec.tuning.systemtap.setup"/>  では、 <literal>read</literal> が <replaceable>ファイル操作</replaceable> の箇所にあたります。 <!--taroth 2011-10-17: sysemtap 1.5, original linkend--> <!-- <xref linkend="sec.tuning.systemtap.setup.classic"/>--> <!--If you also want to monitor the exit of the <replaceable>FILE_OPERATION</replaceable> operation, append a <literal>.return</literal> to the event (for example, <literal>vfs.read.return</literal>).--></para>
    </listitem>
    <listitem>
     <para>非同期型イベント: 特定のインストラクションやカーネルコード内の位置に結びつかないイベントです。このようなプローブポイントとしては、カウンターやタイマーなどの構造があります。</para>
     <para>非同期型イベントの例としては、 <literal>begin</literal>  (&stap; セッションの開始) や <literal>end</literal> (&stap; セッションの終了) のほか、タイマーイベントがあります。タイマーイベントは定期的に実行すべきハンドラを指定するためのもので、たとえば <literal>example timer.s(<replaceable>秒</replaceable>)</literal> や <literal>timer.ms(<replaceable>ミリ秒</replaceable>)</literal> のように指定します。</para>
     <para>タイマーイベントは、他のプローブと併用することで、定期的なデータ更新を行なうことができるようになるほか、時間が経過するたびに変化していくような情報を追跡することができるようになります。</para>
    </listitem>
   </itemizedlist>
   <example xml:id="ex.tuning.stap.async">
    <title>タイマーイベントのプローブ</title>
    <para>たとえば下記のようなプローブを設定すると、 <quote>hello world</quote> を 4 秒間隔で出力します:</para>
<screen>probe timer.s(4)
{
   printf("hello world
")
}</screen>
   </example>
   <para>対応するイベントの詳細について、詳しくは <command>stapprobes</command> のマニュアルページをお読みください。マニュアルページ内の <citetitle>See Also</citetitle> セクションには、特定のサブシステムやコンポーネントに対するイベントを含む、他のマニュアルページへのリンクが書かれています。</para>
  </sect2>

  <sect2 xml:id="sec.tuning.systemtap.syntax.handlers">
   <title>&stap; ハンドラ (プローブボディ)</title>
   <para>&stap; イベントには対応するハンドラが指定されます。ハンドラ内では、ステートメントブロックから構成される処理を記述します。</para>
   <sect3 xml:id="sec.tuning.systemtap.syntax.handlers.functions">
    <title>関数</title>
    <para>複数のプローブ内で同じステートメントを実行する必要がある場合は、それらの共通部分を関数として取り出して、再利用しやすくすることをお勧めします。関数はキーワード <literal>function</literal> に続いて関数名を指定することで、定義を行なうことができます。また、任意の数の文字列や数値 (いずれも値渡し) をパラメータとして取ることができ、返り値は単一の文字列もしくは数値を設定することができます。</para>
<screen>function <replaceable>関数名</replaceable>(<replaceable>パラメータ</replaceable>) {<replaceable>ステートメント</replaceable>}
probe <replaceable>イベント</replaceable> {<replaceable>関数名</replaceable>(<replaceable>パラメータ</replaceable>)}</screen>
    <para>上記の例では、 <replaceable>イベント</replaceable> のハンドラが実行されると、 <replaceable>関数名</replaceable> の関数が実行されます。 <replaceable>パラメータ</replaceable> は任意指定のもので、関数に渡すパラメータを指定します。</para>
    <para>関数はスクリプト内の任意の場所に記述することができます。</para>
    <para>よく使用する関数の例として、既に <xref linkend="ex.tuning.stap.simple"/> で紹介を行なっている <literal>printf</literal> 関数があります。この関数は書式を指定してデータを出力するための関数で、書式ではどれだけの数のパラメータを出力するのか、およびどのように整形して出力するのかを指定します。書式文字列は二重引用符で括り、書式指定は <literal>%</literal> 文字で書き始めます。</para>
    <para>どのような書式指定文字列を使用するのかは、そのパラメータに依存して決まります。書式指定文字列は複数個指定することができ、その際にはパラメータをカンマ区切りで指定します。</para>
    <example xml:id="ex.tuning.stap.printf.formatspec">
     <title>書式指定を伴う <literal>printf</literal> 関数</title>
<screen>printf ("<co xml:id="co.tuning.stap.formatstring.start"/>%s<co xml:id="co.tuning.stap.string.spec"/>(%d<co xml:id="co.tuning.stap.int.spec"/>) open
<co xml:id="co.tuning.stap.formatstring.end"/>", execname(), pid())</screen>
     <calloutlist>
      <callout arearefs="co.tuning.stap.formatstring.start">
       <para><literal>"</literal> で示されているとおり、書式指定文字列の開始位置です。</para>
      </callout>
      <callout arearefs="co.tuning.stap.string.spec">
       <para>文字列の書式指定です。</para>
      </callout>
      <callout arearefs="co.tuning.stap.int.spec">
       <para>整数の書式指定です。</para>
      </callout>
      <callout arearefs="co.tuning.stap.formatstring.end">
       <para><literal>"</literal> で示されているとおり、書式指定文字列の終了位置です。</para>
      </callout>
     </calloutlist>
    </example>
    <para>上記の例では、実行ファイル名 ( <literal>execname()</literal> ) を文字列で、プロセス ID ( <literal>pid()</literal> ) を括弧内に整数で、それぞれ出力する指定になっています。その後ろは固定でスペースを入れ、 <literal>open</literal> と出力して改行を行ないます:</para>
<screen>[...]
vmware-guestd(2206) open
hald(2360) open
[...]
   </screen>
    <para><xref linkend="ex.tuning.stap.printf.formatspec"/> で使用している <literal>execname()</literal> や <literal>pid()</literal> のほかにも、 <literal>printf</literal> のパラメータとしては様々な関数を指定することができます。</para>
    <para>&stap; で最もよく使用される関数は下記のとおりです:</para>
    <variablelist>
     <varlistentry>
      <term>tid()</term>
      <listitem>
       <para>現在のスレッドの ID を返します。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>pid()</term>
      <listitem>
       <para>現在のスレッドのプロセス ID を返します。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>uid()</term>
      <listitem>
       <para>現在のユーザのユーザ ID を返します。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>cpu()</term>
      <listitem>
       <para>現在の CPU 番号を返します。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>execname()</term>
      <listitem>
       <para>現在のプロセスの名前を返します。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>gettimeofday_s()</term>
      <listitem>
       <para>Unix エポック (1970 年 1 月 1 日) からの経過秒数を返します。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>ctime()</term>
      <listitem>
       <para>時刻を文字列に変換します。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>pp()</term>
      <listitem>
       <para>現在処理しているプローブポイントの文字列表現を返します。</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>thread_indent()</term>
      <listitem>
       <para>出力結果を読みやすくするための便利な関数です。これは各スレッド ( <literal>tid()</literal> ) に対して (内部的な) インデントカウンタを保存するものです。この関数には 1 つだけパラメータを指定しますが、このパラメータはインデント差 (スレッドのインデントカウンタの増減値) を指定します。返り値は一般的なトレースデータと、インデントカウンタの値に対応した数のスペースを含む文字列になります。一般的なトレースデータには、タイムスタンプ (スレッドの初期インデントからの経過マイクロ秒) のほか、プロセス名とスレッド ID それ自身が含まれます。これにより、どの関数を誰が呼び出したのか、およびそれにどれだけの時間を要したのかがわかるようになっています。</para>
       <para><!-- NOTE: changed to more explanatory thing --> システムコールの開始と終了は、見た目ではわかりにくくなってしまうことがあります。たとえば一方のシステムコールが他方のシステムコールを呼び出していて、そのいずれにもプローブを設定しているような場合、開始と終了が入れ子になってしまい、出力がわかりにくくなってしまいます。このインデントカウンタの仕組みを使用することで、入れ子の形で呼び出されているシステムコールの出力を字下げ (インデント) して、読みやすくする効果を生み出します。 <literal>thread_indent()</literal> を利用した &stap; スクリプトとその出力例について、詳しくは <link xlink:href="http://sourceware.org/systemtap/tutorial/Tracing.html#fig:socket-trace"/> にある <citetitle>&stap; Tutorial</citetitle> (英語) をお読みください。</para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>提供されている &stap; 関数に関する詳細な情報については、 <command>stapfuncs</command> のマニュアルページをお読みください。</para>
   </sect3>
   <sect3 xml:id="sec.tuning.systemtap.syntax.handlers.others">
    <title>その他の基本構造</title>
    <para>関数のほかに、 &stap; ハンドラ内ではその他の一般的な構造を作成することができます。具体的には変数や条件分岐 (<literal>if</literal> / <literal>else</literal>) 、 <literal>while</literal> ループや <literal>for</literal> ループ、そして配列やコマンドラインパラメータなどがあります。</para>
    <sect4 xml:id="sec.tuning.systemtap.syntax.handlers.others.variables">
     <title>変数</title>
     <para>変数はスクリプト内の任意の場所に定義することができます。変数を定義したい場合は、単純に名前を選んで関数や表現を代入するだけです:</para>
<screen>foo = gettimeofday( )</screen>
     <para>代入した後は、任意の箇所で変数を使用するだけです。 &stap; では、変数の代入元のデータ型 (文字列もしくは数値) に従って、変数のデータ型を自動継承します。何らかの矛盾が発生した場合、それらはエラーとして報告されます。上記の例では、 <literal>foo</literal> は代入元に従って数値型として設定され、 <literal>printf()</literal> 関数の整数書式指定子 ( <literal>%d</literal> ) で出力できる変数になります。</para>
     <para>ただし、既定では変数は全てプローブ内ローカルになります。プローブ内ローカルであることから、変数はハンドラの実行のたびに初期化され、使用され、廃棄されることになります。プローブ間で変数を共有したい場合は、グローバル変数としてスクリプト内に定義してください。グローバル変数を定義するには、プローブの外で <literal>global</literal> キーワードを指定して宣言します:</para>
     <example>
      <title>グローバル変数の使用</title>
<screen>global count_jiffies, count_ms
probe timer.jiffies(100) { count_jiffies ++ }
probe timer.ms(100) { count_ms ++ }
probe timer.ms(12345)
{
  hz=(1000*count_jiffies) / count_ms
  printf ("jiffies:ms ratio %d:%d =&gt; CONFIG_HZ=%d
",
    count_jiffies, count_ms, hz)
  exit ()
  }</screen>
      <para>上記の例では、 jiffies とミリ秒によるタイマーを利用して、カーネルの CONFIG_HZ の設定を計算しています。 jiffy/jiffies はシステムのタイマー割り込みの回数を数えるもので、プロセッサのクロック周波数によって間隔が変化するものであることから、これを実時間で割ることで、クロック周波数を計算しています。ここでの <literal>global</literal> 定義は <literal>count_jiffies</literal> と <literal>count_ms</literal> ですが、これらはそれぞれのタイマー値を保存しておくためのものです。また、 <literal>++</literal> という演算子は、変数の値を <literal>1</literal> だけ足す意味です。</para>
     </example>
    </sect4>
    <sect4 xml:id="sec.tuning.systemtap.syntax.handlers.others.conditional">
     <title>条件分岐</title>
     <para>&stap; スクリプト内で使用できる条件分岐には、いくつかのものがあります。一般的に最もよく使用されるものを下記に示します:</para>
     <variablelist>
      <varlistentry>
       <term>If/Else ステートメント</term>
       <listitem>
        <para>下記のように記述します:</para>
<screen>if (<replaceable>条件</replaceable>)<co xml:id="co.tuning.systemtap.cond.if"/><replaceable>ステートメント_1</replaceable><co xml:id="co.tuning.systemtap.cond.if.statement1"/>
else<co xml:id="co.tuning.systemtap.cond.else"/><replaceable>ステートメント_2</replaceable><co xml:id="co.tuning.systemtap.cond.if.statement2"/></screen>
        <para><literal>if</literal> ステートメントは、整数表現がゼロであるかどうかを調べます。 <xref linkend="co.tuning.systemtap.cond.if" xrefstyle="select:label nopage"/> の結果がゼロ以外であった場合、最初のステートメント <xref linkend="co.tuning.systemtap.cond.if.statement1" xrefstyle="select:label nopage"/> が実行されます。逆に、ゼロであった場合は、 2 番目のステートメント <xref linkend="co.tuning.systemtap.cond.if.statement2" xrefstyle="select:label nopage"/> が実行されます。 else 句 ( <xref linkend="co.tuning.systemtap.cond.else" xrefstyle="select:label nopage"/> および <xref linkend="co.tuning.systemtap.cond.if.statement2" xrefstyle="select:label nopage"/> ) は任意指定で、指定しても指定しなくてもかまいません。また、 <xref linkend="co.tuning.systemtap.cond.if.statement1" xrefstyle="select:label nopage"/> と <xref linkend="co.tuning.systemtap.cond.if.statement2" xrefstyle="select:label nopage"/> には、ステートメントブロックを指定することもできます。</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>While ループ</term>
       <listitem>
        <para>下記のように記述します:</para>
<screen>while (<replaceable>条件</replaceable>)<co xml:id="co.tuning.systemtap.cond.while"/><replaceable>ステートメント</replaceable><co xml:id="co.tuning.systemtap.cond.while.statement"/></screen>
        <para><replaceable>条件</replaceable> がゼロ以外であった場合、 <xref linkend="co.tuning.systemtap.cond.while.statement" xrefstyle="select:label nopage"/> を実行します。 <xref linkend="co.tuning.systemtap.cond.while.statement" xrefstyle="select:label nopage"/> はステートメントブロックでもかまいません。最終的に <replaceable>条件</replaceable> がゼロになるまで、繰り返し実行します。</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>For ループ</term>
       <listitem>
        <para><literal>while</literal> ループのショートカットとして規定されているもので、下記のように記述します:</para>
<screen>for (<replaceable>初期化</replaceable><co xml:id="co.tuning.systemtap.cond.for.init"/>; <replaceable>条件</replaceable><co xml:id="co.tuning.systemtap.cond.for.cond"/>; <replaceable>増加処理</replaceable><co xml:id="co.tuning.systemtap.cond.for.increment"/>) <replaceable>ステートメント</replaceable></screen>
        <para><xref linkend="co.tuning.systemtap.cond.for.init" xrefstyle="select:label nopage"/> に記述したステートメントはカウンタの初期化用に使用すべき箇所で、ループの開始前に実行されます。ループは <xref linkend="co.tuning.systemtap.cond.for.cond" xrefstyle="select:label nopage"/> のステートメントの結果が false になるまで繰り返されます (判断処理はループの処理前に行なわれます) 。また、 <xref linkend="co.tuning.systemtap.cond.for.increment" xrefstyle="select:label nopage"/> はループカウンタの増加処理で使用すべき箇所です。こちらはループ処理後に実行されます。</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>比較演算子</term>
       <listitem>
        <para>条件の指定では、下記の演算子を使用することができます:</para>
        <formalpara>
         <title>==:</title>
         <para>等しいかどうか</para>
        </formalpara>
        <formalpara>
         <title>!=:</title>
         <para>等しくないかどうか</para>
        </formalpara>
        <formalpara>
         <title>&gt;=:</title>
         <para>前のほうが後より大きいかどうか、もしくは等しいかどうか</para>
        </formalpara>
        <formalpara>
         <title>&lt;=:</title>
         <para>前のほうが後より小さいかどうか、もしくは等しいかどうか</para>
        </formalpara>
       </listitem>
      </varlistentry>
     </variablelist>
    </sect4>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.tuning.systemtap.example">
  <title>スクリプト例</title>

  <para><systemitem class="resource">systemtap-docs</systemitem> パッケージをインストールしていれば、 <filename>/usr/share/doc/packages/systemtap/examples</filename> 内に &stap; のスクリプト例がいくつか用意されています。</para>

  <para>本章では、 <filename>/usr/share/doc/packages/systemtap/examples/network/tcp_connections.stp</filename> にあるシンプルなスクリプト例を詳しく説明します:</para>

  <example>
   <title><literal>tcp_connections.stp</literal> での着信 TCP 接続の監視</title>
<screen>#! /usr/bin/env stap

probe begin {
  printf("%6s %16s %6s %6s %16s
",
         "UID", "CMD", "PID", "PORT", "IP_SOURCE")
}

probe kernel.function("tcp_accept").return?,
      kernel.function("inet_csk_accept").return? {
  sock = $return
  if (sock != 0)
    printf("%6d %16s %6d %6d %16s
", uid(), execname(), pid(),
           inet_get_local_port(sock), inet_get_ip_source(sock))
}</screen>
  </example>

  <para>この &stap; スクリプトは着信側の TCP 接続を監視して、リアルタイムに望まない接続を識別する仕組みを提供するものです。それぞれコンピュータが受け入れた着信側 TCP 接続に対して、下記のような情報を表示します:</para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>ユーザ ID ( <literal>UID</literal> )</para>
   </listitem>
   <listitem>
    <para>接続を受け付けたコマンド ( <literal>CMD</literal> )</para>
   </listitem>
   <listitem>
    <para>コマンドのプロセス ID ( <literal>PID</literal> )</para>
   </listitem>
   <listitem>
    <para>接続に使用しているポート ( <literal>PORT</literal> )</para>
   </listitem>
   <listitem>
    <para>TCP 接続の発信元 ( <literal>IP_SOUCE</literal> )</para>
   </listitem>
  </itemizedlist>

  <para>スクリプトを実行するには、下記のように入力して実行します:</para>

<screen>stap&nbsp;/usr/share/doc/packages/systemtap/examples/network/tcp_connections.stp</screen>

  <para>すると、画面内に出力が表示されるようになります。スクリプトを手作業で停止するには、 <keycombo> <keycap function="control"/> <keycap>C</keycap> </keycombo> を押します。</para>
 </sect1>
<!--taroth 2013-11-22: http://doccomments.provo.novell.com/admin/viewcomment/14466-->
 <sect1 xml:id="sec.tuning.systemtap.userspace">
  <title>ユーザスペースプローブ</title>

  <para><remark>taroth 2013-12-05: this will need adjustment for SLE 12 where user-space probes will use uprobes/uretprobes instead (which are in mainline) - according to tonyj everything except itrace is supposed to work</remark> DTrace のようにユーザスペースで動作するアプリケーションをデバッグする目的で、 &productname; &productnumber; では、 &stap; でユーザスペースのプローブを行なうことができます。ユーザスペースのプローブでは、アプリケーション内の任意の場所にプローブポイントを設置することができます。これにより、 &stap; はカーネルスペースとユーザスペースの両方を調査できることになり、結果としてシステム全体を調査できるようになっています。</para>

  <para>ユーザスペースのプローブを設置する際に必要となる utrace インフラストラクチャと uprobe カーネルモジュールを取得するには、 <xref linkend="sec.tuning.systemtap.setup"/> に示されているパッケージに加え、 <systemitem class="resource">kernel-trace</systemitem> パッケージをインストールする必要があります。</para>

  <para><command>utrace</command> はユーザスペースの処理を制御するためのフレームワークを実装するものです。様々なトレーシング <quote>エンジン</quote> で使用することのできるインターフェイスを提供し、これ自身は読み込み可能なカーネルモジュールとして提供されます。エンジンは特定のイベントに対してコールバック関数を登録し、トレース対象のスレッドに結びつけられます。コールバックはカーネル内の <quote>安全な</quote> 場所から行なわれるため、関数が実行できる処理の種類に大きな余裕ができることになります。 utrace では、たとえばシステムコールの開始と終了、 fork() やタスクに送信されるシグナルなど、様々なイベントを監視することができます。 utrace のインフラストラクチャについて、詳しくは <link xlink:href="http://sourceware.org/systemtap/wiki/utrace"/> (英語) をお読みください。</para>

  <para>&stap; では、ユーザスペースプロセス内での関数の開始および終了のプローブに対応しているほか、コード内にマーカーを設定してプローブしたり、特定のプロセス内イベントを監視したりすることもできます。</para>

  <para>現在実行しているカーネルが utrace に対応しているかどうかを調べるには、下記のコマンドを実行します:</para>

<screen>&prompt.sudo;grep CONFIG_UTRACE /boot/config-`uname -r`</screen>

  <para>ユーザスペースのプローブについて、詳しくは <link xlink:href="https://sourceware.org/systemtap/SystemTap_Beginners_Guide/userspace-probing.html"/> (英語) をお読みください。</para>
 </sect1>
 <sect1 xml:id="sec.tuning.systemtap.more">
  <title>さらなる情報</title>

  <para>本章では、 &stap; の概要部までしか言及できていません。 &stap; に関する詳細な情報を得たい場合は、それぞれ下記を参照してください (英語のみの提供である場合もあります):</para>

  <variablelist>
   <varlistentry>
    <term><link xlink:href="http://sourceware.org/systemtap/"/></term>
    <listitem>
     <para>&stap; プロジェクトの Web ページです。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><link xlink:href="http://sourceware.org/systemtap/wiki/"/></term>
    <listitem>
     <para>&stap; に関する便利な情報を数多く集めているサイトです。ユーザに対する詳しい説明から開発者向けの資料のほか、他のツールとの比較やレビュー、よくある質問とその回答 (FAQ) やヒントなどが書かれています。また、 &stap; スクリプトの例もあり、使用例や &stap; に関する直近の対話、ペーパーなども用意されています。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><link xlink:href="http://sourceware.org/systemtap/documentation.html"/></term>
    <listitem>
     <para>PDF および HTML 形式で、 <citetitle>&stap; Tutorial</citetitle> (&stap; チュートリアル), <citetitle>&stap; Beginner's Guide</citetitle> (&stap; 初心者ガイド), <citetitle>Tapset Developer's Guide</citetitle> (タップセット開発者ガイド), <citetitle>&stap; Language Reference</citetitle> (&stap; 言語リファレンス) などが用意されています。</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>なお、 &stap; の言語リファレンスとチュートリアルについては、 <filename>/usr/share/doc/packages/systemtap</filename> ディレクトリ内にも用意されています。また、スクリプトの例については、上記の <filename>example</filename> サブディレクトリをご覧ください。</para>

<!--http://sourceware.org/systemtap/wiki/
    http://en.wikipedia.org/wiki/Systemtap
    http://sourceware.org/systemtap/
    http://sourceware.org/systemtap/documentation.html
    http://sourceware.org/systemtap/langref/-->
 </sect1>
</chapter>
