<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter [
<!ENTITY % entities SYSTEM "generic-entities.ent">
%entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="ja" xml:id="cha-ssh">

 <title>OpenSSH によるネットワーク操作の機密保持</title>
 <info>
  <abstract>
   <para>OpenSSH は &productname; に同梱される SSH (secure shell) 実装で、遠隔からの管理やファイル転送、機密を保持できないプロトコルへの機密トンネル設定など、さまざまな機能を提供するソフトウエアです。 SSH は 2 つのホスト間での認証を含む全通信を暗号化しますので、盗聴や接続の乗っ取りなどの被害から通信を保護することができます。本章では基本的な操作のほか、ホスト鍵の切り替えや証明書認証など、大規模展開向けに便利な機能を説明しています。</para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker>
   </dm:bugtracker>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>

 <sect1 xml:id="sec-ssh-overview">
  <title>OpenSSH の概要</title>
  <para>SSH はエンドツーエンドで通信を保護するためのネットワークプロトコルで、お使いのネットワーク内同士だけでなく、外部のネットワークとの通信も保護することができます。 SSH で他のコンピュータに接続するには、接続先でのユーザ名と適切な認証手段を設定する必要があります。</para>
  <para>SSH はクライアント／サーバ型のプロトコルです。他のホストからの接続を受け付けるには <systemitem class="daemon">sshd</systemitem> デーモンを動作させておく必要があります。また、各ホストで動作する <systemitem class="daemon">sshd</systemitem> にはそれぞれ独自の設定を行うことができますので、アクセス可能なユーザを制限したり、許可する認証方式を制限したりすることもできるようになっています。</para>
   <para>認証と暗号化の機能は暗号鍵対によって行われます。それぞれの鍵対には公開鍵と機密鍵という 2 つの鍵が存在し、公開鍵は暗号化を、機密鍵は暗号の復号化を行うために使用します。また、機密鍵がきちんと保護されている限り、公開鍵は誰にでも配布してかまいません。機密鍵が漏洩してしまうと、機密鍵の元の所有者になりすまして暗号化した通信を行うことができるようになってしまいます。</para>
  <para>SSH ではサーバとクライアントの双方が互いに認証しなければならない仕組みにより、強力な保護を提供しています。クライアントが SSH での接続を開始すると、サーバは自身の持つ公開鍵を提示します。示された公開鍵が既知のものであった場合 (クライアント側の <filename>~/.ssh/known_hosts</filename> 内に保存されます) 、クライアントはサーバを信頼してそのまま処理を続行します。既知のものでなかった場合は、サーバを信頼して良いかどうか、下記のようにしてユーザに尋ねます:</para>
  <screen>The authenticity of host '192.168.22.219 (192.168.22.219)'
   can't be established. ECDSA key fingerprint is
   SHA256:yXf6pjV26N0fegvEYIt3HgG95s3Q1X6WYRhtHLF99pUo.
   Are you sure you want to continue connecting (yes/no/[fingerprint])?
  </screen>
  <para>ユーザは <literal>yes</literal> (このまま接続を続ける) または <literal>no</literal> (接続を中止する) のいずれかを入力できるほか、比較のために鍵の指紋 (fingerprint) そのものを入力することもできます。</para>
  <note>
   <title>ホスト鍵の指紋 (fingerprint) について</title>
   <para>ホスト鍵の指紋 (fingerprint) を接続するユーザに配布することで、接続時にホスト鍵が正しいかどうかを確認できるようになります。上記の表示で指紋そのものを入力すると、 <command>ssh</command> 側で指紋が一致しているかどうかを確認し、一致した場合にのみ接続を続けることができるようになります。これにより、目視で比較するよりずっと信頼性の高い確認を行うことができます。</para>
   <para>これは、ユーザに検証を委ねても、セキュリティという観点では信頼性が低いためです。なお、指紋が一致していなかった場合でも、再度 <literal>yes</literal> を入力するか、表示された指紋をそのまま貼り付けることで、接続を続行することができます。また、より強力な保護として、証明書認証を使用する方法もあります。これは大規模向けの認証機構となるほか、上記のようなユーザへの手間を減らすことにもつながります (詳しくは <xref linkend="sec-ssh-certificate-auth"/> をお読みください) 。</para>
  </note>
   <para>接続先ホストの公開鍵が変更された場合、下記のようにセキュリティ警告を表示して接続が拒否されます:</para>
  <screen>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ECDSA key sent by the remote host is
SHA256:keNu/rJFWmpQu9B0SjIuo8NLjbeDY/x3Tktpl7oDJqo.
Please contact your system administrator.
Add correct host key in /home/geeko/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in /home/geeko/.ssh/known_hosts:210
You can use following command to remove the offending key:
ssh-keygen -R 192.168.121.219 -f /home/geeko/.ssh/known_hosts
ECDSA host key for 192.168.121.219 has changed and you have requested strict
checking.
Host key verification failed.</screen>
  <para>このような場合、警告メッセージを表示せずに接続を行わせたい場合は、 <filename>~/.ssh/known_hosts</filename> 内にある古い公開鍵を削除してから再度接続を行ってください。これにより、新しい鍵を受け付けるかどうかの確認が表示されるようになります。 <!-- see TODO and TODO for key management methods that do not require users to verify or accept new host keys --></para>
  <para><package>openssh</package> パッケージにはサーバとクライアントのほか、ファイル転送コマンドといくつかのユーティリティが含まれています。</para>
  <para>OpenSSH では下記のような認証方式に対応しています:</para>
  <variablelist>
   <varlistentry>
    <term>パスワード認証</term>
    <listitem>
     <para>ユーザ名とパスワードで認証する方式です。この方式は、 SSH のセッションをどのマシンからでも受け付けることができますので、最も単純で柔軟な認証方式です。ただし、パスワードクラッキングには弱く、キーロガーなどによる窃取にも弱いため、機密性は低くなります。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>公開鍵認証</term>
    <listitem>
     <para>ユーザ名とパスワードではなく、個人単位で鍵を設定して認証を行う方式です。公開鍵に対応する機密鍵を持つホストからしかログインできない仕組みであるため、パスワード認証に比べると柔軟性が落ちますが、パスワードクラッキングに強く、キーロガーなどによる窃取も回避できますので、パスワード認証よりはずっと強力です。</para>
     <para>GNOME セッション内で公開鍵認証を自動化したい場合は、 <command>gnome-keyring</command> を使用することができます。詳しくは <xref linkend="sec-ssh-gnome-keyring"/> をお読みください。</para>
      <para>また、コンソールセッション内で公開鍵認証を自動化したい場合は、 <literal>ssh-agent</literal> を使用することができます。詳しくは <xref linkend="sec-ssh-authentic-agent"/> をお読みください。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
     <term>パスフレーズ無しの公開鍵認証</term>
     <listitem>
      <para>機密鍵に対してパスフレーズを設定せずに公開鍵認証を使用する方式です。スクリプトや cron ジョブなどの自動化されたサービスで便利な方式です。ただし、機密鍵はきちんと保護しておかないと、容易にそのユーザになりすましてログインできてしまうので、注意が必要です。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>証明書認証</term>
     <listitem>
      <para>OpenSSH では証明書認証にも対応しています。これにより、鍵の管理の手間を省くことができるほか、より強力な認証手段となり、かつ大規模な SSH 展開にも対応できるようになります。</para>
     </listitem>
    </varlistentry>
   </variablelist>

 <para>&productname; では既定で OpenSSH パッケージをインストールします。パッケージ内には、下記のようなファイルが含まれています:</para>

 <variablelist>
  <varlistentry>
   <term><command>ssh</command></term>
   <listitem>
    <para>遠隔のホストに対して SSH 接続を開始するためのクライアント側コマンドです。</para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><command>scp</command></term>
   <listitem>
    <para>遠隔のホストとの間でファイルをやり取りするためのコマンドです。</para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><command>sftp</command></term>
   <listitem>
    <para>クライアントと SFTP サーバとの間でファイルを送受信するためのコマンドです (なお、 SFTP (SSH FTP) プロトコルは FTPS や FTPES (FTP over SSL/TLS) と呼ばれるプロトコルとは異なり、独自に作成されているものです) 。</para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><command>ssh-add</command></term>
   <listitem>
    <para><literal>ssh-agent</literal> コマンドで動作する認証エージェントに対して、機密鍵の情報を追加するためのコマンドです。</para>
   </listitem>
  </varlistentry>
<varlistentry>
   <term><command>ssh-agent</command></term>
   <listitem>
    <para>公開鍵認証で使用する、ユーザの機密鍵とパスフレーズを管理するためのエージェントです。 <literal>ssh-agent</literal> はパスフレーズをメモリ内に保持し、必要に応じてパスフレーズを提供しますので、パスフレーズの再入力を省略することができるようになります。</para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><command>ssh-copy-id</command></term>
   <listitem>
    <para>公開鍵認証を設定して、公開鍵を遠隔のホストにコピーするコマンドです。</para>
   </listitem>
  </varlistentry>
 </variablelist>
 </sect1>

 <sect1 xml:id="sec-ssh-server-config">
 <title>サーバのセキュリティ強化</title>
 <para>OpenSSH はインストール当初の状態でそれなりに強固な設定になっていますが、サーバのセキュリティを強化するための追加設定も用意されています。</para>
 <important>
  <title>リモートの SSH サーバに対するアクセスの管理について</title>
  <para>SSH サーバに対して何らかの設定変更を行う場合は、その変更が期待通りのものであることを確認できるまで、そのマシンに対して物理的なアクセス手段を残しておくか、もしくは root の SSH セッションを開いたままにしておく必要があります。これにより、期待通りの動作で無かった場合、設定をすぐに戻すことができるためです。</para>
 </important>
 <para>既定のサーバ設定は <filename>/etc/ssh/sshd_config</filename> で、ここには既定で使用される設定が書かれています。また、コメント内には全ての既定値が示されています。既定値を変更したい場合は、これらのコメント文字を外してから、必要な設定を記述してください。たとえば下記の例では、複数のネットワークインターフェイスを持つマシンで待ち受けるポートと IPv4 アドレスを指定しています:</para>
 <screen>
#Port 22
Port <replaceable>2022</replaceable>

#ListenAddress 0.0.0.0
ListenAddress <replaceable>192.168.10.100</replaceable></screen>

<important>
 <title>/etc/services の更新について</title>
 <para>非標準の待ち受けポートを使用する場合は、 <filename>/etc/services</filename> ファイルを参照して、使用していないポートの中から選択してください。通常は 1024 以上の未使用ポートを使用します。設定後は、 <filename>/etc/services</filename> ファイル内にポートが使用中である旨を記録しておくことをお勧めします。</para>
</important>

 <para>root のログインは許可しないようにしておくことが最適です。その代わり、一般ユーザでのログインを行ったあと、 <command>sudo</command> コマンドを利用して root 権限が必要な作業を行うようにしてください。どうしても root でのログインが必要な場合は、下記のサーバ設定例 (<xref linkend="sec-ssh-public-key-auth"/>) にある <literal>PermitRootLogin prohibit-password</literal> と <literal>PasswordAuthentication</literal> のオプションを利用して、公開鍵認証のみを受け付けるように設定してください。</para>
 <para>なお、下記の <filename>/etc/ssh/sshd_config</filename> ファイル例は、アクセス制御をより強化した設定例です:</para>
 <example xml:id="ex-sshd-conf">
  <title>sshd_config の例</title>
  <programlisting># Check if the file modes and ownership of the user’s files and# home directory are correct before allowing them to loginStrictModes yes# If your machine has more than one IP address, define which address or# addresses it listens onListenAddress <replaceable>192.168.10.100</replaceable> # Allow only members of the listed groups to log inAllowGroups <replaceable>ldapadmins backupadmins</replaceable> # Or, deny certain groups. If you use both, DenyGroups is read firstDenyGroups <replaceable>users</replaceable> # Allow or deny certain users. If you use both, DenyUsers is read firstAllowUsers <replaceable>user1 user2@example.com user3</replaceable> DenyUsers <replaceable>user4 user5@192.168.10.10</replaceable> # Allow root logins only with public key authenticationPermitRootLogin prohibit-password# Disable password authentication and allow only public key authentication# for all usersPasswordAuthentication no# Length of time the server waits for a user to log in and complete the# connection. The default is 120 seconds:LoginGraceTime <replaceable>60</replaceable> # Limit the number of failed connection attempts. The default is 6MaxAuthTries <replaceable>4</replaceable></programlisting>
</example>

 <para><filename>/etc/ssh/sshd_config</filename> ファイルを変更したあとは、下記のようにして文法チェックを行ってください:</para>
 <screen>&prompt.sudo;<command>sshd -t</command></screen>
 <para>なお、文法チェック機能は文法のみをチェックする仕組みであり、設定の誤りは検出されないことに注意してください。チェック完了後は下記のように入力して実行することで、設定を再読み込みさせることができます:</para>
 <screen>&prompt.sudo;<command>systemctl reload sshd.service</command></screen>
 <para>また、サーバの鍵ディレクトリに適切なパーミッションが設定されていることを確認してください。</para>
 <para><filename>/etc/ssh</filename> ディレクトリは 0755/drwxr-xr-x のパーミッションで所有者が root:root でなければいけません。</para>
 <para>機密鍵は 0600/-rw------- のパーミッションで所有者が root:root でなければいけません。</para>
 <para>公開鍵は 0644/-rw-r--r-- のパーミッションで所有者が root:root でなければいけません。</para>

 <!-- not sure if this should be included, it seems redundant with
 sshd_config. cjs 27 June 2022 -->
 <!--
 <para>
  You may restrict logins from subnets with PAM (Pluggable Authentication
  Modules). The following steps configure remote login restrictions for
  certain users. These restrictions affect all OpenSSH commands,
  including <command>ssh</command>
  (<xref linkend="sec-ssh-password-auth"/>),
  <command>scp</command> (<xref linkend="sec-ssh-copy"/>), and
  <command>sftp</command> (<xref linkend="sec-ssh-sftp"/>).
  </para>
  <procedure xml:id="pro-ssh-restrict-logins">
   <title>Configuring remote login restrictions</title>
   <para>
    Perform the following steps to configure user remote login restrictions:
    </para>
   <step>
    <para>
     Edit the file <filename>/etc/pam.d/sshd</filename> and append the
     following at the end of the <literal>auth</literal> block:
    </para>
    <screen>auth required pam_access.so</screen>
   </step>
   <step>
    <para>
     Edit the file <filename>/etc/security/access.conf</filename> to
     configure individual restrictions. In this example the users &rootuser;
     and &exampleuser; are restricted to the &exampledomain1ip;.0/&subnetmask;
     network, while the &exampleuserII; user can only login from within the
     &exampledomain2ip;.0/&subnetmask; network:
    </para>
<screen>
+ : root : <replaceable>&exampledomain1ip;.0</replaceable>/<replaceable>&subnetmask;</replaceable>
+ : &exampleuser_plain; : <replaceable>&exampledomain1ip;.0</replaceable>/<replaceable>&subnetmask;</replaceable>
+ : &exampleuserII_plain; : <replaceable>&exampledomain2ip;.0</replaceable>/<replaceable>&subnetmask;</replaceable>
- : ALL : ALL</screen>
   <para>
    Do not forget the last line which denies access for all other users from
    all sources, and be careful not to lock yourself out of the system.
   </para>
   <para>
    For more configuration options, refer to the examples in
    <filename>/etc/security/access.conf</filename>, and to
    <command>man access.conf</command>.
   </para>
   </step>
  </procedure>
  <warning>
   <title>Do not use pam-config</title>
   <para>
    Do not use the <command>pam-config</command> utility here. It only
    supports <systemitem>git pam_access</systemitem> as a global module. The
    configuration above is not suitable to be used globally for all services
    and can completely deny access to the system.
   </para>
 </warning>-->
 </sect1>

<sect1 xml:id="sec-ssh-password-auth">
  <title>パスワード認証</title>
  <para>パスワード認証を行う場合は、接続先のマシン内にユーザアカウントとパスワードを設定し、 <systemitem class="daemon">sshd</systemitem> を設定してそれを動作させておくだけです。個人用の SSH 鍵を作成する必要はありません。下記は、 &exampleserver; というホストに対して &exampleuserIII_plain; というユーザ名で SSH ログインする場合の例です:</para>
<screen>&prompt.user;<command>ssh &exampleuserIII_plain;@&exampleserver;</command>
</screen>
  <para>接続を行うと、まずは接続先で設定した &exampleuserIII_plain; のパスワード入力を求められます。また、 <literal>exit</literal> と入力して <keycap>Enter</keycap> を押すと、 SSH セッションを終了することができます。</para>
  <para>両方のマシンでユーザ名が同じであれば、ユーザ名を指定する必要はありません。 <command>ssh <replaceable>ホスト名</replaceable></command> のように入力して実行するだけで済みます。認証が成功すると、相手側のコンピュータのコマンドラインを使用したり、 &yast; のテキストモードのような対話的なアプリケーションを使用したりすることができるようになります。</para>
  <para>これらに加えて、 <command>ssh <replaceable>ユーザ名@ホスト コマンド</replaceable></command> の書式を使用することで、対話的でないコマンドを実行することもできます。この場合、ログインしてコマンドを実行したあと、そのまま接続を終了する動作になります。なお、 <replaceable>コマンド</replaceable> では適切に引用符を指定する必要があります。また、複数のコマンドはローカルのシェルと同じ方法で繋げることができます:</para>

<screen>&prompt.user;<command>ssh &exampleuserIII_plain;@&exampleserver; "df -h &amp;&amp; du -sh  /home"</command>
&prompt.user;<command>ssh &exampleuserIII_plain;@&exampleserver; "sudo nano /etc/ssh/sshd_config"</command></screen>

  <para>リモートのマシンで <command>sudo</command> を実行すると、 <command>sudo</command> でのパスワード入力が求められます。</para>
  </sect1>

   <sect1 xml:id="sec-ssh-authentic-gen-key">
   <title>ユーザ鍵とホスト鍵の管理</title>
   <para>生成できる鍵の種類としては、 DSA, RSA, ECDSA, ECDSA-SK, Ed25519, Ed25519-SK があります。ただし、 DSA は何年も前に廃止予定とされていて、 OpenSSH 7.0 では無効化されていて使用すべきではありません。 RSA は最も一般的に使用されている種類で、古い仕組みではあるものの一般的に使用されています (なお、 OpenSSH 8.2 およびそれ以降のバージョンでは、 RSA はホスト鍵としては廃止予定になっています。ホスト鍵には ECDSA もしくは Ed25519 をお使いください) 。</para>
   <para>Ed25519 と ECDSA はより強力で高速な鍵です。 Ed25519 が最も強力な鍵として提供されていますが、 Ed25519 や ECDSA に対応していない古いクライアントを受け付ける必要がある場合は、 3 種類全てのホスト鍵を作成してください。</para>
   <note>
     <title>古いクライアントの安全性について</title>
     <para>古い SSH クライアントは ECDSA や ED25519 に対応していませんが、 ECDSA と ED25519 への対応は 2014 年に公開された OpenSSH 6.5 から提供されているものです。どうしても接続を受け付ける必要がある場合は、必ずセキュリティ更新を適用しておいてください。また、可能であれば古いクライアントからの接続は許可しないでください。</para>
   </note>
   <para>SSH の鍵は 2 種類の目的で使用されます。クライアントがサーバを認証するためのホスト鍵と、サーバがクライアントを認証するためのクライアント鍵です (詳しくは <xref linkend="sec-ssh-public-key-auth"/> をお読みください) 。サーバのホスト鍵は <filename>/etc/ssh</filename> ディレクトリ内に保存され、ユーザ鍵はユーザごとのディレクトリである <filename>/home/<replaceable>ユーザ名</replaceable>/.ssh</filename> ディレクトリ内に保存されます。</para>
    <para>なお、ユーザ側で新しい SSH 鍵を作成すると、 <filename>/home/<replaceable>ユーザ名</replaceable>/.ssh</filename> ディレクトリが作成されます。</para>
   <para>また、ホスト鍵にはパスフレーズを設定してはいけません。</para>
   <para>ほとんどの場合、ユーザ鍵には強力なパスフレーズを設定します。</para>

   <sect2 xml:id="sec-create-ssh-key-client">
     <title>ユーザ SSH 鍵の生成</title>
      <para>下記に示す手順では、 OpenSSH でのユーザ鍵の作成方法を説明しています。</para>
     <procedure xml:id="pro-create-ssh-client-keys">
     <title>既定の鍵と独自の鍵について</title>
    <step>
     <para>既定のパラメータ (RSA, 3072 ビット) でユーザ鍵対を生成するには、オプションを何も指定せず <command>ssh-keygen</command> と入力して実行します。なお、機密鍵を保護するため、強力なパスフレーズを設定しておいてください:</para>
     <screen><?dbfo keep-together="always"?>&prompt.user;<command>ssh-keygen</command>
Generating public/private rsa key pair.
Enter file in which to save the key (/home/tux/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in id_rsa
Your public key has been saved in id_rsa.pub
The key fingerprint is:
SHA256:z0uJIuc7Doy07bFTe1ppZHLVrkD/bWWlBAF/PcHjblU user@host2
The key's randomart image is:
+---[RSA 3072]----+
|          ..o... |
|           o . +E|
|        . . o +.=|
|       . o . o o+|
|  .   . S . . o +|
| . =  .= * + . = |
|  o *.o.= * . +  |
|   ..Bo+.. . .   |
|    oo==  .      |
+----[SHA256]-----+</screen>
    </step>
    <step>
      <para>より長いビット長で RSA 鍵対を作成したい場合は、下記のように入力して実行します:</para>
      <screen>&prompt.user;<command>ssh-keygen -b 4096</command></screen>
      <para>OpenSSH での RSA 鍵は、最大で 16,384 ビットまでとなっています。しかしながら、ビット長を大きくしても、かかる負荷に見合うだけの効果を得られません。詳しくは GnuPG の FAQ <link xlink:href="https://www.gnupg.org/faq/gnupg-faq.html#no_default_of_rsa4096"/> (英語) をお読みください。</para>
    </step>
    <step>
      <para>ユーザ鍵は必要な数だけ作成することができます。これらを異なるサーバへの接続に使用することができます。鍵対には重複しない名前を指定しなければならないほか、必要であればコメントを含めることもできます。これらは鍵の用途を記しておくのに最適です。たとえば下記のようにして名前とコメントを指定して作成します:</para>
    <screen>&prompt.user;<command>ssh-keygen -f <replaceable>backup-server-key -C "infrastructure backup server"</replaceable></command>
      </screen>
    </step>
    <step>
     <para>独自のファイル名やコメントを指定して Ed25519 鍵対を作成する場合は、下記のようにします:</para>
     <screen>&prompt.user;<command>ssh-keygen -t ed25519 -f <replaceable>ldap-server-key -C "Internal LDAP server"</replaceable></command>
     </screen>
     <para>Ed25519 の鍵は 256 ビットの固定長です。暗号強度は RSA 4096 ビットと同程度になります。</para>
    </step>
   </procedure>
  </sect2>

   <sect2 xml:id="sec-create-ssh-host-keys">
    <title>SSH サーバのホスト鍵作成</title>
    <para>ホスト鍵はクライアント鍵とは違った管理方法になります。ホスト鍵にはパスフレーズを設定してはならないほか、鍵対は <filename>/etc/ssh</filename> ディレクトリ内に保存します。 OpenSSH では、必要に応じて自動的にホスト鍵を生成します。たとえば下記のようになります:</para>
    <screen><?dbfo keep-together="always"?>&prompt.user;<command>ls -l /etc/ssh</command>
total 608
-rw------- 1 root root 577834  5月  6 2021 moduli
-rw-r--r-- 1 root root   2403  5月  6 2021 ssh_config
-rw-r----- 1 root root   3420  5月  6 2021 sshd_config
-rw------- 1 root root   1381  2月 10 2021 ssh_host_dsa_key
-rw-r--r-- 1 root root    604  2月 10 2021 ssh_host_dsa_key.pub
-rw------- 1 root root    505  2月 10 2021 ssh_host_ecdsa_key
-rw-r--r-- 1 root root    176  2月 10 2021 ssh_host_ecdsa_key.pub
-rw------- 1 root root    411  2月 10 2021 ssh_host_ed25519_key
-rw-r--r-- 1 root root     96  2月 10 2021 ssh_host_ed25519_key.pub
-rw------- 1 root root   2602  2月 10 2021 ssh_host_rsa_key
-rw-r--r-- 1 root root    568  2月 10 2021 ssh_host_rsa_key.pub</screen>

    <para>なお、 <command>ssh-keygen</command> には新しいホスト鍵を作成するための特別なオプションである <option>-A</option> が用意されています。これはそれぞれの種類のホスト鍵対が存在していなかった場合、それらを自動的に生成することができます。保存先や空のパスフレーズ設定、鍵の種類ごとのビット長や空のコメントも自動的に設定されます。下記のように入力して実行すると、既存の鍵を削除して新しいホスト鍵対を生成することができます:</para>
    <screen>&prompt.sudo;<command>rm /etc/ssh/ssh_host*</command>
&prompt.sudo;<command>ssh-keygen -A</command></screen>
    <para>なお、 <command>ssh-keygen -A</command> では既存の鍵を上書きすることはありませんので、ホスト鍵を完全に入れ替える場合は、事前に削除しておく必要があります。</para>
    <important>
     <title>DSA 鍵の使用禁止について</title>
      <para><command>ssh-keygen -A</command> を実行すると、既に何年も前から安全性に問題があると考えられている DSA 鍵も生成されます。 OpenSSH 7.0 の時点でも未だ作成されますが、 <filename>sshd_config</filename> 側で使用されないように設定されています。そのため、生成された DSA 鍵は削除して問題ありません。</para>
    </important>
    <para>ホスト鍵の切り替え (詳しくは <xref linkend="sec-ssh-sshdserver-rotation"/> をお読みください) を検討している場合は、新しいホスト鍵を別のファイル名に保存しなければなりません。単純に新しい鍵に入れ替えるだけの作業では、ユーザ側でホスト鍵の正しさを検証できないためです。ホスト鍵を切り替えるには、サーバ側で古い鍵と新しい鍵の両方を送信するように設定し、古い鍵で新しい鍵を検証できるようにしてください。そのため、古い鍵とは別のファイル名に保存する必要があります。下記の例では、新しい RSA, Ed25519 のホスト鍵を作成して、年月を指定した新しいファイル名に保存しています。もちろん新しいホスト鍵にはパスフレーズを設定してはなりません:</para>
    <screen>&prompt.user;<command>cd /etc/ssh</command>
&prompt.sudo;<command>ssh-keygen -b 4096 -f "<replaceable>SSH_HOST_RSA_2022_02</replaceable>"</command>
&prompt.sudo;<command>ssh-keygen -t ed25519 -f "<replaceable>SSH_HOST_ED25519_2022_02</replaceable>"</command></screen>
    <para>なお、新しい鍵に設定するファイル名は任意のものでかまいません。</para>
   </sect2>
  </sect1>

   <sect1 xml:id="sec-ssh-sshdserver-rotation">
   <title>ホスト鍵の切り替え</title>
   <para>OpenSSH バージョン 6.8 およびそれ以降のバージョンでは、ホスト鍵を切り替えながら使用することのできるプロトコル拡張が利用できます。 SSH サーバの管理者は、たとえばホスト鍵が漏洩したり、既存の鍵の強度では弱いと判断したりした場合、古いホスト鍵を廃棄して新しいホスト鍵に切り替えなければならなくなります。バージョン 6.8 以前では、ユーザ側のマシンの <filename>ssh_config</filename> で <literal>StrictHostKeyChecking</literal> が <literal>yes</literal> に設定されていると、ホスト鍵の変更が検出されると警告メッセージを表示して接続が行われなくなっていました。この場合、ユーザ側で対応する公開鍵を <filename>known_hosts</filename> ファイルから手作業で削除して接続し直し、新しい鍵を受け付ける作業が必要になります。 SSH 経由でのスケジュールバックアップなど、自動化を行っている場合には面倒になってしまいます。</para>
   <para>新しいホスト鍵の切り替え方式では、サービスの停止を伴うことなく新しい鍵を配布できる方式を提供しています。クライアントからの接続があると、サーバは手持ちの鍵を一覧で送信しますので、次回以降のログインで新しい鍵を自動的に受け付けるようにすることができます。これにより、鍵の移行のための猶予期間を設定することができますので、しばらく待ってから古い鍵を削除すれば、移行が完了することになります。ユーザ側の <filename>known_hosts</filename> ファイルも自動的に更新されますので、古い鍵から新しい鍵への切り替えも自動でできることになります。</para>
    <para>ホスト鍵の切り替え機能を使用するには、新しい鍵の作成のほか、サーバ側では <filename>/etc/ssh/sshd_config</filename> ファイルの変更を、クライアント側では <filename>/etc/ssh/ssh_config</filename> ファイルの変更をそれぞれ行う必要があります。</para>
   <para>まずは新しい鍵 (複数可) を作成します。下記の例では、ファイル名とコメントを指定して新しい RSA 鍵と Ed25519 鍵を作成しています。一般的には作成日などを含めておくとよいでしょう。また、ホスト鍵にはパスフレーズを設定してはいけません:</para>
   <screen>&prompt.root;<command>ssh-keygen -t rsa -f ssh_host_rsa_2022-01 -C "main server"</command>
Generating public/private rsa key pair.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in ssh_host_rsa_2022-01
Your public key has been saved in ssh_host_rsa_2022-01.pub
The key fingerprint is:
SHA256:F1FIF2aqOz7D3mGdsjzHpH/kjUWZehBN3uG7FM4taAQ main server
The key's randomart image is:
+---[RSA 3072]----+
|         .Eo*.oo |
|          .B .o.o|
|          o . .++|
|         . o ooo=|
|        S . o +*.|
|         o o.oooo|
|       .o ++oo.= |
|       .+=o+o + .|
|       .oo++..   |
+----[SHA256]-----+

&prompt.root;<command>ssh-keygen -t ed25519 -f ssh_host_ed25519_2022-01 -C "main server"</command>
Generating public/private ed25519 key pair.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in ssh_host_ed25519_2022-01
Your public key has been saved in ssh_host_ed25519_2022-01.pub
The key fingerprint is:
SHA256:2p9K0giXv7WsRnLjwjs4hJ8EFcoX1FWR4nQz6fxnjxg main server
The key's randomart image is:
+--[ED25519 256]--+
|   .+o ...o+     |
| . .... o *      |
|  o..  o = o     |
|  ..   .. o      |
|   o. o S  .     |
|  . oo.*+   E o  |
|   + ++==..  = o |
|    = +oo= o. . .|
|     ..=+o=      |
+----[SHA256]-----+</screen>

   <para>表示されたフィンガープリント (key fingerprint) を、ユーザ側で鍵を検証する際の確認として記録しておいてください。</para>
   <para>新しい鍵のファイル名を <filename>/etc/ssh/sshd_config</filename> で指定します。既存の鍵はコメントアウトせず、そのまま設定しておいてください:</para>
   <screen>## 古い鍵
HostKey /etc/ssh/ssh_host_rsa_key
HostKey /etc/ssh/ssh_host_ed25519_key
HostKey /etc/ssh/ssh_host_ecdsa_key

## 新しい鍵
HostKey /etc/ssh/ssh_host_rsa_2022-01
HostKey /etc/ssh/ssh_host_ed25519_2022-01</screen>

    <para>ファイルを保存したら、 <systemitem class="daemon">sshd</systemitem> を再起動します:</para>
    <screen>&prompt.root;<command>systemctl restart sshd.service</command>
    </screen>
    <para>なお、ユーザ側の <filename>/etc/ssh/ssh_config</filename> では、下記のような設定をしている必要があります:</para>
    <screen>UpdateHostKeys ask
StrictHostKeyChecking yes</screen>
    <para>クライアント側からサーバに SSH で接続してテストしてみます。既に接続している場合はいったんログアウトして再接続してみてください。下記のようなメッセージが表示されるはずです:</para>
    <screen>The server has updated its host keys.
These changes were verified by the server's existing trusted key.
Deprecating obsolete hostkey: ED25519
SHA256:V28d3VpHgjsCoV04RBCZpLo5c0kEslCZDVdIUnCvqPI
Deprecating obsolete hostkey:
RSA SHA256:+NR4DVdbsUNsqJPIhISzx+eqD4x/awCCwijZ4a9eP8I
Accept updated hostkeys? (yes/no):yes</screen>
    <para><literal>UpdateHostKeys ask</literal> を <literal>UpdateHostKeys yes</literal> に変更することで、変更された鍵を自動的に受け付けるように設定することもできます。</para>
    <para>さらに詳しい情報を知りたい場合は、下記を参照してください:</para>

   <itemizedlist>
    <listitem>
      <para><xref linkend="sec-ssh-authentic-gen-key"/></para>
    </listitem>
    <listitem>
     <para><link xlink:href="http://blog.djm.net.au/2015/02/key-rotation-in-openssh-68.html"/> (英語)</para>
    </listitem>
    <listitem>
     <para>man 5 ssh_config, man 5 sshd_config</para>
    </listitem>
   </itemizedlist>
 </sect1>

  <sect1 xml:id="sec-ssh-public-key-auth">
  <title>公開鍵認証</title>
  <para>公開鍵認証は、アカウントに対して設定されたパスワードではなく、ユーザが作成した個人用の鍵で認証を行う方法です。</para>
  <para>下記は、コメント付きで個人用の RSA 鍵を作成する場合の例を示しています。まずは <filename>~/.ssh</filename> ディレクトリに移動 (存在していない場合は作成して移動) したあと、新しい鍵対を作成します。この場合、パスフレーズはできる限り複雑なものとし、パスフレーズは安全な場所に記録しておいてください:</para>
  <screen>&prompt.user;<command>cd ~/.ssh</command>
&prompt.user;<command>ssh-keygen -C <replaceable>"web server1"</replaceable> -f <replaceable>id-web1</replaceable> -t rsa -b <replaceable>4096</replaceable></command>
</screen>
  <para>あとは作成した鍵対のうち、公開鍵を接続先のホストにコピーします。接続先のマシンにユーザアカウントがあれば、 SSH でアクセスして鍵を書き込みます:</para>
  <screen>&prompt.user;<command>ssh-copy-id -i <replaceable>id-web1 user@web1</replaceable></command></screen>
  <para>あとは作成した鍵でログインを試してみるだけです:</para>
  <screen>&prompt.user;<command>ssh -i <replaceable>id-web1 user@web1</replaceable></command>
Enter passphrase for key 'id-web1':
Last login: Sat Jul 11 11:09:53 2022 from 192.168.10.122
Have a lot of fun...</screen>
  <para>この場合、パスフレーズの入力を求められますが、接続先のマシンのパスワードではなく、鍵のパスフレーズを入力する必要があることに注意してください。</para>
  <para>なお、安全性を高めたい場合は、接続先のマシンで公開鍵認証を強制して、パスワード認証を拒否するように設定することをお勧めします (詳しくは <xref linkend="ex-sshd-conf"/> ) をお読みください) 。この場合、接続先のマシンに個人用の公開鍵を設定していないと、 <command>ssh-copy-id</command> やその他の方法での公開鍵書き込みもまた実行できなくなることに注意してください。このような場合は、 USB メモリなどに公開鍵を書き込んで、接続先のマシンの <filename>~/.ssh/authorized_keys</filename> にコピーする作業を実施しなければなりません。</para>
 </sect1>

  <sect1 xml:id="sec-ssh-passphrase-less-auth">
  <title>パスフレーズ無しの公開鍵認証</title>
  <para>これは機密鍵に対してパスフレーズを設定せずに公開鍵認証を使用する方式です。パスフレーズを指定せずに新しい鍵を作成したあとは、パスフレーズ付きの鍵と同じ手順で鍵を使用することができます。これは特にスクリプトや cron ジョブなどの自動化されたサービスで便利な方式です。ただし、機密鍵はきちんと保護しておかないと、容易にそのユーザになりすましてログインできてしまうので、注意が必要です。</para>
  <para>なお、パスフレーズ無しで鍵を使用するもう 1 つの方法として、 <literal>gnome-keyring</literal> があります。こちらは機密鍵のパスフレーズを記憶して、必要に応じて適用を行うことができます。 <literal>gnome-keyring</literal> は GNOME デスクトップセッション向けの仕組みです (詳しくは <xref linkend="sec-ssh-gnome-keyring"/> をお読みください) 。</para>
  <para>コンソールセッションの場合は <literal>ssh-agent</literal> を使用することができます (詳しくは <xref linkend="sec-ssh-authentic-agent"/> をお読みください) 。</para>
 </sect1>

  <sect1 xml:id="sec-ssh-certificate-auth">
  <title>OpenSSH での証明書認証</title>
  <para>OpenSSH 5.4 およびそれ以降のバージョンでは、証明書による認証を行うことができます。証明書認証は公開鍵認証と似ていますが、ホストとユーザとの間で認証を行うにあたって、単純な暗号鍵ではなくデジタル署名された証明書を使用します。証明書認証はサーバとユーザとの間の認証を集中管理することができますので、いちいち公開鍵を接続先のホストにコピーするような手間も発生しません。また、管理者側での制御もできるようになりますので、より管理者側に権力を集中させることができます。</para>
  <para>証明書には公開暗号鍵のほか、ユーザ定義の識別文字列やユーザ名、ホスト名などを必要に応じて含めることができます。ユーザ側とホスト側の公開鍵にはいずれも証明機関 (CA) による署名が付与され、これによって正当性を確認できるようになります。つまり、ユーザ側もホスト側も、 CA の公開鍵を信頼しているだけで認証が成立しますので、わざわざユーザやホストごとに信頼を設定する必要もありません。</para>
  <para>また、 OpenSSH の公開鍵認証の場合、ユーザの公開鍵をそれぞれ接続したい SSH サーバにコピーしていく手間がある (通常は <filename>~/.ssh/authorized_keys</filename> ファイルに保存されます) ほか、ユーザ側でもホスト鍵を受け付ける (通常は <filename>~/.ssh/known_hosts</filename> ファイルに保存されます) 必要がありました。このような構成では操作ミスを引き起こすことがあるほか、管理上も面倒な存在でした。また、このような公開鍵認証では鍵の有効期限が設定できませんので、新しい鍵に入れ替えたい場合は、ネットワーク内に存在する鍵を削除していく手間もありました。</para>
  <para>大企業では、このような手間を全体的に削減して自動化する仕組み (たとえば Ansible など) が必要でした。たとえば Meta 社 (詳しくは <link xlink:href="https://engineering.fb.com/2016/09/12/security/scalable-and-secure-access-with-ssh/"/> (英語) をお読みください) では、この仕組みを完全に自動化して、証明書を失効させて置き換えることができるようになっているほか、証明機関自身も自動化することで、業務の手間とならない仕組みを構成しています。</para>
  <para>なお、事前に実施しておかなければならない作業として、ネットワーク内に存在する全てのホストに SSH 接続して設定ファイルを編集し、 <systemitem class="daemon">sshd</systemitem> を再起動する必要があります。</para>
  <para>OpenSSH での証明機関構築は、下記のような手順で行います:</para>
 <itemizedlist>
  <listitem>
  <para>機密の保持できる信頼できるサーバを構築して、そこに証明機関を配置します。まずは証明機関自身の鍵対を作成して、この機密鍵でユーザ鍵やホスト鍵への署名を行うとともに、公開鍵はサーバへのアクセスを許可する全てのユーザに配布します。</para>
  </listitem>
  <listitem>
  <para>次にホスト側の公開鍵を集めて、証明機関で署名を実施したあと、作成された証明書をそれぞれのホストに返します。発行されたホストの証明書は、ホスト鍵と同様に <filename>/etc/ssh</filename> 内に配置します。</para>
  </listitem>
  <listitem>
  <para>次にユーザ側の公開鍵を集めて、証明機関で署名を実施したあと、作成された証明書を各ユーザに返します。ユーザ側の証明書は、ユーザ鍵と同様に <filename>~/.ssh</filename> 内に配置します。</para>
  </listitem>
  <listitem>
   <para>サーバ側、ユーザ側の各マシンで設定ファイルを編集して、必要であれば <systemitem class="daemon">sshd</systemitem> を再起動します。</para>
  </listitem>
  <listitem>
  <para>なお、発行した証明書は、機密鍵が漏洩したり、ユーザが組織を脱退したり、サーバを退役させたりした場合に失効処理を実施します。証明書の失効処理は、ネットワーク内に配布した公開鍵を削除して回るよりは比較的簡単です。</para>
  </listitem>
 </itemizedlist>
   <para>なお、ユーザ側・サーバ側の管理者とも、それぞれの OpenSSH 鍵はきちんと保護してください。ただし、公開鍵は自由に公開してかまいません。電子メールなどの機密の保護できない方式で公開鍵を送信しても、機密鍵が保護されている限り問題はありません。</para>
   <para>ただし、 SSH での証明書は SSL/TLS ではなく OpenPGP の標準に従っていることに注意してください。これにより、証明書の形式は X.509 ではなく、 OpenPGP 形式になっています。</para>

 <sect2 xml:id="sec-ssh-certificate-create-signing-keys">
  <title>新しい証明機関の構築</title>
  <para>本章では、新しい証明機関 (CA) を構築する手順を説明しています。なお、証明機関を構築するにあたっては、管理の容易さや効率性を考えておくことをお勧めします。</para>
  <important>
   <title>証明機関自身の保護について</title>
   <para>証明機関を設置するホストに対しては、注意深く構成するようにしてください。これは、証明機関は組織全体に対する認証の中枢となるためです。もしも証明機関に対して不正にアクセスできてしまうと、発行した証明書の安全性が損なわれるため、ネットワーク内のコンピュータに対して自由にアクセスを許す結果になってしまうばかりか、サーバや証明機関自身を騙して証明書を偽造することもできてしまいます。そのため、証明機関を設置するホストはそれ専用のコンピュータとして配置し、証明書の発行に必要なサービスのみを動作させるようにしてください。</para>
  </important>
   <para>また、サーバ向けとその他向けで別々の署名鍵を設定してもかまいません。管理すべき証明書の数が多い場合は、サーバ向けとクライアント向けで別々の証明機関のマシンを構築することもできます。同じマシン内に複数の証明機関を構築する場合は、別々のディレクトリ内でもかまいません。本章の例では、 <filename>/ca-ssh-hosts</filename> と <filename>/ca-ssh-users</filename> というディレクトリ内にそれぞれの証明機関を構築しています。また、ホスト名は <replaceable>ca.example.com</replaceable> という名前を使用しています。</para>
   <para>なお、セキュリティポリシー上の理由から、ユーザやサーバに対する公開鍵のコピーを保持しておく必要がある場合は、それぞれサブディレクトリを作成して保存するようにしてください。これにより、追跡が容易にできるほか、名前の衝突を防ぐことにも繋がります。</para>
   <important>
    <title>RSA 署名鍵の廃止予定について</title>
    <para>2020 年 2 月に公開された OpenSSH 8.2 もしくはそれ以降のバージョンでは、 RSA による署名鍵は廃止予定とされています。 Ed25519 もしくは ECDSA をお使いください。</para>
   </important>
   <para>下記の例では、それぞれホスト鍵に署名するための鍵と、ユーザ鍵に署名するための鍵をそれぞれ作成しています。それぞれには強力なパスフレーズを設定してください:</para>
  <screen>&prompt.sudo;<command>ssh-keygen -t ed25519 -f <replaceable>/ca-ssh-hosts/ca-host-sign-key -C "signing key for host certificates"</replaceable></command>
Generating public/private ed25519 key pair.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in ca-host-sign-key
Your public key has been saved in ca-host-sign-key.pub
The key fingerprint is:
SHA256:STuQ7HgDrPcEa7ybNIW0n6kPbj28X5HN8GgwllBbAt0
 signing key for host certificates
The key's randomart image is:
+--[ED25519 256]--+
|      o+o..      |
|   . . o.=E      |
|    = + B .      |
|   + O + = B     |
|  . O * S = +    |
|   o B + o .     |
|    =o=   .      |
|   o.*+  .       |
|   .=.o+.        |
+----[SHA256]-----+
</screen>

  <screen>&prompt.sudo;<command>ssh-keygen -t ed25519 -f <replaceable>/ca-ssh-users/ca-user-sign-key -C "signing key for user certificates"</replaceable></command>
Generating public/private ed25519 key pair.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in ca-user-sign-key
Your public key has been saved in ca-user-sign-key.pub
The key fingerprint is:
SHA256:taYj8tTnjkzgfHRvQ6HTj8a37PY6rwv96V1x+GHRjIk signing key for user certificates
The key's randomart image is:
+--[ED25519 256]--+
|                 |
|             . +.|
|          . E o.o|
|         . + . ..|
|      . S * o .+.|
|     o + + = +..+|
|    . = * . O + o|
|     + = = o =oo+|
|      . o.o  oOX=|
+----[SHA256]-----+
 </screen>
 <para>鍵を作成したら、署名鍵 (公開鍵であることをよくお確かめください) を SSH サーバの動作する全てのホスト内の <filename>/etc/ssh</filename> 内にコピーします。あとは全てのホスト内の <filename>/etc/ssh/sshd_config</filename> ファイルを編集して、署名鍵を指定しておきます:</para>
 <screen>TrustedUserCAKeys <replaceable>/etc/ssh/ca-user-sign-key.pub</replaceable>
</screen>
 <para>ファイルを保存したら、 <systemitem class="daemon">sshd</systemitem> を再起動します。</para>
</sect2>

 <sect2 xml:id="sec-ssh-certificate-create-host-certs">
  <title>サーバ証明書の作成</title>
  <para>下記の例では、データベースサーバ (<replaceable>db-server</replaceable>) のホスト公開鍵に対して、署名を付与しています:</para>
  <screen>&prompt.sudo;<command>ssh-keygen -s <replaceable>/ca-ssh-hosts/ca-host-sign-key</replaceable></command> \
   <command>-n <replaceable>&wsII;,&wsIIname;</replaceable> -I <replaceable>"db-server host cert"</replaceable></command> \
   <command>-h -V +4w <replaceable>/etc/ssh/ssh_host_ed25519_key.pub</replaceable></command>
Enter passphrase:
Signed host key /etc/ssh/ssh_host_ed25519_key-cert.pub: id
"db-server host cert" serial 0 for venus,venus.example.com
valid from 2022-08-08T14:20:00 to 2022-09-05T15:21:19
    </screen>
      <para>サーバ内に複数の鍵が存在する場合は、全ての鍵に対して署名を実施してください。</para>
    <itemizedlist>
     <listitem>
      <para><option>-s</option> では機密鍵を指定しています。</para>
     </listitem>
     <listitem>
      <para><option>-n</option> ではプリンシパル名を指定しています。ホスト鍵の場合、ここには完全修飾ドメイン名によるマシンのホスト名を指定します。</para>
     </listitem>
     <listitem>
      <para><option>-I</option> では識別用の文字列を指定しています。ここはコメント欄ですので、わかりやすい説明を記述してください。また、この文字列はログにも記録されますので、ログ内を検索したい場合にも有用です。</para>
     </listitem>
     <listitem>
      <para><option>-h</option> ではホスト鍵の証明書であることを指定しています。</para>
    </listitem>
    <listitem>
     <para><option>-V</option> では証明書の有効期限を指定しています。この例では、証明書は 4 週間後になっています (指定可能な期間については、 <command>man 1 ssh-keygen</command> 内の "-V validity_interval" の章 (英語) をお読みください) 。</para>
    </listitem>
   </itemizedlist>
   <para>あとは発行された証明書が正しいことを確認します:</para>
   <screen>&prompt.user;<command>ssh-keygen -Lf /etc/ssh/ssh_host_ed25519_key-cert.pub</command>
 /etc/ssh/ssh_host_ed25519_key-cert.pub:
        Type: ssh-ed25519-cert-v01@openssh.com host certificate
        Public key: ED25519-CERT SHA256:/
         U7C+qABXYyuvueUuhFKzzVINq3d7IULRLwBstvVC+Q
        Signing CA: ED25519 SHA256:
         STuQ7HgDrPcEa7ybNIW0n6kPbj28X5HN8GgwllBbAt0 (using ssh-ed25519)
        Key ID: "db-server host cert"
        Serial: 0
        Valid: from 2022-08-08T14:20:00 to 2022-09-05T15:21:19
        Principals:
                venus
                venus.example.com
        Critical Options: (none)
        Extensions: (none)
    </screen>
   <para>あとは発行された証明書のフルパスを <filename>/etc/ssh/sshd_config</filename> で指定して、クライアント側に送信するようにします:</para>
   <screen>HostCertificate <replaceable>/etc/ssh/ssh_host_ed25519_key-cert.pub</replaceable></screen>
   <para>ファイルを保存したら、 <systemitem class="daemon">sshd</systemitem> を再起動します:</para>
   <screen>&prompt.sudo;<command>systemctl restart sshd.service</command></screen>
   <para>ホストの証明書をクライアント側で受け付ける方法については、 <xref linkend="sec-ssh-certificate-user-config"/> をお読みください。</para>
  </sect2>

  <sect2 xml:id="sec-ssh-certificate-user-config">
   <title>ユーザ向けの CA 設定</title>
   <para>下記の例では、クライアント側で個別の鍵ではなく証明機関で署名された鍵を受け付ける設定を示しています。下記の例では単一のサーバに対してのみアクセスを許可しています。また、下記の設定は <filename>~/.ssh/known_hosts</filename> 内で改行せず 1 行で記述する必要があることに注意してください。また、既に <filename>~/.ssh/known_hosts</filename> ファイルが存在する場合は、ファイル名を変更して残しておき、下記の証明機関設定のみを含むようにしてください。なお、 <filename>/etc/ssh/ssh_known_hosts</filename> ファイルに証明機関を設定する方法もありますが、こちらを編集するには管理者権限が必要となります:</para>
   <screen>@cert-authority db,db.example.com ssh-ed25519
 AAAAC3NzaC1lZDI1NTE5AAAAIH1pF6DN4BdsfUKWuyiGt/leCvuZ/fPu
 YxY7+4V68Fz0 signing key for user certificates
   </screen>
    <para>サーバを複数指定する場合は、カンマ区切りで指定してください。たとえば <literal><replaceable>&wsII;,&wsIIname;,&wsIII;,&wsIIIname;</replaceable></literal> のようになります。ワイルドカードを利用して <literal>*.example.com,*.example2.com</literal> のように指定し、ドメイン内の全てのサーバに対してアクセスを許可することもできます。</para>
    <para>あとは実際にサーバに接続してみてください。ホスト鍵の受け付けを促すプロンプトが表示されず、そのままパスワード入力を求められれば成功です。</para>
  </sect2>

  <sect2 xml:id="sec-ssh-certificate-user-certs">
   <title>ユーザ証明書の作成</title>
   <para>下記のようにしてユーザの公開鍵に署名を付与します:</para>
   <screen>&prompt.sudo;<command>ssh-keygen <replaceable>/ca-ssh-hosts/ca-user-sign-key -I "suzanne's cert" -n &exampleuserIII_plain; -V +52w user-key.pub</replaceable></command>
 Signed user key .ssh/ed25519key-cert.pub: id "suzanne's cert" serial 0
 for suzanne valid from 2022-09-14T12:57:00 to 2023-09-13T12:58:21
</screen>
   <para>ここで、プリンシパル名は必ずユーザ名でなければならないことに注意してください。また、発行した証明書はユーザ側のマシンの <filename>~/.ssh</filename> 内に保存してください。</para>
   <para>ユーザの証明書を発行すれば、サーバ側の <filename>~/.ssh/authorized_keys</filename> ファイルは不要になります。サーバ側のこのファイルを削除したあと、 SSH で接続しなおしてみてください。パスワード入力を求められることなくログインできるようになるはずです (なお、サーバ側の <filename>/etc/ssh/sshd_config</filename> ファイルで、 <literal>TrustedUserCAKeys /etc/ssh/<replaceable>ca-user-sign-key.pub</replaceable></literal> を設定していることをご確認ください。この設定で、信頼すべき証明機関を設定しています) 。</para>
   <para>また、サーバ内のログファイルに <literal>Accepted publickey for <replaceable>&exampleuserIII_plain;</replaceable></literal> が記録されていることも確認しておくとよいでしょう。</para>
  </sect2>

  <sect2 xml:id="sec-ssh-certificate-revoke-host-keys">
   <title>ホスト鍵の失効処理</title>
   <para>サーバが不正侵入を受けたり退役したりした場合は、証明書の失効処理を実施してホスト鍵の利用を停止する必要があります。このような場合は、各クライアント側の <filename>/etc/ssh/revoked-host-key</filename> ファイルなどに対応する公開鍵を指定します:</para>
   <screen>ssh-ed25519-cert-v01@openssh.com
    AAAAIHNzaC1lZDI1NTE5LWNlcnQtdjAxQG9wZW5zc2guY29tAAAAIK6hyvFAhFI+0hkKehF/
    506fD1VdcW29ykfFJn1CPK9lAAAAIAawaXbbEFiQOAe5LGclrCHSLWbEeUauK5+CAuhTJyz0
    AAAAAAAAAAAAAAACAAAAE2RiLXNlcnZlciBob3N0IGNlcnQAAAAeAAAABXZlbnVzAAAAEXZl
    bnVzLmV4YW1wbGUuY29tAAAAAGMabhQAAAAAYz9YgQAAAAAAAAAAAAAAAAAAADMAAAALc3No
    LWVkMjU1MTkAAAAgfWkXoM3gF2x9Qpa7KIa3+V4K+5n98+5jFjv7hXrwXPQAAABTAAAAC3Nz
    aC1lZDI1NTE5AAAAQI+mbJsQjt/9bLiURse8DF3yTa6Yk3HpoE2uf9FW/
    KeLsw2wPeDv0d6jv49Wgr5T3xHYPf+VPJQW35ntFiHTlQg= root@db
   </screen>
   <para>上記で作成したファイルは、 <filename>/etc/ssh/sshd_config</filename> 内で下記のようにして指定します:</para>
   <screen>RevokedKeys /etc/ssh/revoked_keys</screen>
  </sect2>
 </sect1>

 <sect1 xml:id="sec-ssh-gnome-keyring">
  <title>gnome-keyring を利用した公開鍵ログインの自動化</title>
  <para>GNOME デスクトップ環境をインストールすると、 <package>gnome-keyring</package> パッケージも自動的にインストールされ、有効化されます。 <package>gnome-keyring</package> はシステムのログインに統合され動作する仕組みであるため、ログイン時に自動的に機密記憶領域の保護が解除されます。ログイン時のパスワードを変更しても、 <literal>gnome-keyring</literal> はそれを自動的に認識して更新処理を行います。</para>
  <para><literal>gnome-keyring</literal> は <filename>~/.ssh</filename> ディレクトリ内にある全ての鍵対 (<filename>*.pub</filename> の形式の公開鍵があるもの) を自動的に読み込みます。その他のディレクトリ内にあるファイルを読み込みたい場合は、 <command>ssh-add</command> コマンドで読み込みを行ってください。たとえば下記のようになります:</para>
  <screen>&prompt.user;<command>ssh-add <replaceable>~/.otherkeys/my_key</replaceable></command>
   </screen>
  <para>読み込まれた全ての鍵を表示するには、下記のコマンドを実行します:</para>
  <screen>&prompt.user;<command>ssh-add -L</command></screen>
  <para>システムを起動して SSH セッションを開くと、機密鍵のパスフレーズの入力を促されます。</para>
   <para><literal>gnome-keyring</literal> はセッションを終了するまでの間パスフレーズを記憶します。そのため、システムを再起動しない限り、パスフレーズを再度入力する必要がなくなります。</para>
 </sect1>

  <sect1 xml:id="sec-ssh-authentic-agent">
   <title>ssh-agent を利用した公開鍵ログインの自動化</title>
   <para><package>openssh</package> パッケージには <command>ssh-agent</command> というユーティリティが付属しています。このユーティリティは、セッションが終了するまでの間だけ機密鍵とパスフレーズを記憶して、必要なときに自動的にそれを適用することができます。</para>
   <para><command>ssh-agent</command> をログイン時に自動的に起動して鍵を読み込むように設定したい場合は、 <filename>~/.profile</filename> ファイル内に下記のような行を記述します:</para>
   <screen>eval "$(ssh-agent)"
ssh-add</screen>
   <para>上記の行のうち、最初の行は <command>ssh-agent</command> を起動するコマンドで、次の行は <filename>~/.ssh</filename> ディレクトリ内にある全ての鍵を読み込むコマンドです。このように起動を行うことで、公開鍵認証が必要な SSH セッションを開始すると、最初の 1 回だけはパスフレーズの入力を求められます。その後はシステムを再起動するまでパスフレーズを記憶しますので、再入力を行う必要が無くなります。</para>
   <para>なお、特定の鍵のみを読み込むように設定したい場合は、下記のように <filename>~/.profile</filename> 内で <filename>id_rsa</filename> や <filename>id_ed25519</filename> のファイルを指定してください:</para>
   <screen>&prompt.user;ssh-add <replaceable>id_rsa id_ed25519</replaceable></screen>

   <sect2 xml:id="sec-ssh-authentic-agent-x">
    <title><command>ssh-agent</command> の X セッション内での利用</title>
    <para>&productname; では、 &gnome; ディスプレイマネージャを起動すると <command>ssh-agent</command> が自動的に開始されます。 X セッションの開始時に <command>ssh-add</command> で鍵を自動的に読み込むようにしたい場合は、下記のように実施します:</para>
    <procedure>
     <step>
      <para>まずは対象のユーザでログインし、 <filename>~/.xinitrc</filename> ファイルが存在しているかどうかを確認します。</para>
     </step>
     <step>
      <para>ファイルが存在していない場合、既存のテンプレートを使用するか、 <filename>/etc/skel</filename> 内にあるファイルをそのままコピーします:</para>
<screen>if [ -f ~/.xinitrc.template ]; then mv ~/.xinitrc.template ~/.xinitrc; \
else cp /etc/skel/.xinitrc.template ~/.xinitrc; fi</screen>
     </step>
     <step>
      <para>テンプレートをコピーした場合は、下記のような行を探してコメント文字を削除します。 <filename>~/.xinitrc</filename> ファイルが既に存在していた場合は、下記の内容を追記します (コメント文字は削除してください)。</para>
<screen># if test -S "$SSH_AUTH_SOCK" -a -x "$SSH_ASKPASS"; then
#       ssh-add &lt; /dev/null
# fi</screen>
     </step>
     <step>
      <para>あとは新しく X セッションを開始すると、 SSH のパスフレーズ入力を求められるようになります。</para>
     </step>
    </procedure>
   </sect2>
 </sect1>

 <sect1 xml:id="sec-ssh-change-passphrase">
  <title>SSH 機密鍵のパスフレーズ変更</title>
  <para>機密鍵に設定したパスフレーズを変更したり、パスフレーズを削除したりしたい場合は、 <command>ssh-keygen</command> コマンドを使用します:</para>
  <screen>&prompt.user;<command>ssh-keygen -pf ~/.ssh/<replaceable>server1</replaceable></command>
Enter old passphrase:
Key has comment 'shared videos server1'
Enter new passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved with the new passphrase.</screen>
 </sect1>

 <sect1 xml:id="sec-ssh-get-key-fingerprint">
  <title>鍵の指紋 (fingerprint) の取得</title>
  <para><command>ssh-keygen</command> コマンドを使用することで、公開鍵の指紋を表示することができます。下記の例では、 ED25519 鍵に対して SHA256 形式の指紋を表示しています:</para>
  <screen>&prompt.user;<command>ssh-keygen -lf <replaceable>ldap-server</replaceable></command>
256 SHA256:W45lbmj24ZoASbrqW0q9+NhF04muvfKZ+FkRa2cCiqo comment (ED25519)</screen>
  <para><command>-v</command> フラグを指定すると、 ASCII アート形式での鍵表示を行うこともできます:</para>
  <screen>&prompt.user;<command>ssh-keygen -lvf <replaceable>ldap-server</replaceable></command>
256 SHA256:W45lbmj24ZoASbrqW0q9+NhF04muvfKZ+FkRa2cCiqo comment (ED25519)
+--[ED25519 256]--+
|                 |
|                 |
|    .. .         |
|  .o..+ +        |
| ...o+ BSo+      |
|. ..o.o =X       |
|...o o..* =      |
|o.*.* =+ = .     |
|E*o*+O. o.o      |
+----[SHA256]-----+</screen>
</sect1>

  <sect1 xml:id="sec-ssh-programm-x">
   <title>ネットワーク上の離れたホストでの X11 アプリケーションの起動</title>
   <para>SSH では、ネットワーク上離れた場所にある X アプリケーションも簡単に使用することができます。接続先のマシンの <filename>/etc/ssh/sshd_config</filename> で <literal>X11Forwarding Yes</literal> を設定しておかなければなりませんが、 <command>ssh</command> コマンドに <option>-X</option> オプションを付けることで、接続先の <envar>DISPLAY</envar> 変数が自動的に設定され、全ての X 出力が SSH の接続を介してローカルマシンに表示されるようになります。それと同時に接続先で起動された X アプリケーションは、不正に傍受されたりできないようになります。</para>
   <para>たとえば下記のように実行することで、リモートのマシンでシンプルなゲームである GNOME Mines を動かすことができます:</para>
   <screen>&prompt.user;<command>ssh &exampleuserII_plain;@&exampleserver;</command>
Password:
Last login: Tue May 10 11:29:06 2022 from 192.168.163.13
Have a lot of fun...

&exampleuserII_plain;@&exampleserver;&prompt.user; <command>gnome-mines</command></screen>
   <para>起動したアプリケーションはローカルにインストールされているかのように、ローカル側に表示されるはずです (ただしネットワーク側の遅延があると、その分だけ性能に影響があります) 。アプリケーションの終了も通常と同じで、閉じるボタンを押すだけです。ただし、アプリケーションを閉じても SSH のセッションは終了せず、そのまま動作し続けます。</para>

   <important>
    <title>Wayland では X11 転送機能が使用できない問題について</title>
    <para>X11 転送機能を利用するには、接続先で X Window System が動作している必要があります。これは、 X Window System にはネットワーク機能が内蔵されているものの、 Wayland にはそのような機能が内蔵されていないことによるものです。</para>
    <para>X Window System で動作しているのか、それとも Wayland で動作しているかを確認するには、下記のように入力して実行します:</para>
    <screen>&prompt.user;<command>echo $XDG_SESSION_TYPE</command>
x11</screen>
    <para>Wayland で動作している場合は、下記のような出力になります:</para>
    <screen>&prompt.user;<command>echo $XDG_SESSION_TYPE</command>
wayland</screen>
    <para>systemd を利用して判断したい場合は、 <command>loginctl</command> コマンドを使用します:</para>
     <screen>&prompt.user;<command>loginctl show-session "$XDG_SESSION_ID" -p Type</command>
Type=x11

&prompt.user;<command>loginctl show-session "$XDG_SESSION_ID" -p Type</command>
Type=wayland</screen>
   </important>
  </sect1>

  <!-- this section needs improving and expanding -->
  <sect1 xml:id="sec-ssh-programm-forwarding">
   <title>エージェント転送</title>
   <para><option>-A</option> オプションを追加することで、 ssh-agent 認証の仕組みが接続先のマシンに引き継がれます。このオプションを使用することで、公開鍵を様々なホストに登録して適切な場所に保存しておくだけで、それらのホストにパスワード無しでログインできるようになります (詳しくは <xref linkend="sec-ssh-public-key-auth"/> をお読みください) 。</para>
   <para><filename>/etc/ssh/sshd_config</filename> では、既定で <literal>AllowAgentForwarding yes</literal> が設定されています。無効化したい場合は <literal>No</literal> に変更してください。</para>
 </sect1>

 <sect1 xml:id="sec-ssh-copy">
  <title><command>scp</command> - 機密を確保したファイルのコピー</title>
  <para><command>scp</command> は、指定したファイルをリモートのマシンとの間でコピーするプログラムです。 &wsI; 内でのユーザ名と &exampleserver; 内でのユーザ名が異なる場合は、 <option><replaceable>ユーザ名</replaceable>@<replaceable>ホスト名</replaceable></option> の形式で指定してください。また、ホームディレクトリ以外のディレクトリにファイルをコピーしたい場合は、 &exampleserver;: <replaceable>ディレクトリ</replaceable> の形式で指定してください。下記の例では、ローカルから接続先に、および接続先からローカルにそれぞれファイルをコピーしています。</para>

<screen>&prompt.user;scp ~/MyLetter.tex &exampleuser_plain;@&exampleserver;:/tmp <co xml:id="co-scp-local-remote"/>
&prompt.user;scp &exampleuser_plain;@&exampleserver;:/tmp/MyLetter.tex ~ <co xml:id="co-scp-remote-local"/></screen>
<calloutlist>
 <callout arearefs="co-scp-local-remote">
  <para>ローカルから接続先に</para>
</callout>
 <callout arearefs="co-scp-remote-local">
  <para>接続先からローカルに</para>
 </callout>
</calloutlist>
  <tip>
   <title><option>-l</option> オプションについて</title>
   <para><command>ssh</command> コマンドでは、 <option>-l</option> オプションを指定することで、接続先のコンピュータ内でのユーザを指定することができます (<option><replaceable>ユーザ名</replaceable>@<replaceable>ホスト名</replaceable></option> と同じ意味になります) 。 <command>scp</command> コマンドの場合、 <option>-l</option> は <command>scp</command> が消費する帯域を制限するためのオプションを意味しています。</para>
  </tip>

  <para>正しいパスワードの入力が行われると、 <command>scp</command> はデータ転送を開始します。進捗表示バーと、各ファイルの転送にかかる残り時間が表示されます。 <option>-q</option> オプションを指定すると、それらの出力を省略することができます。</para>

  <para><command>scp</command> はディレクトリ全体を再帰的にコピーする用途でも使用することができます:</para>

<screen>&prompt.user;scp -r src/ sun:backup/</screen>

  <para>上記のコマンドを実行すると、 <filename>src</filename> ディレクトリ内にある全てのファイルとサブディレクトリを、 &exampleserver; 内の <filename>~/backup</filename> ディレクトリにコピーします。サブディレクトリが存在していない場合は、それらは自動的に作成されます。</para>

  <para><option>-p</option> オプションは、 <command>scp</command> に対してファイルのタイムスタンプを変更しないようにするオプションです。 <option>-C</option> はデータ転送を圧縮するよう指示するオプションです。これにより転送の際のデータ量を減らすことができますが、送信側・受信側両方のホストでプロセッサにかかる負荷が上昇します。</para>
 </sect1>

 <sect1 xml:id="sec-ssh-sftp">
  <title><command>sftp</command> - 機密を保持したファイルの転送</title>

  <sect2 xml:id="sec-ssh-sftp-using">
   <title><command>sftp</command> の使用</title>
  <para>複数のファイルをコピーしたい場合や、異なる場所からコピーを行いたい場合は、 <command>scp</command> の代わりに <command>sftp</command> を利用したほうが便利になることがあります。このコマンドは、通常の FTP プロトコルと同様に、様々なコマンドを実行できるシェルを開くことができます。利用可能なコマンドの一覧を取得したい場合は、 sftp のプロンプトで <command>help</command> と入力してください。より詳しい詳細は、 <command>sftp</command> のマニュアルページに書かれています。</para>

<screen>&prompt.user;sftp &exampleserver;
Enter passphrase for key '/home/&exampleuser_plain;/.ssh/id_rsa':
Connected to &exampleserver;.
sftp&gt; help
Available commands:
bye                                Quit sftp
cd path                            Change remote directory to 'path'
[...]</screen>
  </sect2>
  <sect2 xml:id="sec-ssh-sftp-perms">
   <title>ファイルアップロードのパーミッション設定</title>
   <para>通常の FTP サーバと同様に、ユーザは SFTP を利用することで、ダウンロードやアップロードを行うことができます。コマンドも通常の FTP サーバと同じで、 たとえばアップロードであれば <command>put</command> コマンドを利用します。既定では、アップロードしたファイルのパーミッションは、ローカル側のパーミッションと同じに設定されます。ただし、自動的に設定されるパーミッションを変更したい場合は、下記のいずれかを実施してください:</para>
   <variablelist>
    <varlistentry>
     <term>umask の設定</term>
     <listitem>
      <para>umask はパーミッションに対するフィルタとして動作する仕組みで、元々のファイルとアップロード先のファイルとの間で、引き継いで欲しくないビットを 1 にします。なお、アクセス許可を追加することはできません。取り消すことのみ実現できます:</para>
      <informaltable>
       <tgroup cols="3">
        <colspec colnum="1" colname="1" colwidth="33*"/>
        <colspec colnum="2" colname="2" colwidth="33*"/>
        <colspec colnum="3" colname="3" colwidth="33*"/>
        <thead>
         <row>
          <entry>
           <para>元々のパーミッション</para>
          </entry>
          <entry>
           <para>umask の値</para>
          </entry>
          <entry>
           <para>アップロードされたファイルのパーミッション</para>
          </entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry>
           <para>0666</para>
          </entry>
          <entry>
           <para>0002</para>
          </entry>
          <entry>
           <para>0664</para>
          </entry>
         </row>
         <row>
          <entry>
           <para>0600</para>
          </entry>
          <entry>
           <para>0002</para>
          </entry>
          <entry>
           <para>0600</para>
          </entry>
         </row>
         <row>
          <entry>
           <para>0775</para>
          </entry>
          <entry>
           <para>0025</para>
          </entry>
          <entry>
           <para>0750</para>
          </entry>
         </row>
        </tbody>
       </tgroup>
      </informaltable>
      <para>SFTP サーバ側で umask を適用するには、 <!-- NOTE: sshd_config (not sshd_configuration? --><filename>/etc/ssh/sshd_configuration</filename> ファイルを編集します。まずは <literal>Subsystem sftp</literal> で始まる行を探し、行の末尾に <option>-u</option> オプションを追加して、必要な値を指定してください。たとえば下記のようになります:</para>
<screen>Subsystem sftp /usr/lib/ssh/sftp-server -u 0002</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>明示的なパーミッションの指定</term>
     <listitem>
      <para>SFTP 経由でアップロードされた全てのファイルに対して、同じパーミッションを設定するように指定する方法です。 <option>-u</option> オプションと同様に、 <literal>600</literal> , <literal>644</literal> , <literal>755</literal> のような 3 桁のパーミッション値を指定してください。 <option>-m</option> と <option>-u</option> の両方が指定された場合、 <literal>-u</literal> は無視されます。</para>
      <para>SFTP サーバ側で明示的にパーミッションを指定するには、  <filename>/etc/ssh/sshd_config</filename> ファイルを編集します。まずは <literal>Subsystem sftp</literal> で始まる行を探し、行の末尾に <option>-m</option> オプションを追加して、必要な値を指定してください。たとえば下記のようになります:</para>
<screen>Subsystem sftp /usr/lib/ssh/sftp-server -m 600</screen>
     </listitem>
    </varlistentry>
   </variablelist>

  <tip>
   <title>SSH デーモンのログファイル表示</title>
   <para><systemitem class="daemon">sshd</systemitem> が出力したログを表示したい場合は、下記のコマンドを実行します:</para>
   <screen>&prompt.sudo;journalctl -u sshd</screen>
   </tip>
  </sect2>
 </sect1>

 <sect1 xml:id="sec-ssh-port-forwarding">
  <title>ポート転送 (SSH トンネリング)</title>

  <para><command>ssh</command> は TCP/IP 接続を転送するような用途でも使用することができます。この機能は <literal>SSH トンネリング</literal> とも呼ばれ、暗号化された通信を介して TCP の接続を別のマシン内にある特定のポートに転送することができます。</para>

  <para>下記のコマンドを実行することで、 <!-- NOTE: wrong explanation? --> ローカルの TCP ポート 25 (SMTP) への接続を行うと、 &wsI; への暗号化接続を介して &exampleserver; の TCP ポート 25 (SMTP) に接続するようになります。これは特に、 SMTP-AUTH や POP-before-SMTP のような機能を持たない SMTP サーバを使用するような場合に有用です。 <!-- NOTE: bind adress must be set to "0.0.0.0" in order to be connected from network, i.e. "-L 0.0.0.0:25:&exampleserver;:25" -->このようにポート転送を行うことで、電子メールを <quote>自宅の</quote> メールサーバに配送するような構成を構築することができます。</para>

<screen>&prompt.root;ssh -L 25:&exampleserver;:25 &wsI;</screen>

  <para>上記と同様に、全ての POP3 接続 (ポート 110) を &exampleserver; に転送したい場合は、下記のように実行します:</para>

<screen>&prompt.root;ssh -L 110:&exampleserver;:110 &wsI;</screen>

  <para>いずれのコマンドも特権ポートを使用していることから、 &rootuser; で実行しなければなりません。いったんコマンドを実行すれば、一般ユーザからもそのポートを使用して電子メールを送受信できるようになります。この場合、電子メールソフトウエア側のサーバ設定は <literal>localhost</literal> を指定します。上記で説明したそれぞれのプログラムのオプションに関する説明は、 <filename>/usr/share/doc/packages/openssh</filename> 内にある OpenSSH のパッケージドキュメンテーション内にあります。</para>
 </sect1>

 <sect1 xml:id="sec-security-ssh-moreinfo">
  <title>さらなる情報</title>

  <para/>

  <variablelist>
   <varlistentry>
    <term><link xlink:href="https://www.openssh.com"/></term>
    <listitem>
     <para>OpenSSH の Web ページ</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><link xlink:href="https://en.wikibooks.org/wiki/OpenSSH"/></term>
    <listitem>
     <para>OpenSSH Wikibook (英語)</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>man sshd</command></term>
    <listitem>
     <para>OpenSSH デーモンのマニュアルページ</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>man ssh_config</command></term>
    <listitem>
     <para>OpenSSH のクライアント側設定ファイルのマニュアルページ</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>man scp</command></term>
    <term><command>man sftp</command></term>
    <term><command>man ssh</command></term>
    <term><command>man ssh-add</command></term>
    <term><command>man ssh-copy-id</command></term>
    <term><command>man ssh-keygen</command></term>
    <listitem>
     <para>ファイルコピー ( <command>scp</command> , <command>sftp</command> ) やログイン ( <command>slogin</command> , <command>ssh</command> ) 、鍵管理などのコマンドに対するマニュアルページ。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><filename>/usr/share/doc/packages/openssh-common/README.SUSE</filename></term>
    <term os="sles;sled;slemicro"><filename>/usr/share/doc/packages/openssh-common/README.FIPS</filename></term>
    <listitem>
     <para>&suse; 固有のパッケージドキュメンテーション; <phrase os="sles;sled;slemicro">FIPS モードなど、</phrase> 提供元からの既定値の変更点などを説明しています。</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec-security-ssh-fail2ban">
  <title>fail2ban による SSH ブルートフォース攻撃の抑止</title>
  <para>SSH ブルートフォース攻撃とは、様々なユーザ名とパスワードの組み合わせでログインを試すことにより、ネットワーク経由でサーバへの不正侵入を試みるものです。攻撃者は自動化されたツールを利用して侵入を試みるため、膨大な数のユーザ名とパスワードの組み合わせを試すことができてしまいます。</para>
 <para>このような不正侵入を防ぐには、 fail2ban と呼ばれるソフトウエアを使用します。 fail2ban は定期的にシステムログを検索して攻撃を検知し、ファイアウオールで接続元の IP アドレスからのアクセスを禁止するなど、その攻撃内容に応じた処理を実施します。なお fail2ban は、ユーザ名とパスワードを使用するサービスを保護するためだけに使用することができます。</para>
  <sect2 xml:id="sec-ssh-what-fail2ban">
  <title>fail2ban とは？</title>
  <para>fail2ban は <filename>/var/log/apache/error_log</filename> 等のログファイルを定期的に検索し、繰り返し何度もログインを試しているような不正アクセスの端緒を検出し、 IP アドレス単位でのアクセス禁止を設定することができます。 fail2ban ではファイアウオールルールを設定して、一定時間のアクセス禁止を実現しています。</para>
    <para>fail2ban は Apache, SSH, Courier など、様々なサービスに対応するフィルタが提供されています。 fail2ban を利用することで、不正アクセスを未然に減らすことができるようになります。</para>
  </sect2>
  <sect2 xml:id="sec-security-ssh-fail2ban-use">
    <title>SSH ブルートフォース攻撃を抑止するための fail2ban の使用</title>
    <para>fail2ban をインストールして設定しておくことで、 SSH ブルートフォース攻撃からサーバを保護することができます。</para>
    <procedure>
      <title>SSH ブルートフォース攻撃を抑止するための fail2ban の使用</title>
      <step><para>fail2ban をインストールするには、下記のようなコマンドを入力して実行します:</para>
        <screen>&prompt.root;sudo zypper -n in fail2ban firewalld</screen>
      </step>
      <step><para>fail2ban をインストールすると、既定の設定ファイルである <filename>jail.conf</filename> がインストールされますが、このファイルは fail2ban パッケージの更新で上書きされてしまう仕組みであることから、このファイルに直接設定を記述してはなりません。その代わりに、 <emphasis>jail.local</emphasis> というファイルを作成して設定してください。 fail2ban では両方のファイルを読み込むようになっています。</para>
      <screen>&prompt.root;cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local</screen>
    </step>
    <step><para>まずはエディタでファイルを開きます。</para>
    <screen>vi /etc/fail2ban/jail.local</screen>
  </step>
<step><para>設定項目のうち、知っておかなければならない項目は 4 種類になります。</para>
<figure xml:id="fig-fail2ban-jail-local">
  <title><emphasis>jail.local </emphasis> ファイルの設定</title>
  <mediaobject>
   <imageobject role="fo">
    <imagedata width="75%" fileref="fail2ban.png"/>
   </imageobject>
   <imageobject role="html">
    <imagedata fileref="fail2ban.png"/>
      </imageobject>
      <textobject role="description"><phrase>fail2ban の設定</phrase></textobject>
  </mediaobject>
 </figure>
 <variablelist>
  <varlistentry><term><emphasis>ignoreip</emphasis></term>
<listitem><para>アクセスを禁止したくない IP アドレスの一覧を指定します。既定では IPv4 アドレスの <emphasis>127.0.0.1</emphasis> と IPv6 アドレスの <emphasis>::1</emphasis> (いずれも自分自身を表すアドレスです) が設定されています。それ以外にもアクセスを禁止したくないアドレスがある場合は、ここに追加してください。</para>
</listitem>
</varlistentry>
<varlistentry><term><emphasis>bantime</emphasis></term>
  <listitem><para>特定の IP アドレスからのアクセスを禁止する際、その禁止期間を指定します。設定値が <emphasis>m</emphasis> (分) または <emphasis>h</emphasis> (時間) で終わっていない場合、禁止期間は秒単位であるものとして解釈されます。また、 <emphasis>-1</emphasis> を設定すると、恒久的にアクセスを禁止することになります。</para>
  </listitem>
  </varlistentry>
  <varlistentry><term><emphasis>findtime</emphasis></term>
    <listitem><para>特定の IP アドレスからのアクセスを禁止するにあたっての持続時間を指定します。</para>
    </listitem>
    </varlistentry>
    <varlistentry><term><emphasis>maxretry</emphasis></term>
      <listitem><para>試行失敗の上限回数を指定します。</para>
             </listitem>
      </varlistentry>
</variablelist>
<note><para>同じ IP アドレスからのアクセスが <emphasis>findtime</emphasis> で指定した時間内に <emphasis>maxretry</emphasis> で指定した回数以上実施された場合、 <emphasis>bantime</emphasis> で指定した時間だけアクセスを禁止することになります。なお、 <emphasis>ignoreip</emphasis> に含まれる IP アドレスについては除外されます。</para></note>

<para>fail2ban では様々な種類の jail に対応しています。 jail とは設定の単位で、それぞれが様々な種類の接続に対応しています。</para>
</step>
<step><para>fail2ban サービスを有効化や起動は、下記のようにして行います:</para>
  <para>サービスを有効化するには:</para>
  <screen>&prompt.root; systemctl enable fail2ban</screen>
  <para>起動するには:</para>
  <screen>&prompt.root; systemctl start fail2ban</screen>
  <para>サービスの状態を確認するには:</para>
  <screen>&prompt.root; systemctl status fail2ban.service</screen>
  <important><para>なお、設定を変更した場合は fail2ban の再起動を実施しなければならないことに注意してください。</para></important>
  </step>

    </procedure>
  </sect2>
  </sect1>
</chapter>
