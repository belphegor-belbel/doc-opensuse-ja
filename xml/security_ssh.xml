<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter [
<!ENTITY % entities SYSTEM "generic-entities.ent">
%entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="ja" xml:id="cha-ssh">

 <title>OpenSSH によるネットワーク操作の機密保持</title>
 <info>
  <abstract>
   <para>OpenSSH は &sles; に同梱される SSH (secure shell) 実装で、遠隔からの管理やファイル転送、機密を保持できないプロトコルへの機密トンネル設定など、さまざまな機能を提供するソフトウエアです。 SSH は認証を含む全ての通信を暗号化しますので、盗聴や接続の乗っ取りなどの被害から通信を保護することができます。本章では基本的な操作のほか、ホスト鍵の切り替えや証明書認証など、特に大規模展開向けに便利な機能を説明しています。</para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker>
   </dm:bugtracker>
  </dm:docmanager>
 </info>

 <sect1 xml:id="sec-ssh-overview">
  <title>OpenSSH の概要</title>
  <para>SSH はエンドツーエンドで通信を保護するためのプロトコルで、お使いのネットワーク内同士だけでなく、外部のネットワークとの通信も保護することができます。なお、 SSH はクライアント／サーバ型のプロトコルであり、他のホストからの接続を受け付けるには <systemitem class="daemon">sshd</systemitem> デーモンを動作させておく必要があります。また、各ホストで動作する <systemitem class="daemon">sshd</systemitem> にはそれぞれ独自の設定を行うことができますので、アクセス可能なユーザを制限したり、許可する認証プロトコルを制限したりすることもできるようになっています。</para>
  <para><package>openssh</package> パッケージにはサーバとクライアントのほか、ファイル転送コマンドと支援系のユーティリティが含まれています。</para>
  <para>OpenSSH では下記のような認証方式に対応しています:</para>
  <variablelist>
   <varlistentry>
    <term>パスワード認証</term>
    <listitem>
     <para>ユーザ名とパスワードで認証する方式です。接続先のホストにユーザアカウントを作成しておく必要があります。この方式は、 SSH のセッションをどのマシンからでも受け付けることができますので、最も単純で柔軟な認証方式です。ただし、パスワードクラッキングには弱く、キーロガーなどによる窃取にも弱いため、機密性は低くなります。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>公開鍵認証</term>
    <listitem>
     <para>パスワードではなく、個人単位で鍵を設定して認証を行う方式です。公開鍵に対応する機密鍵を持つホストからしかログインできない仕組みであるため、パスワード認証に比べると柔軟性が落ちますが、パスワードクラッキングに強く、キーロガーなどによる窃取も回避できますので、パスワード認証よりはずっと強力です。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
     <term>パスフレーズ無しの公開鍵認証</term>
     <listitem>
      <para>機密鍵に対してパスフレーズを設定せずに公開鍵認証を使用する方式です。スクリプトや cron ジョブなどの自動化されたサービスで便利な方式です。ただし、機密鍵はきちんと保護しておかないと、容易にそのユーザになりすましてログインできてしまうので、注意が必要です。</para>
      <para>なお、 <command>ssh-agent</command> と関連するユーティリティを利用して、パスフレーズで保護した鍵を使用する方法もあります。この場合、パスフレーズはメモリ内に保持され、必要に応じてパスフレーズを提供します。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>証明書認証</term>
     <listitem>
      <para>OpenSSH では証明書認証にも対応しています。これにより、鍵の管理と大規模な SSH 展開が容易になっています。</para>
     </listitem>
    </varlistentry>
   </variablelist>

 <para>&productname; では既定で OpenSSH パッケージをインストールします。パッケージ内には、下記のようなファイルが含まれています:</para>

 <variablelist>
  <varlistentry>
   <term><command>ssh</command></term>
   <listitem>
    <para>遠隔のホストに対して SSH 接続を開始するためのクライアント側コマンドです。</para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><command>scp</command></term>
   <listitem>
    <para>遠隔のホストとの間でファイルをやり取りするためのコマンドです。</para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><command>sftp</command></term>
   <listitem>
    <para>クライアントと SFTP サーバとの間でファイルを送受信するためのコマンドです。<!--the SFTP protocol (SSH FTP), a protocol made from scratch and that has nothing to do with FTPS or FTPES (FTP over SSL / TLS).--></para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><command>ssh-add</command></term>
   <listitem>
    <para><command>ssh-agent</command> コマンドで動作する認証エージェントに対して、機密鍵の情報を追加するためのコマンドです。</para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><command>ssh-agent</command></term>
   <listitem>
    <para>公開鍵認証で使用する、ユーザの機密鍵とパスフレーズを管理するためのエージェントです。 <command>ssh-agent</command> はパスフレーズをメモリ内に保持し、必要に応じてパスフレーズを提供します。</para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><command>ssh-copy-id</command></term>
   <listitem>
    <para>公開鍵認証を設定して、公開鍵を遠隔のホストにコピーするコマンドです。</para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><command>ssh-keyscan</command></term>
   <listitem>
    <para>複数のホストにある SSH ホスト鍵を収集するコマンドです。 <filename>known_hosts</filename> ファイルの作成用に提供されているものです。</para>
   </listitem>
  </varlistentry>
 </variablelist>
</sect1>

<sect1 xml:id="sec-ssh-server-config">
 <title>サーバのセキュリティ強化</title>
 <para>OpenSSH はインストール当初の状態でそれなりに強固な設定になっていますが、サーバのセキュリティを強化するための追加設定も用意されています。</para>
 <para>既定のサーバ設定は <filename>/etc/ssh/sshd_config</filename> で、ここには既定で使用される設定が書かれています。また、コメント内には全ての既定値が示されています。既定値を変更したい場合は、これらのコメント文字を外してから、必要な設定を記述してください。たとえば下記の例では、待ち受けるポートと IPv4 アドレスを変更しています:</para>
 <screen>
#Port 22
Port <replaceable>2022</replaceable>

#ListenAddress 0.0.0.0
ListenAddress <replaceable>192.168.10.100</replaceable></screen>
 <para>なお、下記の <filename>/etc/ssh/sshd_config</filename> ファイル例は、アクセス制御をより強化した設定例です:</para>
 <screen># Check if the file modes and ownership of the user’s files and
# home directory are correct before allowing them to login
StrictModes yes

# If your machine has more than one IP address, define which address or
# addresses it listens on
ListenAddress <replaceable>192.168.10.100</replaceable>

# Allow only members of the listed groups to log in
AllowGroups <replaceable>ldapadmins backupadmins</replaceable>

# Or, deny certain groups. If you use both, DenyGroups is read first
DenyGroups <replaceable>users</replaceable>

# Allow or deny certain users. If you use both, DenyUsers is read first
AllowUsers <replaceable>user1 user2 user3</replaceable>
DenyUsers <replaceable>user4</replaceable>

# Allow root logins only with public key authentication
PermitRootLogin prohibit-password

# Disable password authentication and allow only public key authentication
# for all users
PasswordAuthentication no</screen>

 <para><filename>/etc/ssh/sshd_config</filename> ファイルを変更したあとは、下記のようにして文法チェックを行ってください:</para>
 <screen>&prompt.sudo;<command>sshd -t</command></screen>
 <para>なお、文法チェック機能は文法のみをチェックする仕組みであり、設定の誤りは検出されないことに注意してください。チェック完了後は下記のように入力して実行することで、設定を再読み込みさせることができます:</para>
 <screen>&prompt.sudo;<command>systemctl reload sshd.server</command></screen>
 <para>サーバの鍵ディレクトリに適切なパーミッションが設定されていることを確認します。</para>
 <para><filename>/etc/ssh</filename> ディレクトリには 0755/drwxr-xr-x のパーミッションが設定され、 root が所有するディレクトリでなければいけません。</para>
 <para>機密鍵には 0600/-rw------- のパーミッションが設定され、 root が所有していなければなりません。</para>
 <para>公開鍵には 0644/-rw-r--r-- のパーミッションが設定され、 root が所有していなければなりません。</para>
</sect1>

<sect1 xml:id="sec-ssh-programm">
  <title>パスワード認証</title>
  <para><command>ssh</command> コマンドを使用することで、ネットワーク上離れたシステムにログインして対話的な作業を行うことができます。たとえば &exampleuser; というユーザ名で <literal>&exampleserver;</literal> というホストにログインしたい場合は、下記のいずれかのコマンドを実行します:</para>

<screen>&prompt.user;<command>ssh &exampleuser_plain;@&exampleserver;</command>
&prompt.user;<command>ssh -l &exampleuser_plain; &exampleserver;</command></screen>

  <para><literal>exit</literal> と入力して Enter を押すと、 SSH セッションを終了することができます。</para>

  <para>両方のマシンでユーザ名が同じであれば、ユーザ名を指定する必要はありません。 <command>ssh &exampleserver;</command> のように入力して実行するだけで済みます。このコマンドを実行すると、パスワードの入力が求められますので、相手側のコンピュータでのパスワードを入力してください。認証が成功すると、相手側のコンピュータのコマンドラインを使用したり、 &yast; のテキストモードのような対話的なアプリケーションを使用したりすることができるようになります。</para>

  <para>これらに加えて、 <command>ssh</command> では <command>ssh</command> <replaceable>ユーザ名</replaceable>@<replaceable>ホスト</replaceable> <replaceable>コマンド</replaceable> のように入力して実行することで、対話操作を伴わないコマンドの実行にも対応しています。なお、 <replaceable>コマンド</replaceable> では適切に引用符を指定する必要があります。また、複数のコマンドはローカルのシェルと同じ方法で繋げることができます。</para>

<screen>&prompt.user;<command>ssh root@&exampleserver; "dmesg -T | tail -n 25"</command>
&prompt.user;<command>ssh root@&exampleserver; "cat /etc/os-release &amp;&amp; uptime"</command></screen>

  <sect2 xml:id="sec-ssh-programm-x">
   <title>ネットワーク上の離れたホストでの X11 アプリケーションの起動</title>
   <para>SSH では、ネットワーク上離れた場所にある X アプリケーションも簡単に使用することができます。接続先のマシンの <filename>/etc/ssh/sshd_config</filename> で <literal>X11Forwarding Yes</literal> を設定しておかなければなりませんが、 <command>ssh</command> コマンドに <option>-X</option> オプションを付けることで、接続先の <envar>DISPLAY</envar> 変数が自動的に設定され、全ての X 出力が SSH の接続を介してローカルマシンに表示されるようになります。それと同時に接続先で起動された X アプリケーションは、不正に傍受されたりできないようになります。</para>
   <para>たとえば下記のように実行することで、リモートのマシンでシンプルなゲームである GNOME Mines を動かすことができます:</para>
   <screen>&prompt.user;<command>ssh &exampleuser_plain;@&exampleserver;</command>
Password:
Last login: Tue May 10 11:29:06 2022 from 192.168.163.13
Have a lot of fun...

&exampleuser_plain;@&exampleserver; gnome-mines</screen>
   <para>起動したアプリケーションはローカルにインストールされているかのように、ローカル側に表示されるはずです (ただしネットワーク側の遅延があると、その分だけ性能に影響があります)。アプリケーションの終了も通常と同じで、閉じるボタンを押すだけです。ただし、アプリケーションを閉じても SSH のセッションは終了せず、そのまま動作し続けます。</para>

   <important>
    <title>Wayland では X11 転送機能が使用できない問題について</title>
    <para>X11 転送機能は &slea; での既定値である X Window System の機能を使用しており、 Wayland ディスプレイサーバプロトコルには対応していません。これは、 Wayland がネットワークに対応していないことによるものです。</para>
    <para>X Window System で動作しているのか、それとも Wayland で動作しているかを確認するには、下記のように入力して実行します:</para>
    <screen>&prompt.user;<command>echo $XDG_SESSION_TYPE</command>
x11</screen>
    <para>Wayland で動作している場合は、下記のような出力になります:</para>
    <screen>&prompt.user;<command>echo $XDG_SESSION_TYPE</command>
wayland</screen>
   </important>
  </sect2>

  <!-- this section needs improving and expanding -->
  <sect2 xml:id="sec-ssh-programm-forwarding">
   <title>エージェント転送</title>
   <para><option>-A</option> オプションを追加することで、 ssh-agent 認証の仕組みが接続先のマシンで有効化されます。このオプションを使用することで、公開鍵を様々なホストに登録して適切な場所に保存しておくだけで、それらのホストにパスワード無しでログインできるようになります (詳しくは <xref linkend="sec-ssh-authentic-key-copy"/> をお読みください) 。</para>
<!--
   <para>
    <literal>AllowAgentForwarding yes</literal> is the default in
    <filename>/etc/ssh/sshd_config</filename>. Change it to
    <literal>No</literal> to disable it.
   </para> -->
  </sect2>
 </sect1>

 <sect1 xml:id="sec-ssh-copy">
  <title><command>scp</command> - 機密を確保したファイルのコピー</title>
  <para><command>scp</command> は、指定したファイルをリモートのマシンとの間でコピーするプログラムです。 &wsI; 内でのユーザ名と &exampleserver; 内でのユーザ名が異なる場合は、 <option><replaceable>ユーザ名</replaceable>@<replaceable>ホスト名</replaceable></option> の形式で指定してください。また、ホームディレクトリ以外のディレクトリにファイルをコピーしたい場合は、 &exampleserver;: <replaceable>ディレクトリ</replaceable> の形式で指定してください。下記の例では、ローカルから接続先に、および接続先からローカルにそれぞれファイルをコピーしています。</para>

<screen>&prompt.user;scp ~/MyLetter.tex &exampleuser_plain;@&exampleserver;:/tmp <co xml:id="co-scp-local-remote"/>
&prompt.user;scp &exampleuser_plain;@&exampleserver;:/tmp/MyLetter.tex ~ <co xml:id="co-scp-remote-local"/></screen>
<calloutlist>
 <callout arearefs="co-scp-local-remote">
  <para>ローカルから接続先に</para>
</callout>
 <callout arearefs="co-scp-remote-local">
  <para>接続先からローカルに</para>
 </callout>
</calloutlist>
  <tip>
   <title><option>-l</option> オプションについて</title>
   <para><command>ssh</command> コマンドでは、 <option>-l</option> オプションを指定することで、接続先のコンピュータ内でのユーザを指定することができます (<option><replaceable>ユーザ名</replaceable>@<replaceable>ホスト名</replaceable></option> と同じ意味になります) 。 <command>scp</command> コマンドの場合、 <option>-l</option> は <command>scp</command> が消費する帯域を制限するためのオプションを意味しています。</para>
  </tip>

  <para>正しいパスワードの入力が行われると、 <command>scp</command> はデータ転送を開始します。進捗表示バーと、各ファイルの転送にかかる残り時間が表示されます。 <option>-q</option> オプションを指定すると、それらの出力を省略することができます。</para>

  <para><command>scp</command> はディレクトリ全体を再帰的にコピーする用途でも使用することができます:</para>

<screen>&prompt.user;scp -r src/ sun:backup/</screen>

  <para>上記のコマンドを実行すると、 <filename>src</filename> ディレクトリ内にある全てのファイルとサブディレクトリを、 &exampleserver; 内の <filename>~/backup</filename> ディレクトリにコピーします。サブディレクトリが存在していない場合は、それらは自動的に作成されます。</para>

  <para><option>-p</option> オプションは、 <command>scp</command> に対してファイルのタイムスタンプを変更しないようにするオプションです。 <option>-C</option> はデータ転送を圧縮するよう指示するオプションです。これにより転送の際のデータ量を減らすことができますが、送信側・受信側両方のホストでプロセッサにかかる負荷が上昇します。</para>
 </sect1>
 <sect1 xml:id="sec-ssh-sftp">
  <title><command>sftp</command> - 機密を保持したファイルの転送</title>

  <sect2 xml:id="sec-ssh-sftp-using">
   <title><command>sftp</command> の使用</title>
  <para>複数のファイルをコピーしたい場合や、異なる場所からコピーを行いたい場合は、 <command>scp</command> の代わりに <command>sftp</command> を利用したほうが便利になることがあります。このコマンドは、通常の FTP プロトコルと同様に、様々なコマンドを実行できるシェルを開くことができます。利用可能なコマンドの一覧を取得したい場合は、 sftp のプロンプトで <command>help</command> と入力してください。より詳しい詳細は、 <command>sftp</command> のマニュアルページに書かれています。</para>

<screen>&prompt.user;sftp &exampleserver;
Enter passphrase for key '/home/&exampleuser_plain;/.ssh/id_rsa':
Connected to &exampleserver;.
sftp&gt; help
Available commands:
bye                                Quit sftp
cd path                            Change remote directory to 'path'
[...]</screen>
  </sect2>
  <sect2 xml:id="sec-ssh-sftp-perms">
   <title>ファイルアップロードのパーミッション設定</title>
   <para>通常の FTP サーバと同様に、ユーザは SFTP を利用することで、ダウンロードだけでなくアップロードも行うことができます。コマンドは通常の FTP サーバと同じで、 <command>put</command> コマンドを利用します。既定では、アップロードしたファイルのパーミッションは、ローカル側のパーミッションと同じに設定されます。ただし、自動的に設定されるパーミッションを変更したい場合は、下記のいずれかを実施してください:</para>
   <variablelist>
    <varlistentry>
     <term>umask の設定</term>
     <listitem>
      <para>umask はパーミッションに対するフィルタとして動作する仕組みで、元々のファイルとアップロード先のファイルとの間で、引き継いで欲しくないビットを 1 にします。なお、アクセス許可を追加することはできません。取り消すことのみ実現できます:</para>
      <informaltable>
       <tgroup cols="3">
        <colspec colnum="1" colname="1" colwidth="33*"/>
        <colspec colnum="2" colname="2" colwidth="33*"/>
        <colspec colnum="3" colname="3" colwidth="33*"/>
        <thead>
         <row>
          <entry>
           <para>元々のパーミッション</para>
          </entry>
          <entry>
           <para>umask の値</para>
          </entry>
          <entry>
           <para>アップロードされたファイルのパーミッション</para>
          </entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry>
           <para>0666</para>
          </entry>
          <entry>
           <para>0002</para>
          </entry>
          <entry>
           <para>0664</para>
          </entry>
         </row>
         <row>
          <entry>
           <para>0600</para>
          </entry>
          <entry>
           <para>0002</para>
          </entry>
          <entry>
           <para>0600</para>
          </entry>
         </row>
         <row>
          <entry>
           <para>0775</para>
          </entry>
          <entry>
           <para>0025</para>
          </entry>
          <entry>
           <para>0750</para>
          </entry>
         </row>
        </tbody>
       </tgroup>
      </informaltable>
      <para>SFTP サーバ側で umask を適用するには、 <!-- NOTE: sshd_config (not sshd_configuration? --><filename>/etc/ssh/sshd_configuration</filename> ファイルを編集します。まずは <literal>Subsystem sftp</literal> で始まる行を探し、行の末尾に <option>-u</option> オプションを追加して、必要な値を指定してください。たとえば下記のようになります:</para>
<screen>Subsystem sftp /usr/lib/ssh/sftp-server -u 0002</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>明示的なパーミッションの指定</term>
     <listitem>
      <para>SFTP 経由でアップロードされた全てのファイルに対して、同じパーミッションを設定するように指定する方法です。 <option>-u</option> オプションと同様に、 <literal>600</literal> , <literal>644</literal> , <literal>755</literal> のような 3 桁のパーミッション値を指定してください。 <option>-m</option> と <option>-u</option> の両方が指定された場合、 <literal>-u</literal> は無視されます。</para>
      <para>SFTP サーバ側で明示的にパーミッションを指定するには、  <!-- NOTE: sshd_config (not sshd_configuration? --><filename>/etc/ssh/sshd_configuration</filename> ファイルを編集します。まずは <literal>Subsystem sftp</literal> で始まる行を探し、行の末尾に <option>-m</option> オプションを追加して、必要な値を指定してください。たとえば下記のようになります:</para>
<screen>Subsystem sftp /usr/lib/ssh/sftp-server -m 600</screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-ssh-sshdserver">
  <title>SSH デーモン ( <systemitem class="daemon">sshd</systemitem> )</title>

  <para><command>ssh</command> や <command>scp</command> などのクライアント側プログラムを動作させるには、サーバ側で SSH デーモンを動作させておかなければなりません。 SSH デーモンは通常、裏で動く仕組みで、 <literal>TCP/IP ポート 22</literal> で接続を待ち受けています。デーモンは初回の起動時にホスト側の鍵対を作成しますが、それぞれの鍵対には公開鍵と機密鍵が含まれています。そのため、この処理は公開鍵ベースの鍵の生成と呼ばれます。また、 SSH を介した通信の機密が保たれるようにするため、機密鍵を含むファイルへのアクセスは、システム管理者にのみ許可するように設定しなければなりません。ただし、ファイルへのアクセス権は自動的に設定されます。さらに、機密鍵はローカルの SSH デーモンのみが使用するものであり、それ以外のユーザに公開してはなりません。逆に公開鍵 (ファイル名の拡張子が <filename>.pub</filename> になっているもの) は、接続を行うクライアントに送信されるものであり、全てのユーザから読み込むことができるようになっています。</para>

  <para>接続は SSH クライアント側から行います。その後、待ち受けている SSH デーモンと SSH クライアントとの間でプロトコルとソフトウエアバージョンを含む識別情報を交換し、誤ったポートからの接続が行われないようにします。 SSH デーモンの子プロセスが要求に応答する仕組みであるため、複数の SSH 接続を同時に受け付けることができるようになっています。</para>

  <para>セッション鍵を解読するには、ホスト鍵とサーバ鍵の両方の機密鍵が必要となるほか、機密鍵は公開鍵からは生成できない性質があります。そのため、通信相手となっている SSH デーモンのみがセッション鍵を解読できることになります。このような接続当初の動作は、 SSH クライアント側で <option>-v</option> オプションを指定して冗長出力を行うことで、より詳しく表示することができます。</para>

  <tip>
   <title>SSH デーモンのログファイルの表示について</title>
   <para><systemitem class="daemon">sshd</systemitem> が生成したログの出力を読みたい場合は、下記のコマンドを使用します:</para>
   <screen>&prompt.sudo;journalctl -u sshd</screen>
  </tip>


  <sect2>
   <title>SSH 鍵の管理</title>
  <para><filename>/etc/ssh/</filename> 内にある機密鍵と公開鍵の両方を、機密の保持される外部のデバイスにバックアップしておくことをお勧めします。バックアップを採取しておくことで、鍵が不正に書き換えられた際の検出ができるほか、新しくシステムをインストールし直すような場合にも対応することができます。</para>

  <tip>
   <title>既存の SSH ホスト鍵</title>
   <para>&productname; を既存の Linux インストールが存在する環境にインストールする場合、インストールルーチンは既存の SSH ホスト鍵を検索して、最も新しいアクセス日時のものを自動的に取り込むことができるようになっています。</para>
  </tip>

  <para>初めて特定のホストに接続すると、クライアントは公開鍵を <filename>~/.ssh/known_hosts</filename> 内に保存します。これにより、ネットワーク内で不正な鍵を使用させて、攻撃者に容易に機密メッセージを解読させてしまうような、中間者攻撃を防ぐことができます。このような攻撃が行われた場合、 <filename>~/.ssh/known_hosts</filename> 内に保存されているホスト鍵が変更されていることが検出されるか、もしくはサーバ側でメッセージが解読できないことで判明します。</para>

  <para>何らかの理由でホストの公開鍵が変わってしまった場合、クライアントはサーバへの接続前にその旨のメッセージを受け取ります。以前の鍵を削除したい場合は、 <command>ssh-keygen -r <replaceable>ホスト名</replaceable></command> を実行してください。</para>
  </sect2>

  <sect2 xml:id="sec-ssh-sshdserver-rotation">
   <title>ホスト鍵の切り替え</title>
   <para>OpenSSH バージョン 6.8 およびそれ以降のバージョンでは、ホスト鍵を切り替えながら使用することのできるプロトコル拡張が利用できます。サーバの管理者は、たとえばホスト鍵が漏洩したり、既存の鍵の強度では弱いと判断したりした場合、古いホスト鍵を廃棄して新しいホスト鍵に切り替えなければならなくなります。バージョン 6.8 以前では、クライアント側の <filename>ssh_config</filename> で <literal>StrictHostKeyChecking</literal> が <literal>yes</literal> に設定されていると、ホスト鍵の変更が検出されると警告メッセージを表示して接続が行われなくなっていました。この場合、クライアント側で対応する公開鍵を <filename>known_hosts</filename> ファイルから手作業で削除して接続し直し、新しい鍵を受け付ける作業が必要になります。 SSH 経由でのスケジュールバックアップなど、自動化を行っている場合には面倒になってしまいます。</para>
   <para>新しいホスト鍵の切り替え方式では、サービスの停止を伴うことなく新しい鍵を配布できる方式を提供しています。クライアントからの接続があると、サーバは手持ちの鍵を一覧で送信しますので、次回以降のログインで新しい鍵を自動的に受け付けるようにすることができます。これにより、鍵の移行のための猶予期間を設定することができますので、しばらく待ってから古い鍵を削除すれば、移行が完了することになります。クライアント側の <filename>known_hosts</filename> ファイルも自動的に更新されますので、古い鍵から新しい鍵への切り替えも自動でできることになります。</para>
    <para>ホスト鍵の切り替え機能を使用するには、新しい鍵の作成のほか、サーバ側では <filename>/etc/ssh/sshd_config</filename> ファイルの変更を、クライアント側では <filename>/etc/ssh/ssh_config</filename> ファイルの変更をそれぞれ行う必要があります。</para>
   <para>まずは新しい鍵 (複数可) を作成します。下記の例では新しい RSA 鍵と Ed25519 鍵を作成しています。新しい鍵は既存の鍵に上書きせず、異なるファイル名を指定してください。一般的には作成日などを含めておくとよいでしょう。また、ホスト鍵にはパスフレーズを設定してはいけません:</para>
   <screen>&prompt.root;<command>ssh-keygen -t rsa -f ssh_host_rsa_2022-01 -C "main server"</command>
Generating public/private rsa key pair.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in ssh_host_rsa_2022-01
Your public key has been saved in ssh_host_rsa_2022-01.pub
The key fingerprint is:
SHA256:F1FIF2aqOz7D3mGdsjzHpH/kjUWZehBN3uG7FM4taAQ main server
The key's randomart image is:
+---[RSA 3072]----+
|         .Eo*.oo |
|          .B .o.o|
|          o . .++|
|         . o ooo=|
|        S . o +*.|
|         o o.oooo|
|       .o ++oo.= |
|       .+=o+o + .|
|       .oo++..   |
+----[SHA256]-----+

&prompt.root;<command>ssh-keygen -t ed25519 -f ssh_host_ed25519_2022-01 -C "main server"</command>
Generating public/private ed25519 key pair.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in ssh_host_ed25519_2022-01
Your public key has been saved in ssh_host_ed25519_2022-01.pub
The key fingerprint is:
SHA256:2p9K0giXv7WsRnLjwjs4hJ8EFcoX1FWR4nQz6fxnjxg root@server2
The key's randomart image is:
+--[ED25519 256]--+
|   .+o ...o+     |
| . .... o *      |
|  o..  o = o     |
|  ..   .. o      |
|   o. o S  .     |
|  . oo.*+   E o  |
|   + ++==..  = o |
|    = +oo= o. . .|
|     ..=+o=      |
+----[SHA256]-----+</screen>

   <para>表示されたフィンガープリント (key fingerprint) を、ユーザ側で鍵を検証する際の確認として記録しておいてください。</para>
   <para>新しい鍵のファイル名を <filename>/etc/ssh/sshd_config</filename> で指定します。既存の鍵はコメントアウトせず、そのまま設定しておいてください:</para>
   <screen>## 古い鍵
HostKey /etc/ssh/ssh_host_rsa_key
HostKey /etc/ssh/ssh_host_ed25519_key
HostKey /etc/ssh/ssh_host_ecdsa_key

## 新しい鍵
HostKey /etc/ssh/ssh_host_rsa_2022-01
HostKey /etc/ssh/ssh_host_ed25519_2022-01</screen>

    <para>ファイルを保存したら、 <systemitem class="daemon">sshd</systemitem> を再起動します:</para>
    <screen>&prompt.root;<command>systemctl restart sshd.service</command>
    </screen>
    <para>なお、クライアント側の <filename>/etc/ssh/ssh_config</filename> では、下記のような設定をしている必要があります:</para>
    <screen>UpdateHostKeys ask
StrictHostKeyChecking yes</screen>
    <para>クライアント側からサーバに SSH で接続してテストしてみます。既に接続している場合はいったんログアウトして再接続してみてください。下記のようなメッセージが表示されるはずです:</para>
    <screen>The server has updated its host keys.
These changes were verified by the server's existing trusted key.
Deprecating obsolete hostkey: ED25519
SHA256:V28d3VpHgjsCoV04RBCZpLo5c0kEslCZDVdIUnCvqPI
Deprecating obsolete hostkey:
RSA SHA256:+NR4DVdbsUNsqJPIhISzx+eqD4x/awCCwijZ4a9eP8I
Accept updated hostkeys? (yes/no):</screen>
    <para><literal>UpdateHostKeys ask</literal> を <literal>UpdateHostKeys yes</literal> に設定することで、変更された鍵を自動的に受け付けるように設定することもできますが、鍵の変更について問い合わせを行うように設定したほうが安全です。</para>
    <para>さらに詳しい情報を知りたい場合は、下記を参照してください:</para>

<itemizedlist>
    <listitem>
      <para><xref linkend="sec-ssh-authentic-gen-key"/></para>
    </listitem>
    <listitem>
     <para><link xlink:href="http://blog.djm.net.au/2015/02/key-rotation-in-openssh-68.html"/> (英語)</para>
    </listitem>
    <listitem>
     <para>man 5 ssh_config, man 5 sshd_config</para>
    </listitem>
   </itemizedlist>
  </sect2>
 </sect1>

<sect1 xml:id="sec-ssh-authentic">
  <title>SSH 認証の仕組み</title>

  <para>最も簡単な構成では、ログイン時にユーザのパスワードを入力させて認証を行います。しかしながら、複数のコンピュータを利用しているような場合、いちいちパスワードを覚えておくのは非効率ですし、面倒です。また、これらのパスワードは管理上の理由などで変更を行わなければならないこともあります。それだけでなく、 &rootuser; のアクセスを許可するような場合、管理者側では &rootuser; のパスワードを変更することなく、素早く個別の許可を取り消す措置を備えていなければならない場合もあります。</para>

  <para>このような要件に対応するため、接続先のパスワードを入力することなくログインできる仕組みが用意されています。ユーザ側で鍵対を生成して、この鍵対を認証の代用として使用する方法です。この鍵対には公開鍵 ( <filename>id_rsa.pub</filename> もしくは <filename>id_dsa.pub</filename> ) と機密鍵 ( <filename>id_rsa</filename> もしくは <filename>id_dsa</filename> ) が含まれています。</para>

  <para>接続先のユーザのパスワードを指定せずにログインできるようにするには、生成した公開鍵を、接続先のユーザのホームディレクトリ以下にある <filename>~/.ssh/authorized_keys</filename> というファイルに保存しておかなければなりません。このファイルに保存する際には、このユーザのパスワードを知っておかなければなりませんし、公開鍵を削除すればアクセスも拒否されるようになることから、アカウントに対する完全な制御を実現できることになります。</para>

  <para>生成した鍵対そのものに対する機密を保護するため、鍵対にはパスフレーズを設定しておいて、 <command>ssh</command> , <command>scp</command> , <command>sftp</command> のような各コマンドを使用する際に、パスフレーズを入力するように設定しておくことをお勧めします。通常のパスワード認証とは異なり、接続先ホストのユーザのパスワードとは連動していないものですので、自由に管理することができます。</para>

  <para>上述のとおり鍵対を利用した認証方法のほかに、 SSH ではホストベースの認証にも対応しています。ホストベースの認証では、信頼されているホスト内のユーザは、同じユーザに対して同機能が有効化されている接続先にログインすることができるようになります。 &productname; では鍵対ベースの認証を設定しますので、本マニュアルでは説明していません。</para>

  <note>
<!-- fix for bug #398647 -->
   <title>ホストベースの認証でのファイルパーミッションについて</title>
   <para>ホストベースの認証を使用している場合、 <filename>/usr/lib/ssh/ssh-keysign</filename> に対して setuid ビットを設定する必要があります。既定の &productname; ではそのような設定を行っていませんので、必要であれば手作業で設定を行ってください。なお、 <filename>/etc/permissions.local</filename> ファイルで必要な設定を行うことで、 <package>openssh</package> 自身に対する更新が提供された場合でも、パーミッションを設定し直す必要が無くなります。</para>
  </note>

  <sect2 xml:id="sec-ssh-authentic-gen-key">
   <title>SSH クライアント鍵とホスト鍵の生成</title>
   <para>生成できる鍵の種類としては、 DSA, RSA, ECDSA, ECDSA-SK, Ed25519, Ed25519-SK があります。ただし、 DSA は何年も前に廃止予定とされていて、 OpenSSH 7.0 では無効化されていて使用すべきではありません。 RSA は最も一般的に使用されている種類で、古い仕組みではあるものの一般的に使用されています。</para>
   <para>Ed25519 と ECDSA はより強力で高速な鍵です。 Ed25519 が最も強力な鍵として提供されていますが、 Ed25519 に対応していない古いクライアントを受け付ける必要がある場合は、 Ed25519 と RSA の両方のホスト鍵を作成してください。</para>
   <note>
     <title>古いクライアントの安全性について</title>
     <para>古い SSH クライアントは ECDSA や ED25519 に対応していませんが、 ECDSA と ED25519 への対応は 2014 年に公開された OpenSSH 6.5 から提供されているものです。どうしても接続を受け付ける必要がある場合は、必ずセキュリティ更新を適用しておいてください。また、可能であれば古いクライアントからの接続は許可しないでください。</para>
   </note>
   <para>SSH の鍵は 2 種類の目的で使用されます。サーバ側を認証するためのホスト鍵と、クライアントを認証するためのクライアント鍵です。ホスト鍵は <filename>/etc/ssh</filename> ディレクトリ内に保存され、クライアント鍵はユーザごとのディレクトリである <filename>/home/<replaceable>ユーザ名</replaceable>/.ssh</filename> に保存されます。</para>
   <para>ホスト鍵にはパスフレーズを設定してはいけません。</para>
   <para>ほとんどの場合、クライアント鍵には強力なパスワードを設定します。</para>
   <para>下記に示す手順では、クライアント鍵の作成方法を説明しています。</para>

   <procedure xml:id="pro-ssh-key-client">
     <title>クライアント側の SSH 鍵の生成</title>
    <step>
     <para>既定のパラメータ (RSA, 3072 ビット) でクライアント側の鍵対を生成するには、オプションを何も指定せず <command>ssh-keygen</command> と入力して実行します。なお、機密鍵を保護するため、強力なパスフレーズを設定しておいてください:</para>
     <screen>&prompt.user;<command>ssh-keygen</command>
Generating public/private rsa key pair.
Enter file in which to save the key (/home/user/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/user/.ssh/id_rsa
Your public key has been saved in /home/user/.ssh/id_rsa.pub
The key fingerprint is:
SHA256:z0uJIuc7Doy07bFTe1ppZHLVrkD/bWWlBAF/PcHjblU user@server2
The key's randomart image is:
+---[RSA 3072]----+
|          ..o... |
|           o . +E|
|        . . o +.=|
|       . o . o o+|
|  .   . S . . o +|
| . =  .= * + . = |
|  o *.o.= * . +  |
|   ..Bo+.. . .   |
|    oo==  .      |
+----[SHA256]-----+</screen>
    </step>
    <step>
      <para>より長いビット長で RSA 鍵対を作成したい場合は、下記のように入力して実行します:</para>
      <screen>&prompt.user;<command>ssh-keygen -b 4096</command></screen>
      <para>OpenSSH での RSA 鍵は、最大で 16,384 ビットまでとなっています。しかしながら、ビット長を大きくしても、かかる負荷に見合うだけの効果を得られません。詳しくは GnuPG の FAQ <link xlink:href="https://www.gnupg.org/faq/gnupg-faq.html#no_default_of_rsa4096"/> (英語) をお読みください。</para>
    </step>
    <step>
      <para>独自のファイル名やコメントを指定して RSA 鍵対を作成する場合は、下記のようにします:</para>
    <screen>&prompt.user;<command>ssh-keygen -f <replaceable>backup-server-key -C "infrastructure backup server"</replaceable></command>
      </screen>
    </step>
    <step>
     <para>Ed25519 鍵対を作成する場合は、下記のようにします:</para>
     <screen>&prompt.user;<command>ssh-keygen -t ed25519 -f <replaceable>ldap-server-key -C "Internal HTTP server"</replaceable></command>
     </screen>
     <para>Ed25519 の鍵は 256 ビットの固定長です。暗号強度は RSA 4096 ビットと同程度になります。</para>
    </step>
   </procedure>

    <para>ホスト鍵はクライアント鍵とは違った管理方法になります。ホスト鍵にはパスフレーズを設定してはならないほか、鍵対は <filename>/etc/ssh</filename> ディレクトリ内に保存します。 OpenSSH では、必要に応じて自動的にホスト鍵を生成します。たとえば下記のようになります:</para>
    <screen>&prompt.user;<command>ls -l /etc/ssh</command>
total 608
-rw------- 1 root root 577834  5月  6 2021 moduli
-rw-r--r-- 1 root root   2403  5月  6 2021 ssh_config
-rw-r----- 1 root root   3420  5月  6 2021 sshd_config
-rw------- 1 root root   1381  2月 10 2021 ssh_host_dsa_key
-rw-r--r-- 1 root root    604  2月 10 2021 ssh_host_dsa_key.pub
-rw------- 1 root root    505  2月 10 2021 ssh_host_ecdsa_key
-rw-r--r-- 1 root root    176  2月 10 2021 ssh_host_ecdsa_key.pub
-rw------- 1 root root    411  2月 10 2021 ssh_host_ed25519_key
-rw-r--r-- 1 root root     96  2月 10 2021 ssh_host_ed25519_key.pub
-rw------- 1 root root   2602  2月 10 2021 ssh_host_rsa_key
-rw-r--r-- 1 root root    568  2月 10 2021 ssh_host_rsa_key.pub</screen>

    <para>なお、 <command>ssh-keygen</command> には新しいホスト鍵を作成するための特別なオプションである <option>-A</option> が用意されています。これはそれぞれの種類のホスト鍵対が存在していなかった場合、それらを自動的に生成することができます。保存先や空のパスフレーズ設定、鍵の種類ごとのビット長や空のコメントも自動的に設定されます。下記のように入力して実行すると、既存の鍵を削除して新しいホスト鍵対を生成することができます:</para>
    <screen>&prompt.sudo;<command>rm /etc/ssh/ssh_host*</command>
&prompt.sudo;<command>ssh-keygen -A</command></screen>
    <para>なお、 <command>ssh-keygen -A</command> では既存の鍵を上書きすることはありませんので、ホスト鍵を完全に入れ替える場合は、事前に削除しておく必要があります。</para>
    <important>
     <title>DSA 鍵の使用禁止について</title>
      <para><command>ssh-keygen -A</command> を実行すると、既に何年も前から安全性に問題があると考えられている DSA 鍵も生成されます。 OpenSSH 7.0 の時点でも未だ作成されますが、 <filename>sshd_config</filename> 側で使用されないように設定されています。そのため、生成された DSA 鍵は削除して問題ありません。</para>
    </important>
    <para>ホスト鍵の切り替えを検討している場合は、新しいホスト鍵を別のファイル名に保存しなければなりません。単純に新しい鍵に入れ替えるだけの作業では、クライアント側がホスト鍵の正しさを検証できないためです。ホスト鍵を切り替えるには、サーバ側で古い鍵と新しい鍵の両方を送信するように設定し、古い鍵で新しい鍵を検証できるようにしてください。そのため、古い鍵とは別のファイル名に保存する必要があります。下記の例では、新しい RSA, Ed25519 のホスト鍵を作成して、年月を指定した新しいファイル名に保存しています。もちろん新しいホスト鍵にはパスフレーズを設定してはなりません:</para>
    <screen>&prompt.user;<command>cd /etc/ssh</command>
&prompt.sudo;<command>ssh-keygen -b 4096 -f "ssh_host_rsa_2022_02"</command>
&prompt.sudo;<command>ssh-keygen -t ed25519 -f "ssh_host_ed25519_2022_02"</command></screen>
    <para>なお、新しい鍵に設定するファイル名は任意のものでかまいません。</para>
  </sect2>

  <sect2 xml:id="sec-ssh-authentic-key-copy">
   <title>SSH 鍵のコピー</title>
   <para>SSH の公開鍵を接続先の <filename>~/.ssh/authorized_keys</filename> にコピーする際、 <command>ssh-copy-id</command> コマンドを使用することができます。生成した鍵を <filename>~/.ssh/id_rsa.pub</filename> 内に保存していれば、簡単にコピーを行うことができます。 DSA 鍵を使用しているような場合や、異なるファイル名に保存している場合は、パスを指定して実行する必要があります:</para>
  <screen>&prompt.user;<prompt>~/.ssh/id_rsa.pub</prompt>
ssh-copy-id -i &exampleuser_plain;@&exampleserver;

&prompt.user;<prompt>~/.ssh/id_dsa.pub</prompt>
ssh-copy-id -i ~/.ssh/id_dsa.pub  &exampleuser_plain;@&exampleserver;

&prompt.user;<prompt>~notme/.ssh/id_rsa.pub</prompt>
ssh-copy-id -i ~notme/.ssh/id_rsa.pub  &exampleuser_plain;@&exampleserver;</screen>
   <para>鍵のコピーを行うには、接続先のユーザのパスワードを入力する必要があります。また、鍵を削除したい場合は、 <filename>~/.ssh/authorized_keys</filename> ファイルを手作業で編集してください。</para>
  </sect2>

  <sect2 xml:id="sec-ssh-authentic-agent">
   <title><command>ssh-agent</command> の使用</title>
   <para>Secure SHell で何度も作業を行うような場合、いちいちパスワードやパスフレーズを入力するのは面倒です。そのため、 SSH パッケージにはもう 1 つのツールである <command>ssh-agent</command> が提供されています。これは X セッションや端末セッションが有効である間、機密鍵を保持することができる仕組みです。その他のウインドウやプログラムは、 <command>ssh-agent</command> に対するクライアントとして起動します。 <command>ssh-agent</command> を起動することで様々な環境変数が設定され、 <command>ssh</command> , <command>scp</command> , <command>sftp</command> で自動ログインを行うことができるよう、エージェントの場所を通知することができます。詳しい説明については、 <command>ssh-agent</command> のマニュアルページをお読みください。</para>
   <para><command>ssh-agent</command> を起動したあとは、 <command>ssh-add</command> コマンドで鍵を追加していきます。このとき、パスフレーズの入力を求められます。パスフレーズをいったん入力してしまえば、再度認証を行うことなく Secure SHell のコマンドを使用することができるようになります。</para>
   <sect3 xml:id="sec-ssh-authentic-agent-x">
    <title>X セッション内での <command>ssh-agent</command> の使用</title>
    <para>&productname; では、 &gnome; ディスプレイマネージャ経由でログインすることで、自動的に <command>ssh-agent</command> が起動されます。あとは <command>ssh-add</command> コマンドを実行して、 X セッションの冒頭で鍵を追加していくことになりますが、この処理をログイン時に自動的に実施したい場合は、下記のようにして実行します:</para>
    <procedure>
     <step>
      <para>まずは目的のユーザでログインして、 <filename>~/.xinitrc</filename> ファイルが存在していないかどうかを確認します。</para>
     </step>
     <step>
      <para>存在していない場合は、 <filename>/etc/skel</filename> 内にある雛形を使用して設定するか、もしくはシンプルにコピーして使用します:</para>
<screen>if [ -f ~/.xinitrc.template ]; then mv ~/.xinitrc.template ~/.xinitrc; \
else cp /etc/skel/.xinitrc.template ~/.xinitrc; fi</screen>
     </step>
     <step>
      <para>雛形をコピーしたあとは、下記のような行を探してコメント文字 (#) を外します。 <filename>~/.xinitrc</filename> が既に存在しているような場合は、下記のような行を追加します (コメント文字 (#) は外して記入してください) 。</para>
<screen># if test -S "$SSH_AUTH_SOCK" -a -x "$SSH_ASKPASS"; then
#       ssh-add &lt; /dev/null
# fi</screen>
     </step>
     <step>
      <para>新しい X セッションを開始すると、 SSH 鍵に対するパスフレーズの入力を求められます。</para>
     </step>
    </procedure>
   </sect3>
   <sect3 xml:id="sec-ssh-authentic-agent-terminal">
    <title>端末セッション内での <command>ssh-agent</command> の使用</title>
    <para>端末セッションの場合は、 <command>ssh-agent</command> を手作業で起動して、後から <command>ssh-add</command> を実行する必要があります。 <command>ssh-agent</command> の起動方法には 2 種類のものがあります。 1 行目の例は既存のシェルから <command>ssh-agent</command> を起動して、その中で新しいシェルを起動する方法、 2 行目の例は既存のシェル内で <command>ssh-agent</command> を起動して、必要に応じて環境を書き換える方法です。</para>
<screen>&prompt.user;ssh-agent -s /bin/bash
eval $(ssh-agent)
    </screen>
    <para>エージェントを起動したら、 <command>ssh-add</command> を実行して鍵を追加していってください。</para>
   </sect3>
  </sect2>

<!-- fs 2012-10-02:

     Not sure what to do with this...

    <sect2 id="sec-ssh-authentic-host-based">
   <title>Host-based authentication</title>
   <para></para>
  </sect2>
-->
 </sect1>
 <sect1 xml:id="sec-ssh-restrict-logins">
  <title>SSH ログインの制限</title>
  <para>SSH 経由でのログインを制限したい場合、アカウントごとに接続元 IP サブネットを限定することができます。下記の手順を実行することで、 <command>ssh</command> ( <xref linkend="sec-ssh-programm"/> ), <command>scp</command> ( <xref linkend="sec-ssh-copy"/> ), <command>sftp</command> ( <xref linkend="sec-ssh-sftp"/> のそれぞれに対して、ログイン制限を行うことができます。</para>
  <procedure xml:id="pro-ssh-restrict-logins">
   <!-- cwickert 2021-09-24 following lines are the 'new' format of procedures
    with title and introduction inside. Commented out for consistency for now.
   -->
   <!-- <title>Configuring user remote login restrictions</title>
   <para>
    Perform the following steps to configure user remote login restrictions:
    </para> -->
   <step>
    <para>まずは <filename>/etc/pam.d/sshd</filename> ファイルを編集して、 <literal>auth</literal> ブロックの末尾に下記を追加します:</para>
    <screen>auth required pam_access.so</screen>
   </step>
   <step>
    <para>あとは <filename>/etc/security/access.conf</filename> ファイルを編集して、ユーザごとの制限を設定します。下記の例では、 &rootuser; と &exampleuser; のログインを &exampledomain1ip;.0/&subnetmask; のネットワークから、 &exampleuserII; のログインを &exampledomain2ip;.0/&subnetmask; のネットワークからにのみ制限しています:</para>
<screen>
+ : root : <replaceable>&exampledomain1ip;.0</replaceable>/<replaceable>&subnetmask;</replaceable>
+ : &exampleuser_plain; : <replaceable>&exampledomain1ip;.0</replaceable>/<replaceable>&subnetmask;</replaceable>
+ : &exampleuserII_plain; : <replaceable>&exampledomain2ip;.0</replaceable>/<replaceable>&subnetmask;</replaceable>
- : ALL : ALL</screen>
   <para>なお一番下の行は、全てのユーザに対して全てのネットワークからのアクセスを禁止する設定になります。設定を行う際は注意して設定してください。</para>
   <para>詳しい設定オプションについては、上記ファイル内のコメント文、もしくは <command>man access.conf</command> をお読みください。</para>
   </step>
  </procedure>
  <warning>
   <title><command>pam-config</command> の使用禁止について</title>
   <para>本章で記述している設定を行う場合は、 <command>pam-config</command> ユーティリティを使用してはなりません。このユーティリティは <systemitem>pam_access</systemitem> をグローバルモジュールとして設定する機能しか持ち合わせていないためです。グローバルモジュールとして設定してしまうと、全てのサービス経由でのログインが上記に合わせて許可または禁止されることになってしまいます。</para>
  </warning>

 </sect1>
 <sect1 xml:id="sec-ssh-port-forwarding">
  <title>ポート転送</title>

  <para><command>ssh</command> は TCP/IP 接続を転送するような用途でも使用することができます。この機能は <literal>SSH トンネリング</literal> とも呼ばれ、暗号化された通信を介して TCP の接続を別のマシン内にある特定のポートに転送することができます。</para>

  <para>下記のコマンドを実行することで、 <!-- NOTE: wrong explanation? --> ローカルの TCP ポート 25 (SMTP) への接続を行うと、 &wsI; への暗号化接続を介して &exampleserver; の TCP ポート 25 (SMTP) に接続するようになります。これは特に、 SMTP-AUTH や POP-before-SMTP のような機能を持たない SMTP サーバを使用するような場合に有用です。 <!-- NOTE: bind adress must be set to "0.0.0.0" in order to be connected from network, i.e. "-L 0.0.0.0:25:&exampleserver;:25" -->このようにポート転送を行うことで、電子メールを <quote>自宅の</quote> メールサーバに配送するような構成を構築することができます。</para>

<screen>&prompt.root;ssh -L 25:&exampleserver;:25 &wsI;</screen>

  <para>上記と同様に、全ての POP3 接続 (ポート 110) を &exampleserver; に転送したい場合は、下記のように実行します:</para>

<screen>&prompt.root;ssh -L 110:&exampleserver;:110 &wsI;</screen>

  <para>いずれのコマンドも特権ポートを使用していることから、 &rootuser; で実行しなければなりません。いったんコマンドを実行すれば、一般ユーザからもそのポートを使用して電子メールを送受信できるようになります。この場合、電子メールソフトウエア側のサーバ設定は <literal>localhost</literal> を指定します。上記で説明したそれぞれのプログラムのオプションに関する説明は、 <filename>/usr/share/doc/packages/openssh</filename> 内にある OpenSSH のパッケージドキュメンテーション内にあります。</para>
 </sect1>

 <sect1 xml:id="sec-ssh-publickey">
  <title>インストール済みのシステムにおける公開鍵の追加と削除</title>
  <para>利用環境によっては、 SSH を利用してログインしたほうが便利であったり、 SSH 経由でのログインが必要となったりすることがあります。このような場合、 SSH 公開鍵認証を利用してログインする必要があることもあります。 SSH 鍵を追加もしくは削除するには、下記の手順で行います:</para>
  <procedure>
   <step>
    <para>&yast; を開きます。</para>
   </step>
   <step>
    <para><guimenu>セキュリティとユーザ</guimenu> 内にある <guimenu>ユーザとグループの管理</guimenu> を選択します。</para>
   </step>
   <step>
    <para>鍵を追加もしくは削除したいユーザを選んで、 <guimenu>編集</guimenu> を押します。</para>
   </step>
   <step>
    <para><guimenu>SSH 公開鍵</guimenu> タブに切り替えます。</para>
   </step>
   <step>
    <para>ここから公開鍵を追加もしくは削除することができます。 SSH 公開鍵を追加する場合は、 <filename class="extension">.pub</filename> というファイル名のファイルを追加することができます。</para>
   </step>
   <step>
    <para><guimenu>OK</guimenu> を押して閉じます。</para>
   </step>
  </procedure>

  <para>追加した公開鍵は、 <filename>~/.ssh/authorized_keys</filename> 内に保存されます。</para>
 </sect1>

 <sect1 xml:id="sec-security-ssh-moreinfo">
  <title>さらなる情報</title>

  <para/>

  <variablelist>
   <varlistentry>
    <term><link xlink:href="https://www.openssh.com"/></term>
    <listitem>
     <para>OpenSSH の Web ページ</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><link xlink:href="https://en.wikibooks.org/wiki/OpenSSH"/></term>
    <listitem>
     <para>OpenSSH Wikibook (英語)</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>man sshd</command></term>
    <listitem>
     <para>OpenSSH デーモンのマニュアルページ</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>man ssh_config</command></term>
    <listitem>
     <para>OpenSSH のクライアント側設定ファイルのマニュアルページ</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>man scp</command></term>
    <term><command>man sftp</command></term>
    <term><command>man slogin</command></term>
    <term><command>man ssh</command></term>
    <term><command>man ssh-add</command></term>
    <term><command>man ssh-agent</command></term>
    <term><command>man ssh-copy-id</command></term>
    <term><command>man ssh-keyconvert</command></term>
    <term><command>man ssh-keygen</command></term>
    <term><command>man ssh-keyscan</command></term>
    <listitem>
     <para>ファイルコピー ( <command>scp</command> , <command>sftp</command> ) やログイン ( <command>slogin</command> , <command>ssh</command> ) 、鍵管理などのコマンドに対するマニュアルページ。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><filename>/usr/share/doc/packages/openssh-common/README.SUSE</filename></term>
    <term><filename>/usr/share/doc/packages/openssh-common/README.FIPS</filename></term>
    <listitem>
     <para>&suse; 固有のパッケージドキュメンテーション; FIPS モードなど、提供元からの既定値の変更点などを説明しています。</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
</chapter>
