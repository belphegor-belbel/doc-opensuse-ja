<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter [
<!ENTITY % entities SYSTEM "entity-decl.ent">
%entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha-selinux">
 <title>&selnx; の設定</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
  </dm:docmanager>
 </info>
 <para>本章では、 &productname; 上で &selnx; を使用する際の、設定と管理の方法について説明しています。下記のトピックをカバーしています:</para>
 <itemizedlist mark="bullet" spacing="normal">
  <listitem>
   <para>なぜ &selnx; を使用するのか</para>
  </listitem>
  <listitem>
   <para>&selnx; とは</para>
  </listitem>
  <listitem>
   <para>&selnx; の設定方法</para>
  </listitem>
  <listitem>
   <para>&selnx; の管理</para>
  </listitem>
 </itemizedlist>
 <sect1 xml:id="sec-selinux-why">
  <title>なぜ &selnx; を使用するのか</title>

  <para>&selnx; は Linux カーネル内でセキュリティフレームワークを使用する追加のセキュリティソリューションとして開発されてきました。従来型の標準ファイルパーミッション (所有者、グループ、全体に対して、それぞれ読み込み、書き込み、実行を許可する仕組み) という随意アクセス制御 (DAC) の範疇を超えた、きめ細かいセキュリティポリシーを構築できる仕組みを目指しています。</para>

  <para>下記の例では、なぜ &selnx; (もしくはその同等品である &aa;) が必要となるのかについて、説明しています:</para>

  <para><quote>ある朝、私はサーバがクラックされていることに気がついた。サーバは &productname; ですべての修正 (パッチ) が適用され動作していた。ファイアウオールについても正しく設定が行われ、そのサーバでは不要なサービスは全く提供していなかった。より詳しく調査を行うと、クラッカーはサーバ内の Apache 仮想ホスト内の 1 つに設置された、脆弱性のある PHP スクリプトを通して侵入を行っていた。クラッカーはその後、 Apache Web サーバで使用されている <systemitem class="username">wwwrun</systemitem> を利用して、シェルへのアクセスを取得していた。この <systemitem class="username">wwwrun</systemitem> での侵入後、 <filename>/var/tmp</filename> および <filename>/tmp</filename> の各ディレクトリ内に複数のスクリプトを作成し、これを様々なサーバへの分散型サービス拒否攻撃のボットネットとして動作させていた。</quote></para>

  <para>ここで注目すべき点は、このクラッキングでは、サーバ側の設定を誤っているわけではない、という点です。すべてのパーミッションの設定が正しいにも関わらず、侵入者はシステム内に入り込むことができてしまっています。上記の例は、場合によっては追加のセキュリティ機構が必要となることを示しているわけです。</para>

  <!--
  <para>
   &aa; is a less complete and less complex alternative. &aa; attempts
   to limit privilege escalation by confining the privileges of specific 
   processes (see <xref linkend="cha-apparmor-intro"/>).  
  </para>-->

  <para>&selnx; では、オブジェクト (ファイルやバイナリ、ネットワークソケット) に対してラベルを設定し、このラベルを権限の境界線を決めるものとして使用します。そのため、複数のプロセスやシステム全体にまたがる制限レベルを設定することができます。</para>

  <!--
  <para>
   &selnx; was developed by the US National Security Agency (NSA), and since
   the beginning Red Hat has been heavily involved in its development. The
   first version of &selnx; was offered in the era of <trademark>Red Hat
   Enterprise Linux 4</trademark>, around the year 2006. In the beginning it
   offered support for essential services only, but over the years it has
   developed into a system that offers many rules that are collected in
   policies to protect a broad range of services.
  </para>-->

  <para>&selnx; は Common Criteria や FIPS 140 などの認証規格に従って開発されてきた経緯があります。</para>

  <!--
  <para>
   As an alternative to &selnx;, Immunix, a company that was purchased by
   Novell in 2005, had developed &aa;. &aa; was built on top of the same
   security principles as &selnx;, but took a completely different approach,
   where it was possible to restrict services to exactly what they needed to
   do by using an easy to use wizard-driven procedure. Nevertheless, &aa;
   has never reached the same status as &selnx;, even if there are some good
   arguments to secure a server with &aa; rather than with &selnx;.
  </para>

  <para>
   Because many organizations are requesting &selnx; to be in the
   Linux distributions they are using, &suse; is offering support for the
   &selnx; framework in &productname;.
  </para> -->

  <sect2 xml:id="sec-selinux-support">
   <title>サポート状態</title>
   <para>&selnx; フレームワークは &productnumbershort; でもサポート対象となっています。つまり&productnameshort; では、お使いのサーバ内で &selnx; を使用するのに必要な、すべてのバイナリやライブラリが提供されます。</para>
   <para>ただし、ポリシーは添付されていませんので、要件に合わせて構築していかなければなりません。サードパーティ製のポリシーを使用してもかまいません。 <xref linkend="sec-selinux-install"/> や <xref linkend="sec-selinux-getpolicy"/> では、テスト用に &opensuse; のポリシーをインストールするための情報が示されています。</para>
  </sect2>

  <sect2 xml:id="sec-selinux-component">
   <title>&selnx; のコンポーネント</title>
   <para>&selnx; の設定を始める前に、まずは &selnx; の構成について知っておく必要があります。 &selnx; では、下記の 3 種類から構成されています:</para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>Linux カーネル内にあるセキュリティフレームワーク</para>
    </listitem>
    <listitem>
     <para>&selnx; のライブラリとバイナリ</para>
    </listitem>
    <listitem>
     <para>&selnx; のポリシー</para>
    </listitem>
   </itemizedlist>
   <para>&productname; の既定のカーネルであれば &selnx; に対応していますので、ツールを使用するだけで管理を行うことができます。そのため、管理者にとって最も重要な作業は、 &selnx; のポリシー管理ということになります。</para>
   <para>&selnx; のポリシーでは、 Linux サーバ内の様々なオブジェクトに対して、セキュリティラベルを設定します。これらのオブジェクトには、ユーザやポート、プロセスやファイルなどが含まれます。このようなセキュリティラベルを使用することで、サーバ内での許可を判断することになります。ただし、既定の &selnx; ではすべてのものを拒否する仕組みであることから、どうしても必要なアクセスのみを許可する適切なルール構築が重要となります。そのため、ルールはシステム内で使用するすべてのプログラムに対して存在していなければならないことになります。</para>
   <para>それ以外にも、システム内の一部 (特定のポートやプログラム、ユーザやファイル、ディレクトリなど) を無制限モードで動作させることもできます。無制限モードは &selnx; での保護を外すための仕組みで、システム内の重要なサービスにのみ &selnx; の保護を働かせるような用途で便利な仕組みです。もちろんこの仕組みでは保護が不完全になりますので、可能な限り &selnx; をシステム全体に適用しておいたほうが適切です。</para>
   <para>お使いのシステムに対して適切な保護を実現するには、 &selnx; のポリシーを設定する必要があります。これはすべてのファイルに対してラベルを提供するよう仕立て上げられたポリシーでなければならず、すべてのサービスやユーザに対してセキュリティラベルを設定し、サーバ内でどのファイルやディレクトリにアクセスを許可するのかを設定するものでなければなりません。このようなポリシーの作成には、途方もない労力が必要となります。</para>   
   <!--this is not helpful cschroder 2021-10-06
   <para>
    The complexity of &selnx; is also one of the main arguments against
    using it. Because a typical Linux system is so very complex, it is easy
    to overlook something and leave an opening that intruders can abuse to
    get into your system. And even if it is set up completely the way it
    should be, it still is very hard for an administrator to overlook all
    aspects with &selnx;.
   </para>-->
   <para>なお、無償で提供されている様々な &selnx; ポリシーは、お使いのサーバでも問題なく動作するとは思いますが、独自にポリシーを構築するのに比べると、保護レベルが落ちることがほとんどであることに注意してください。また、 &suse; ではサードパーティ製のポリシーへのサポートは行っておりません。</para>
  </sect2>
 </sect1>
 
 <sect1 xml:id="sec-selinux-policy">
  <title>&selnx; ポリシーの概要</title>
  <para>ポリシーとは &selnx; における主要なコンポーネントです。 &selnx; のポリシーは、特定のオブジェクトがシステム内のどのファイルやディレクトリ、ポートやプロセスなどにアクセスできるのかを示すためのもので、これら全てに対してセキュリティコンテキストを設定することで、この仕組みを実現しています。ポリシーが適用され、ファイルシステムにラベルが設定されている &selnx; システムであれば、 <command>ls -Z</command> コマンドを実行することで、ディレクトリ内のセキュリティコンテキストを表示することができます。<xref linkend="ex-selnx-con-set" xrefstyle="select:label quotedtitle nopage"/> では、 &selnx; によってラベルが設定された &productname; システムにおいて、 <filename>/</filename> ディレクトリ内のセキュリティコンテキストを表示した場合の例を示しています。</para>

  <example xml:id="ex-selnx-con-set">
   <title><command>ls -Z</command> を利用したセキュリティコンテキストの表示</title>
<screen>&prompt.user;ls -Z /
system_u:object_r:bin_t bin
system_u:object_r:boot_t boot
system_u:object_r:device_t dev
system_u:object_r:etc_t etc
system_u:object_r:home_root_t home
system_u:object_r:lib_t lib
system_u:object_r:lib_t lib64
system_u:object_r:lost_found_t lost+found
system_u:object_r:mnt_t media
system_u:object_r:mnt_t mnt
system_u:object_r:usr_t opt
system_u:object_r:proc_t proc
system_u:object_r:default_t root
system_u:object_r:bin_t sbin
system_u:object_r:security_t selinux
system_u:object_r:var_t srv
system_u:object_r:sysfs_t sys
system_u:object_r:tmp_t tmp
system_u:object_r:usr_t usr
system_u:object_r:var_t var</screen>
  </example>

  <para>セキュリティコンテキストで最も重要な箇所は、コンテキストタイプ (種類) です。これはしばしば <literal>_t</literal> で終わるセキュリティコンテキストとして示され、 &selnx; が対象のオブジェクトに対して、どのような種類のアクセスを許可するのかを示しています。ポリシー側では、どのような種類のユーザまたはロールに対して、どの種類のコンテキストにアクセスを許可するのかを指定します。たとえば下記のようなルールがあります:</para>

<screen>allow user_t bin_t:file {read execute gettattr};</screen>

  <para>上記のルールでは、 <systemitem class="username">user_t</systemitem> というコンテキストタイプのユーザ (これをソースオブジェクトと呼びます) に対して、 <filename>bin_t</filename> というコンテキストタイプが設定された "ファイル" (これをターゲットと呼びます) へのアクセスを許可しています。ただし、許可されるアクセスは <literal>read</literal> (読み込み) , <literal>execute</literal> (実行) , <literal>getattr</literal> (属性取得) の 3 種類だけです。</para>

  <para>&elnx; のポリシーには数多くのルールが含まれています。管理をやりやすくするには、ポリシーをモジュールとして分割したほうがよい場合があります。これにより、システム内の様々な箇所で、保護の有無を切り替えることができるようになります。</para>

  <para>お使いのシステムでポリシーを構築する場合、モジュール型のポリシーを構築するのか、もしくはモノリシックな (1 つの巨大なポリシーでシステム全体を保護する) ポリシーを構築するのかを選択することができますが、通常はモジュール型のポリシーを構築しておくことを強くお勧めします。それは、モジュール型のほうが管理がやりやすいためです。</para>
 </sect1>
 
 <sect1 xml:id="sec-selinux-install">
  <title>&selnx; パッケージのインストール</title>
  <para>zypper で &selnx; をインストールしている場合は、 <command>--search-descriptions</command> オプションで関連するパッケージを検索することができます。たとえば下記のような結果になります:</para>
  <screen>&prompt.user;<command>zypper se --search-descriptions selinux</command>
libselinux-devel 
libselinux1 
libselinux1-32bit
libsemanage-devel
libsemanage1 
libsepol-devel 
libsepol1 
mcstrans 
policycoreutils 
python3-policycoreutils
python3-selinux 
python3-semanage
python3-setools 
restorecond
selinux-tools
setools-console
setools-devel 
setools-java
setools-libs
setools-tcl
  </screen>
  <para>これら全てのパッケージをインストールする必要はありません。下記のパッケージをインストールしてください:</para>
  <screen>&prompt.sudo;<command>zypper in restorecond policycoreutils setools-console</command></screen>
  <para>&yast; を利用してインストールしたい場合は、ソフトウエア管理モジュールで "selinux" を検索し、 <package>restorecond</package> , <package>policycoreutils</package> , <package>setools-console</package> の各パッケージをインストールしてください。</para>
  
  <para>ただし、これではポリシーがインストールされません。テスト用に &opensuse; のポリシーをインストールしたい場合は、 <xref linkend="sec-selinux-getpolicy"/> を参照してください。</para>
</sect1>

  <sect1 xml:id="sec-selinux-getpolicy">
  <title>&selnx; ポリシーのインストール</title>
  <para>ポリシーは &selnx; で必須の部品です。 &productname; &productnumber; では、既定のポリシーは同梱されておりませんので、お使いの環境に合わせてポリシーを構築しなければなりません。これは、 &selnx; が要件に合わせてカスタマイズしなければならない特性があるためです。詳しくは &suse; のサポートエンジニアにお問い合わせください。</para>
  <para>テスト用のポリシーは <link xlink:href="https://download.opensuse.org/repositories/security:/SELinux/"/> で公開されています。ここでは &slea; と &opensuse; に対応したポリシーが提供されています。お使いの &slea; バージョンに合ったリポジトリリンクをコピーして、 zypper に追加してください:</para>
  <screen>&prompt.sudo;<command>zypper ar -f https://download.opensuse.org/repositories/security:/SELinux/SLE_15_SP&product-sp;/ Security-SELinux</command>
      </screen>
  <para>&yast; を利用したい場合は、ソフトウエアリポジトリモジュールをお使いください。</para>
  <para>このリポジトリには、ポリシーを含む様々な追加パッケージが含まれています。たとえば下記のようになります:</para>
  <screen>
selinux-autorelabel
selinux-policy 
selinux-policy-devel
selinux-policy-doc
selinux-policy-minimum 
selinux-policy-mls
selinux-policy-sandbox
selinux-policy-targeted
setools-gui
setroubleshoot
setroubleshoot-plugins
setroubleshoot-server
</screen>
  <para>下記のパッケージをインストールします:</para>
 <screen>&prompt.sudo;<command>zypper in selinux-policy-targeted selinux-policy-devel selinux-autorelabel</command></screen>
 <para>次に実施すべきことは、 SELinux 自身や SELinux のモードを設定するための &grub; ブートローダの修正です ( <xref linkend="sec-selinux-grub"/> ) 。</para>
</sect1>

 <sect1 xml:id="sec-selinux-grub">
   <title>&grub; ブートローダの修正</title>   
<para>&selnx; のパッケージをインストールしたあとは、 &grub; ブートローダの修正を行います。これは　<filename>/etc/default/grub</filename> ファイルを直接編集するか、もしくは &yast; で行うことができます。</para>
  <para><filename>/etc/default/grub</filename> ファイルを直接編集する場合は、下記のような内容を <literal>GRUB_CMDLINE_LINUX_DEFAULT=</literal> 以下に追加します:</para>
  <screen>security=selinux selinux=1 enforcing=0</screen>
  <para>あとは <command>grub2-mkconfig -o /boot/grub2/grub.cfg</command> を実行して、 &grub; の設定を再生成してください。</para>
  <para>&yast; の場合は、 <menuchoice> <guimenu>システム</guimenu> <guimenu>ブートローダ</guimenu> <guimenu>カーネルのパラメータ</guimenu></menuchoice> を選択し、下記の内容を <guimenu>オプションのカーネルコマンドラインパラメータ</guimenu> に <literal>security=selinux selinux=1 enforcing=0</literal> を追加します。</para>
  <para>それぞれのオプションの意味は下記のとおりです:</para>

  <variablelist>
   <varlistentry>
    <term><literal>security=selinux</literal></term>
    <listitem>
     <para>このオプションを指定することにより、 &aa; ではなく &selnx; を使用することを宣言します。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>selinux=1</literal></term>
    <listitem>
     <para>このオプションを指定することにより、 &selnx; を有効化します。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>enforcing=0</literal></term>
    <listitem>
     <para>このオプションを設定することにより、 permissive (許容) モードに設定します。このモードでは、 &selnx; が完全に動作するものの、ポリシー内に書かれたセキュリティ設定は、実際には強制されなくなります。このモードは &selnx; のテストや設定を行う際に使用します。システムの動作確認を終え、 &selnx; の保護を有効化したい場合は、このオプションを <literal>enforcing=1</literal> に設定し、 <filename>/etc/selinux/config</filename> 内で <literal>SELINUX=enforcing</literal> を設定してください。</para>
    </listitem>
   </varlistentry>
  </variablelist>
      
  <para>設定後に再起動を行うことで、 &selnx; がファイルシステム全体に対するラベルを再設定するようになります。ラベルの再設定が完了したあとは、  <command>sestatus -v</command> を実行して、正しく動作していることを確認してください。 <xref linkend="ex-selnx-sestatus" xrefstyle="select:label quotedtitle nopage"/> のような出力が現れるはずです。</para>

  <example xml:id="ex-selnx-sestatus">
   <title>&selnx; が動作していることの確認</title>
<screen>&prompt.sudo;<command>sestatus -v</command>
SELinux status:                 enabled
SELinuxfs mount:                /selinux
Current mode:                   permissive
Mode from config file:          permissive
Policy version:                 26
Policy from config file:        minimum

Process contexts:
Current context:                root:staff_r:staff_t
Init context:                   system_u:system_r:init_t
/sbin/mingetty                  system_u:system_r:sysadm_t
/usr/sbin/sshd                  system_u:system_r:sshd_t

File contexts:
Controlling term:               root:object_r:user_devpts_t
/etc/passwd                     system_u:object_r:etc_t
/etc/shadow                     system_u:object_r:shadow_t
/bin/bash                       system_u:object_r:shell_exec_t
/bin/login                      system_u:object_r:login_exec_t
/bin/sh                         system_u:object_r:bin_t -&gt; system_u:object_r:shell_exec_t
/sbin/agetty                    system_u:object_r:getty_exec_t
/sbin/init                      system_u:object_r:init_exec_t
/sbin/mingetty                  system_u:object_r:getty_exec_t
/usr/sbin/sshd                  system_u:object_r:sshd_exec_t
/lib/libc.so.6                  system_u:object_r:lib_t -&gt; system_u:object_r:lib_t
/lib/ld-linux.so.2              system_u:object_r:lib_t -&gt; system_u:object_r:ld_so_t</screen>
  </example>
 </sect1>
 
 <sect1 xml:id="sec-selinux-configure">
  <title>&selnx; の設定</title>
  <para>この時点では既に &selnx; システムを完全に動作できていますので、後は設定作業ということになります。現時点では &selnx; が動作しているものの、強制 (enforcing) モードにはなっていません。つまり、何をするにしても制限が加わっておらず、強制モードに移行した際に実施される制限がログに記録されるだけです。まずはログファイルを読んで、どのような処理が許可されていないのかを確認してください。ここでは、最初のテストとして &selnx; を強制モードに移行し、サーバを問題なく使用できるかどうかを確認します。これを行うには、 &grub; の設定ファイル内で <option>enforcing=1</option> を設定し、 <filename>/etc/selinux/config</filename> 内で <option>SELINUX=enforcing</option> を指定します。設定が終わったらサーバを再起動し、きちんと起動ができるかどうかを確認してください。問題なく動作した場合は、そのままサーバの残りの機能が一通り動作するよう、必要に応じて設定を変更していきます。サーバが起動できない状態になってしまった場合は、 &selnx; の強制モードを解除して、サーバの調整作業を行ってください。</para>
  <para>サーバの調整作業を行う場合、まずは &selnx; のインストールを確認します。既に <command>sestatus -v</command> というコマンドを使用していますので、ここに表示されている現在のモードとプロセス、ファイルコンテキストをそれぞれ確認します。あとは下記のように実行して、利用可能な可否設定を確認します:</para>
<screen>&prompt.sudo;<command>semanage boolean -l</command></screen>
   <para>この可否設定の一覧を表示することで、ポリシーへのアクセスも同時に検証することができます。 <xref linkend="ex-selnx-ls-bool"/> には、このコマンドの出力例が示されています:</para>
   <example xml:id="ex-selnx-ls-bool">
    <title>可否設定の一覧表示とポリシーアクセスの確認</title>
<screen>&prompt.sudo;<command>semanage boolean -l</command>
SELinux boolean                          Description
ftp_home_dir                   -&gt; off   ftp_home_dir
mozilla_read_content           -&gt; off   mozilla_read_content
spamassassin_can_network       -&gt; off   spamassassin_can_network
httpd_can_network_relay        -&gt; off   httpd_can_network_relay
openvpn_enable_homedirs        -&gt; off   openvpn_enable_homedirs
gpg_agent_env_file             -&gt; off   gpg_agent_env_file
allow_httpd_awstats_script_anon_write -&gt; off   allow_httpd_awstats_script_anon_write
httpd_can_network_connect_db   -&gt; off   httpd_can_network_connect_db
allow_ftpd_full_access         -&gt; off   allow_ftpd_full_access
samba_domain_controller        -&gt; off   samba_domain_controller
httpd_enable_cgi               -&gt; off   httpd_enable_cgi
virt_use_nfs                   -&gt; off   virt_use_nfs</screen>
    <para>この時点で有用なコマンドがもう 1 つあります。それは下記のとおりです:</para>
<screen>&prompt.sudo;<command>semanage fcontext -l</command></screen>
    <para>上記は、ポリシーによって提供される既定のファイルコンテキスト設定を表示することができます (詳しくは <xref linkend="ex-selnx-fcon" xrefstyle="select:label quotedtitle nopage"/> をご覧ください) 。</para>
   </example>
   <example xml:id="ex-selnx-fcon">
    <title>ファイルのコンテキスト情報の取得</title>
<screen>&prompt.sudo;<command>semanage fcontext -l</command>
/var/run/usb(/.*)?                                 all files          system_u:object_r:hotplug_var_run_t
/var/run/utmp                                      regular file       system_u:object_r:initrc_var_run_t
/var/run/vbe.*                                     regular file       system_u:object_r:hald_var_run_t
/var/run/vmnat.*                                   socket             system_u:object_r:vmware_var_run_t
/var/run/vmware.*                                  all files          system_u:object_r:vmware_var_run_t
/var/run/watchdog\.pid                             regular file       system_u:object_r:watchdog_var_run_t
/var/run/winbindd(/.*)?                            all files          system_u:object_r:winbind_var_run_t
/var/run/wnn-unix(/.*)                             all files          system_u:object_r:canna_var_run_t
/var/run/wpa_supplicant(/.*)?                      all files          system_u:object_r:NetworkManager_var_run_t
/var/run/wpa_supplicant-global                     socket             system_u:object_r:NetworkManager_var_run_t
/var/run/xdmctl(/.*)?                              all files          system_u:object_r:xdm_var_run_t
/var/run/yiff-[0-9]+\.pid                          regular file       system_u:object_r:soundd_var_run_t</screen>
   </example>
 </sect1>
 <sect1 xml:id="sec-selinux-manage">
  <title>&selnx; の管理</title>

  <para>ここまでの作業で &selnx; を動作させることができましたので、次は設定作業に移ります。 &selnx; では、プロセスやユーザがどのファイルやディレクトリ、ポートなどにアクセスできるのかを、正確に定義するための追加のルールセットを使用します。ルールセットの設定を行うにあたって、 &selnx; はそれぞれのファイルやディレクトリ、プロセスやポートに対してコンテキストを設定し、それをセキュリティラベルとして使用します。セキュリティラベルは、それらをどのように扱うべきかを示しているもので、 &selnx; のポリシー側から指定が行われます。既定では、ポリシーは全てのアクセスを拒否するように設定されていますので、お使いのシステムが何らかの動作を必要とする場合、管理者はルールを作成してポリシー内に配置する必要があります。</para>

  <sect2 xml:id="sec-selinux-viewcontext">
   <title>セキュリティコンテキストの表示</title>
   <para>上述のとおり、ファイルやディレクトリ、ポートなどに対してラベルを設定することができます。ラベル内では様々なコンテキストを使用します。管理者が日々の作業を実施できるようにするためには、コンテキストタイプについて最も知識を持っておく必要があります。様々なコマンドに用意された <option>-Z</option> オプションを使用することで、現在のコンテキスト設定を表示することができるようになります。 <xref linkend="ex-selnx-def-con" xrefstyle="select:label quotedtitle nopage"/> には、ルートディレクトリ内でのコンテキスト設定の例を示しています。</para>
   <example xml:id="ex-selnx-def-con">
    <title>ルートディレクトリ内でのディレクトリ向け既定コンテキスト</title>
<screen>&prompt.sudo;<command>ls -Z</command>
dr-xr-xr-x. root root system_u:object_r:bin_t:s0       bin
dr-xr-xr-x. root root system_u:object_r:boot_t:s0      boot
drwxr-xr-x. root root system_u:object_r:cgroup_t:s0    cgroup
drwxr-xr-x+ root root unconfined_u:object_r:default_t:s0 data
drwxr-xr-x. root root system_u:object_r:device_t:s0    dev
drwxr-xr-x. root root system_u:object_r:etc_t:s0       etc
drwxr-xr-x. root root system_u:object_r:home_root_t:s0 home
dr-xr-xr-x. root root system_u:object_r:lib_t:s0       lib
dr-xr-xr-x. root root system_u:object_r:lib_t:s0       lib64
drwx------. root root system_u:object_r:lost_found_t:s0 lost+found
drwxr-xr-x. root root system_u:object_r:mnt_t:s0       media
drwxr-xr-x. root root system_u:object_r:autofs_t:s0    misc
drwxr-xr-x. root root system_u:object_r:mnt_t:s0       mnt
drwxr-xr-x. root root unconfined_u:object_r:default_t:s0 mnt2
drwxr-xr-x. root root unconfined_u:object_r:default_t:s0 mounts
drwxr-xr-x. root root system_u:object_r:autofs_t:s0    net
drwxr-xr-x. root root system_u:object_r:usr_t:s0       opt
dr-xr-xr-x. root root system_u:object_r:proc_t:s0      proc
drwxr-xr-x. root root unconfined_u:object_r:default_t:s0 repo
dr-xr-x---. root root system_u:object_r:admin_home_t:s0 root
dr-xr-xr-x. root root system_u:object_r:bin_t:s0       sbin
drwxr-xr-x. root root system_u:object_r:security_t:s0  selinux
drwxr-xr-x. root root system_u:object_r:var_t:s0       srv
-rw-r--r--. root root unconfined_u:object_r:swapfile_t:s0 swapfile
drwxr-xr-x. root root system_u:object_r:sysfs_t:s0     sys
drwxrwxrwt. root root system_u:object_r:tmp_t:s0       tmp
-rw-r--r--. root root unconfined_u:object_r:etc_runtime_t:s0 tmp2.tar
-rw-r--r--. root root unconfined_u:object_r:etc_runtime_t:s0 tmp.tar
drwxr-xr-x. root root system_u:object_r:usr_t:s0       usr
drwxr-xr-x. root root system_u:object_r:var_t:s0       var</screen>
   </example>
   <para>上述の一覧に書かれているとおり、全てのディレクトリに対してコンテキストが設定されていることがわかります。ここにはユーザと役割、タイプがそれぞれ示されています。残る s0 はマルチレベルセキュリティ環境でのセキュリティレベルを示すもので、ここでは説明していません。このような環境では s0 が設定されていることを確認してください。コンテキストの種類は、そのディレクトリ内でどのような種類の動作を許可するのかを表しています。たとえば <filename>/root</filename> ディレクトリには <filename>admin_home_t</filename> というコンテキストタイプが割り当てられ、 <filename>/home</filename> ディレクトリには <filename>admin_home_t</filename> というコンテキストタイプが割り当てられています。 &selnx; のポリシーでは、これらのコンテキストタイプに対して様々な種類のアクセスが定義されています。</para>
   <para>セキュリティラベルはファイルに対して割り当てられるだけでなく、ポートやプロセスなどにも割り当てられます。 <xref linkend="ex-selnx-set-proc" xrefstyle="select:label quotedtitle nopage"/> では、サーバ内のプロセスに対するコンテキスト設定の表示例を示しています。</para>
   <example xml:id="ex-selnx-set-proc">
    <title><command>ps Zaux</command> によるプロセス向け &selnx; 設定の表示</title>
<screen>&prompt.sudo;<command>ps Zaux</command>
LABEL                           USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
system_u:system_r:init_t        root         1  0.0  0.0  10640   808 ?        Ss   05:31   0:00 init [5]
system_u:system_r:kernel_t      root         2  0.0  0.0      0     0 ?        S    05:31   0:00 [kthreadd]
system_u:system_r:kernel_t      root         3  0.0  0.0      0     0 ?        S    05:31   0:00 [ksoftirqd/0]
system_u:system_r:kernel_t      root         6  0.0  0.0      0     0 ?        S    05:31   0:00 [migration/0]
system_u:system_r:kernel_t      root         7  0.0  0.0      0     0 ?        S    05:31   0:00 [watchdog/0]
system_u:system_r:sysadm_t      root      2344  0.0  0.0  27640   852 ?        Ss   05:32   0:00 /usr/sbin/mcelog --daemon --config-file /etc/mcelog/mcelog.conf
system_u:system_r:sshd_t        root      3245  0.0  0.0  69300  1492 ?        Ss   05:32   0:00 /usr/sbin/sshd -o PidFile=/var/run/sshd.init.pid
system_u:system_r:cupsd_t       root      3265  0.0  0.0  68176  2852 ?        Ss   05:32   0:00 /usr/sbin/cupsd
system_u:system_r:nscd_t        root      3267  0.0  0.0 772876  1380 ?        Ssl  05:32   0:00 /usr/sbin/nscd
system_u:system_r:postfix_master_t root   3334  0.0  0.0  38320  2424 ?        Ss   05:32   0:00 /usr/lib/postfix/master
system_u:system_r:postfix_qmgr_t postfix  3358  0.0  0.0  40216  2252 ?        S    05:32   0:00 qmgr -l -t fifo -u
system_u:system_r:crond_t       root      3415  0.0  0.0  14900   800 ?        Ss   05:32   0:00 /usr/sbin/cron
system_u:system_r:fsdaemon_t    root      3437  0.0  0.0  16468  1040 ?        S    05:32   0:00 /usr/sbin/smartd
system_u:system_r:sysadm_t      root      3441  0.0  0.0  66916  2152 ?        Ss   05:32   0:00 login -- root
system_u:system_r:sysadm_t      root      3442  0.0  0.0   4596   800 tty2     Ss+  05:32   0:00 /sbin/mingetty tty2</screen>
   </example>
  </sect2>

  <sect2 xml:id="sec-selinux-selectmode">
   <title>&selnx; モードの選択</title>
   <para>&selnx; では、 3 種類のモードを使用します:</para>
   <variablelist>
    <varlistentry>
     <term>強制 (Enforcing):</term>
     <listitem>
      <para>こちらが既定のモードです。 &selnx; では、ポリシー内のルールに従ってサーバを保護します。合わせて &selnx; では、監査ログ内に動作状況を記録します。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>許容 (Permissive):</term>
     <listitem>
      <para>このモードはトラブルシューティングで有用な仕組みです。許容モードでは、 &selnx; はサーバを保護しませんが、ログファイル内への記録は変わらず行われます。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>無効 (Disabled):</term>
     <listitem>
      <para>このモードでは、 &selnx; は完全に無効化され、ログへの記録も行われません。ファイルシステム内に設定されたラベルについては、ファイルシステムから削除されることはありません。</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>&selnx; のモードの設定方法については前述のとおり、システム起動時の &grub; でパラメータを指定して行います。</para>
  </sect2>

  <sect2 xml:id="sec-selinux-modifycontext">
   <title>&selnx; のコンテキストタイプの変更</title>
   <para>管理者の作業として重要なものとして、 &selnx; を正しく動作させるため、ファイルにコンテキストタイプを設定する作業があります。</para>
   <para>ファイルが特定のディレクトリ内に作成されると、既定では親のディレクトリのコンテキストタイプを継承します。ですが、ファイルが一方のディレクトリから他方のディレクトリに移動されると、以前の場所でのコンテキストタイプをそのまま適用し続けます。</para>
   <para>ファイルに対してコンテキストタイプを設定するには、 <command>semanage fcontext</command> コマンドを使用します。このコマンドでは、新しいコンテキストタイプをポリシー内に書き込むまでは行うものの、実際のコンテキストタイプを即時に反映することは行いません。ポリシー内のコンテキストタイプを実際に反映させるには、設定後に <command>restorecon</command> コマンドを実行します。</para>
   <para><command>semanage fcontext</command> を利用してみる前に、まずは実際にどのようなコンテキストが必要なのかを確認します。具体的には下記のように実行します:</para>
<screen>&prompt.sudo;<command>semanage fcontext -l</command></screen>
   <para>上記のように実行することで、ポリシー内に設定されている全てのコンテキストを表示することができます。ですが、出力は比較的長いものであるため、実際に必要なコンテキストを知るには少し面倒ではあります (<xref linkend="ex-selnx-semanage" xrefstyle="select:label quotedtitle nopage"/> をご覧ください) 。</para>
   <example xml:id="ex-selnx-semanage">
    <title>既定のファイルコンテキストの表示</title>
<screen>&prompt.sudo;<command>semanage fcontext -l | less</command>
&selnx; fcontext                                   type               Context

/                                                  directory          system_u:object_r:root_t:s0
/.*                                                all files          system_u:object_r:default_t:s0
/[^/]+                                             regular file       system_u:object_r:etc_runtime_t:s0
/\.autofsck                                        regular file       system_u:object_r:etc_runtime_t:s0
/\.autorelabel                                     regular file       system_u:object_r:etc_runtime_t:s0
/\.journal                                         all files          X:&gt;&gt;None&gt;&gt;
/\.suspended                                       regular file       system_u:object_r:etc_runtime_t:s0
/a?quota\.(user|group)                             regular file       system_u:object_r:quota_db_t:s0
/afs                                               directory          system_u:object_r:mnt_t:s0
/bin                                               directory          system_u:object_r:bin_t:s0
/bin/.*                                            all files          system_u:object_r:bin_t:s0</screen>
   </example>
   <para>お使いのサービスでどのようなコンテキスト設定が利用できるのかを確認する方法には、下記の 3 つの方法があります:</para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>サービスをインストールして、使用されている既定のコンテキストを判別する方法。この方法が最も簡単であり、推奨される方法です。</para>
    </listitem>
    <listitem>
     <para>特定のサービスに対してマニュアルページを確認します。サービスによっては <literal>_selinux</literal> で終わる名前のマニュアルページを用意しているものがあり、必要なコンテキスト設定の情報を取得できるものがあります。</para>
     <para>正しいコンテキスト設定を見つけることができたら、 <command>semanage fcontext</command> を利用して設定を適用します。このコマンドでは <option>-t</option> のコンテキストタイプの指定を最初のパラメータとして指定し、その後ろに適用したい先のディレクトリやファイルを指定します。コンテキストを適用したいディレクトリ内に存在する全てに対して、コンテキストを適用したい場合は、ディレクトリ名の箇所に <literal>(/.*)?</literal> を指定します。これは正規表現で、スラッシュに続いて任意の文字が続くものを表しています。このほかにも、 <command>semanage</command> のマニュアルページ内の examples セクションには、 <command>semanage</command> を使用する際の様々な便利な例が示されています。正規表現に関する詳しい情報については、 <link xlink:href="https://ja.wikipedia.org/wiki/%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%8F%BE"/> をお読みください。</para>
    </listitem>
    <listitem>
     <para>お使いのシステムで利用可能な全てのコンテキストタイプを一覧表示する方法:</para>
<screen>&prompt.sudo;<command>seinfo -t</command></screen>
     <para>コマンドそれ自身は非常に多くの情報を出力します。そのため、 <command>grep</command> などのコマンドを併用して、必要な情報だけを取得するようにしてください。</para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 xml:id="sec-selinux-applyfilecontext">
   <title>ファイルコンテキストの適用</title>
   <para>&selnx; のコンテキストを正しく適用するため、下記の手順では <command>semanage fcontext</command> と <command>restorecon</command> を使用して、コンテキストを設定する方法を示しています。ここまでの説明でご存じのとおり、既定のドキュメントルート以外を使用した場合、 Web サーバが動作しません。 &selnx; の設定を変更して、正しく動作するようにするまでの手順を示します:</para>
   <procedure>
    <step>
     <para><filename>/web</filename> ディレクトリを作成し、そのディレクトリに移動します:</para>
<screen>&prompt.sudo;<command>mkdir /web  &amp;&amp; cd /web</command></screen>
    </step>
    <step>
     <para>テキストエディタを利用して、 <filename>/web/index.html</filename> ファイルを作成し、どんなものでもかまいませんのでコンテンツを作成します。</para>
    </step>
    <step>
     <para><filename>/etc/apache2/default-server.conf</filename> ファイルをエディタで開いて、 DocumentRoot の行を <literal>DocumentRoot /web</literal> のように変更します。</para>
    </step>
    <step>
     <para>Apache Web サーバを再起動します:</para>
<screen>&prompt.sudo;<command>systemctl start apache2</command></screen>
    </step>
    <step>
     <para>ローカルの Web サーバが表示できるかどうか、テストを行います:</para>
<screen>&prompt.user;<command>w3m localhost</command></screen>
     <para><emphasis>Connection refused</emphasis> (接続が拒否されました) のようなメッセージが表示されるかと思います。 <keycap function="enter"/> を押したあと、 <command>q</command> を押して w3m を終了します。</para>
    </step>
    <step>
     <para>Apache Web サーバ既定の <literal>ドキュメントルート</literal> に対して、コンテキストタイプを表示します。このディレクトリは <filename>/srv/www/htdocs</filename> になっています。このディレクトリに対しては、 <filename>httpd_sys_content_t</filename> が設定されているはずです:</para>
<screen>&prompt.sudo;<command>ls -Z /srv/www</command></screen>
    </step>
    <step>
     <para>ポリシー内に新しいコンテキストを設定します。下記のとおり入力して <keycap function="enter"/> を押します:</para>
<screen>&prompt.sudo;<command>semanage fcontext -a -f "" -t httpd_sys_content_t '/web(/.*) ?'</command></screen>
    </step>
    <step>
     <para>新しいコンテキストタイプを適用します:</para>
<screen>&prompt.sudo;<command>restorecon /web</command></screen>
    </step>
    <step>
     <para><filename>/web</filename> ディレクトリ内のファイルのコンテキスト情報を表示します。<filename>/web</filename> ディレクトリには正しく設定されているものの、そのディレクトリ内のファイルには設定されていないはずです:</para>
<screen>&prompt.sudo;<command>ls -Z /web</command></screen>
    </step>
    <step>
     <para>今度は新しいコンテキストを、 <filename>/web</filename> ディレクトリ以下の全てに対して再帰的に適用します。これでファイルにも新しいコンテキストが適用されるようになります:</para>
<screen>&prompt.sudo;<command>restorecon -R /web</command></screen>
    </step>
    <step>
     <para>Web サーバを再起動します:</para>
<screen>&prompt.sudo;<command>systemctl restart apache2</command></screen>
     <para>これで <filename>/web</filename> ディレクトリ内のコンテンツについても、問題なくアクセスできるようになっているはずです。</para>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec-selinux-configurepolicy">
   <title>&selnx; ポリシーの設定</title>
   <para>ポリシーの動作を変更する際、最も簡単なものは可否設定 (boolean) です。可否設定はオンとオフを切り替えることのできる項目で、ポリシー内で変更することのできるものです。利用可能な設定の一覧を取得するには、下記のように入力して実行します:</para>
<screen>&prompt.sudo;<command>semanage boolean -l</command></screen>
   <para>上記を実行すると、可否設定の長い一覧と共に、それぞれの可否設定に対する短い説明文が表示されます。必要な可否設定を見つけることができたら、あとは <command>setsebool -P</command> を利用して、設定作業を行います。このコマンドの後ろには可否設定の名前を指定します。このとき、 <command>setsebool</command> に <option>-P</option> というオプションを指定していることに注目してください。このオプションは、ディスク上にあるポリシーファイル内に設定を書き込むためのもので、システムを再起動しても設定を残すように設定するための唯一の方法でもあります。</para>
   <para>下記の手順では、可否設定の変更例を示しています:</para>
   <procedure>
    <step>
     <para>まずは FTP サーバに関連する可否設定を一覧表示します:</para>
<screen>&prompt.sudo;<command>semanage boolean -l | grep ftp</command></screen>
    </step>
    <step>
     <para>可否設定をオフにします:</para>
<screen>&prompt.sudo;<command>setsebool allow_ftpd_anon_write off</command></screen>
     <para>なお、変更を書き込むのにそれほど時間はかかりません。設定を書き込んだら、本当にオフになっているのかを確認します:</para>
<screen>&prompt.sudo;<command>semanage boolean -l|grep ftpd_anon</command></screen>
    </step>
    <step>
     <para>あとはサーバを再起動します。</para>
    </step>
    <step>
     <para>再起動後、 <literal>allow_ftpd_anon_write</literal> の設定がオンに戻っていることを確認します。これは、ポリシーがファイルには書き込まれなかったためです。</para>
    </step>
    <step>
     <para>再度可否設定を切り替えて、今度はポリシーファイルにも書き込みます:</para>
<screen>&prompt.sudo;<command>setsebool -P allow_ftpd_anon_write</command></screen>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec-selinux-module">
   <title>&selnx; モジュールの使用</title>
   <para>既定では、 &selnx; はモジュール型のポリシーを使用します。これは、 &selnx; の機能が単一の巨大なポリシーとして作られているのではなく、多数の小さいモジュールとして構成されていることを意味しています。それぞれのモジュールには、それぞれ対応する &selnx; の設定パートがあります。このような &selnx; の仕組みにより、サードパーティのベンダがサービスを提供する場合でも、自身のサービスを &selnx; に対応できるようにすることができます。 &selnx; のモジュールの一覧を取得するには、 <command>semodule -l</command> コマンドを実行します。このコマンドは、 &selnx; で使用されている全てのモジュールと、そのバージョン番号を表示します。</para>
   <para>管理者の権限を使用すると、モジュールを個別にオンもしくはオフにすることができます。これは &selnx; の一部の機能のみを無効化したい場合や、全てのサービスを &selnx; で保護する必要がない場合に便利な仕組みです。特に &productname; では、 &selnx; ポリシーを完全にサポートしているわけではないので、全てのモジュールをいったんオフに設定して、必要なサービスにのみ &selnx; の保護を適用したほうが都合がよいことがあります。 &selnx; のモジュールをオフにしたい場合は、下記のように入力して実行します:</para>
<screen>&prompt.sudo;<command>semodule -d <replaceable>モジュール名</replaceable></command></screen>
   <para>オンに戻したい場合は、下記のように入力して実行します:</para>
   <screen>&prompt.sudo;<command>semodule -e <replaceable>モジュール名</replaceable></command></screen>
   <!--
    <remark>jsegitz, 2015-10-30: not true, the source files aren't available</remark>
   <para>
    It will change the current state of the module in the
    <filename>/etc/selinux/minimum/policy/modules.conf</filename> file.
   </para>
   <para>
    To handle policy modules properly, it helps to understand what you are
    dealing with. In the end, a policy module is a compiled policy file that
    you can load using the <command>semodule -e</command> command. You can
    recognize these files by the extension they use:
    *<filename>.pp</filename> (which stands for Policy Package). In some
    cases it can be useful to modify modules to have them do exactly what
    you need them to do. Three different kinds of files are used as input
    files for policy modules and you can find them in subdirectories of the
    <filename>/etc/selinux/minimum/policy/modules</filename> directory:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>
      <filename>*.te</filename> files contain the actual allow rules and
      calls to interfaces (also transition rules). These rules tell the
      policy how to deal with specific subprocesses that are started. You
      will not often change these as an administrator.
     </para>
    </listitem>
    <listitem>
     <para>
      <filename>*.if</filename> files contain interface definitions. As an
      administrator you do not typically change the contents of these files.
     </para>
    </listitem>
    <listitem>
     <para>
      <filename>*.fc</filename> files contain the labeling instructions that
      apply to this policy. As an administrator, you may need to change
      their contents with the <command>semanage</command> to modify the
      default behavior of policies.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    In
    <xref linkend="ex-selnx-li-apachefc" xrefstyle="select:label quotedtitle nopage"/>
    below you can see the first 20 lines of the
    <filename>apache.fc</filename> file. This is the file that contains the
    default file contexts that are used for the Apache server.
   </para>
   <example xml:id="ex-selnx-li-apachefc">
    <title>The first 20 lines of <filename>apache.fc</filename></title>
<screen>/etc/apache(2)?(/.*)? gen_context(system_u:object_r:httpd_config_t,s0)
/etc/apache-ssl(2)?(/.*)? gen_context(system_u:object_r:httpd_config_t,s0)
/etc/htdig(/.*)? gen_context(system_u:object_r:httpd_sys_content_t,s0)
/etc/httpd -d gen_context(system_u:object_r:httpd_config_t,s0) /etc/httpd/conf.*
gen_context(system_u:object_r:httpd_config_t,s0) /etc/httpd/logs
gen_context(system_u:object_r:httpd_log_t,s0) /etc/httpd/modules
gen_context(system_u:object_r:httpd_modules_t,s0) /etc/vhosts \-\-
gen_context(system_u:object_r:httpd_config_t,s0) /srv/([^/]*/)?www(/.*)?
gen_context(system_u:object_r:httpd_sys_content_t,s0) /srv/gallery2(/.*)?
gen_context(system_u:object_r:httpd_sys_content_t,s0) /usr/bin/htsslpass \-\-
gen_context(system_u:object_r:httpd_helper_exec_t,s0) /usr/lib/apache-ssl/.+ \-\-
gen_context(system_u:object_r:httpd_exec_t,s0) /usr/lib/cgi-bin(/.*)?
gen_context(system_u:object_r:httpd_sys_script_exec_t,s0)
/usr/lib(64)?/apache(/.*)? gen_context(system_u:object_r:httpd_modules_t,s0)
/usr/lib(64)?/apache2/modules(/.*)?
gen_context(system_u:object_r:httpd_modules_t,s0)</screen>
   </example>
   <remark>jsegitz, 2015-10-30: these are not the first 20 lines of the file and it's also syntactically incorrect. Please check the current file</remark>
   <para>
    In the <filename>fc</filename> file, you will be able to recognize
    different elements. First is the name of the directory or file to which
    the file context will apply. As you can see, variables can be used (as
    is the case in the first line that starts with
    <varname>HOME_DIR</varname>),
    <remark>jsegitz, 2015-10-30: the description doesn't match the listing</remark>
    and typically, regular expressions will be used as well. Next, the
    gen_context command tells the policy to which context the files related
    to the policy module should be set. This is the same context setting
    that you can see when using <command>ls -Z</command> on the file or
    directory.
   </para>

   <para>
    To change the contents of any of the policy module files,
    compile the changes into a new policy module file. To do this,
    first install the <systemitem>selinux-policy-devel</systemitem> package.
    Then, in the directory where the files created by
    <command>audit2allow</command> are located, run:
   </para>
   <screen>&prompt.user;make -f /usr/share/selinux/devel/Makefile</screen>
   <para>
    When <command>make</command> has completed, you can manually load the
    modules into the system, using <command>semodule -i</command>.
   </para>   -->
  </sect2>
 </sect1>
 <sect1 xml:id="sec-selinux-troubleshoot">
  <title>トラブルシューティング</title>

  <para>既定では、 &selnx; が何らかの理由で動作しない場合、ログメッセージが <filename>/var/log/audit/audit.log</filename> ファイル内に記録されます。ただし、このファイルに書き込みを行うには、 auditd サービスを動作させて置かなければなりません。 <filename>/var/log/audit</filename> ディレクトリ内に何もファイルが存在しない場合は、下記のように入力して実行し、 auditd サービスを開始してください:</para>

<screen>&prompt.sudo;<command>systemctl start auditd</command></screen>

  <para>また、システムの起動時に開始するように設定したい場合は、下記のように入力して実行します:</para>

<screen>&prompt.sudo;<command>systemctl enable auditd</command></screen>

  <para><xref linkend="ex-selnx-li-auditlog" xrefstyle="select:label quotedtitle nopage"/> には、 <filename>/var/log/audit/audit.log</filename> の内容の出力例があります:</para>

  <example xml:id="ex-selnx-li-auditlog">
   <title><filename>/etc/audit/audit.log</filename> の例</title>
<screen>type=DAEMON_START msg=audit(1348173810.874:6248): auditd start, ver=1.7.7 format=raw kernel=3.0.13-0.27-default auid=0 pid=4235 subj=system_u:system_r:auditd_t res=success
type=AVC msg=audit(1348173901.081:292): avc:  denied  { write } for  pid=3426 comm="smartd" name="smartmontools" dev=sda6 ino=581743 scontext=system_u:system_r:fsdaemon_t tcontext=system_u:object_r:var_lib_t tclass=dir
type=AVC msg=audit(1348173901.081:293): avc:  denied  { remove_name } for  pid=3426 comm="smartd" name="smartd.WDC_WD2500BEKT_75PVMT0-WD_WXC1A21E0454.ata.state~" dev=sda6 ino=582390 scontext=system_u:system_r:fsdaemon_t tcontext=system_u:object_r:var_lib_t tclass=dir
type=AVC msg=audit(1348173901.081:294): avc:  denied  { unlink } for  pid=3426 comm="smartd" name="smartd.WDC_WD2500BEKT_75PVMT0-WD_WXC1A21E0454.ata.state~" dev=sda6 ino=582390 scontext=system_u:system_r:fsdaemon_t tcontext=system_u:object_r:var_lib_t tclass=file
type=AVC msg=audit(1348173901.081:295): avc:  denied  { rename } for  pid=3426 comm="smartd" name="smartd.WDC_WD2500BEKT_75PVMT0-WD_WXC1A21E0454.ata.state" dev=sda6 ino=582373 scontext=system_u:system_r:fsdaemon_t tcontext=system_u:object_r:var_lib_t tclass=file
type=AVC msg=audit(1348173901.081:296): avc:  denied  { add_name } for  pid=3426 comm="smartd" name="smartd.WDC_WD2500BEKT_75PVMT0-WD_WXC1A21E0454.ata.state~" scontext=system_u:system_r:fsdaemon_t tcontext=system_u:object_r:var_lib_t tclass=dir
type=AVC msg=audit(1348173901.081:297): avc:  denied  { create } for  pid=3426 comm="smartd" name="smartd.WDC_WD2500BEKT_75PVMT0-WD_WXC1A21E0454.ata.state" scontext=system_u:system_r:fsdaemon_t tcontext=system_u:object_r:var_lib_t tclass=file
type=AVC msg=audit(1348173901.081:298): avc:  denied  { write open } for  pid=3426 comm="smartd" name="smartd.WDC_WD2500BEKT_75PVMT0-WD_WXC1A21E0454.ata.state" dev=sda6 ino=582390 scontext=system_u:system_r:fsdaemon_t tcontext=system_u:object_r:var_lib_t tclass=file
type=AVC msg=audit(1348173901.081:299): avc:  denied  { getattr } for  pid=3426 comm="smartd" path="/var/lib/smartmontools/smartd.WDC_WD2500BEKT_75PVMT0-WD_WXC1A21E0454.ata.state" dev=sda6 ino=582390 scontext=system_u:system_r:fsdaemon_t tcontext=system_u:object_r:var_lib_t tclass=file
type=AVC msg=audit(1348173901.309:300): avc:  denied  { append } for  pid=1316</screen>
  </example>

  <para>はじめて <filename>audit.log</filename> をお読みになる方にとっては、少しわかりにくいと感じることでしょう。しかしながら、読み方がわかればそれほど難しくはありません。各行はそれぞれセクションに分割することができます。たとえば末尾の行の意味は下記のようになります:</para>

  <variablelist>
   <varlistentry>
    <term><literal>type=AVC</literal> :</term>
    <listitem>
     <para>それぞれの &selnx; 関連の監査ログ行には、 <literal>type=AVC</literal> という種類判別用の記述が書き込まれます。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>msg=audit(1348173901.309:300)</literal> :</term>
    <listitem>
     <para>これはタイムスタンプを意味しています。ただし、エポック秒と呼ばれる、 1970 年 1 月 1 日からの経過秒数で書かれています。整数部分については、 <command>date -d</command> コマンドで日時に変換することができます:</para>
<screen>&prompt.user;<command>date -d @1348173901</command>
2012年  9月 21日 金曜日 05:45:01 JST</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>avc: denied { append }</literal> :</term>
    <listitem>
     <para>拒否された処理の内容を示しています。この場合、システムはデータをファイルに追記する処理が拒否されたことを表しています。監査ログファイル内では、ファイルを開いたり属性を取得したりなど、様々な処理が記録されることになります。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>for pid=1316</literal> :</term>
    <listitem>
     <para>その処理を実施したコマンドもしくはプロセスのプロセス ID です。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>comm="rsyslogd"</literal> :</term>
    <listitem>
     <para>その PID に結びつけられたコマンドを表しています。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>name="smartmontools"</literal> :</term>
    <listitem>
     <para>処理を実行しようとしたアプリケーションの名前を表しています。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>dev=sda6 ino=582296</literal> :</term>
    <listitem>
     <para>対象となるファイルが存在するブロックデバイス名と inode 番号です。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>scontext=system_u:system_r:syslogd_t</literal> :</term>
    <listitem>
     <para>ソースコンテキストと呼ばれ、処理を実行しようとした側のコンテキストを表しています。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>tclass=file</literal> :</term>
    <listitem>
     <para>処理内容の分類名を表しています。</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>audit.log 内の各イベントの意味を自分自身で解釈する以外の方法もあります。それは、 <command>audit2allow</command> というコマンドです。このコマンドは、わかりにくい <filename>/var/log/audit/audit.log</filename> 内のメッセージを分析するための支援を行うソフトウエアです。下記に示す 3 種類の形態が用意されています。 1 つめは <command>audit2allow -w -a</command> のような実行形態で、より読みやすい形式で監査情報を表示することができます。 <command>audit2allow -w -a</command> は、既定では audit.log ファイルを読み込みます。 audit.log ファイル内の特定のメッセージのみを分析したい場合は、一時ファイルにコピーして下記のように入力して実行してください:</para>

<screen>&prompt.sudo;<command>audit2allow -w -i <replaceable>ファイル名</replaceable></command></screen>

  <example>
   <title>監査メッセージの分析</title>
<screen>&prompt.sudo;<command>audit2allow -w -i testfile</command>
type=AVC msg=audit(1348173901.309:300): avc:  denied  { append } for  pid=1316
comm="rsyslogd" name="acpid" dev=sda6 ino=582296
scontext=system_u:system_r:syslogd_t tcontext=system_u:object_r:apmd_log_t tclass=file</screen>
  </example>

  <variablelist>
   <varlistentry>
    <term>これは下記の理由によって発生しています:</term>
    <listitem>
     <para>タイプ強制 (Type Enforcement; TE) の許可ルールが存在しないためです。</para>
     <para>このアクセスを許可するような読み込みモジュールを生成するには、下記のように入力して実行します:</para>
<screen>&prompt.sudo;<command>audit2allow</command></screen>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>アクセスを拒否したルールを見つけたい場合は、 <command>audit2allow -a</command> と入力して実行し、 <filename>audit.log</filename> ファイル内に記録された全てのメッセージから、対応する強制ルールを表示することができるほか、 <command>audit2allow -i <replaceable>ファイル名</replaceable></command> のように入力して実行することで、指定したファイル内に保存されているメッセージに対する強制ルールを表示することもできます。</para>

  <example>
   <title>アクセス拒否内容の表示</title>
<screen>&prompt.sudo;<command>audit2allow -i testfile</command>
#============= syslogd_t ==============
allow syslogd_t apmd_log_t:file append;</screen>
  </example>

  <para><literal>mymodule</literal> という名前の &selnx; モジュールを作成し、以前は拒否されていたアクセスを許可するように設定したい場合は、下記のように入力して実行します:</para>

<screen>&prompt.sudo;<command>audit2allow -a -R -M mymodule</command></screen>

  <para>audit.log に記録されている全てのイベントに対して、同様のことを行いたい場合は、パラメータに <option>-a -M</option> を追加します。また、特定のファイル内のメッセージに対してのみ実施したい場合は、下記のように <option>-i -M</option> を追加します:</para>

  <example>
   <title>以前に拒否されたアクションを許可するためのポリシー作成</title>
<screen>&prompt.sudo;<command>audit2allow -i testfile -M example</command>
******************** IMPORTANT ***********************
To make this policy package active, execute:

semodule -i example.pp</screen>
  </example>

  <para><command>audit2allow</command> コマンドの出力にもあるとおり、この後に <command>semodule -i</command> コマンドの後ろにモジュール名指定して、実行します。このとき、モジュール名は <command>audit2allow</command> で指定した名前となります (上記の例では <filename>example.pp</filename> です) 。</para>
 </sect1>
</chapter>
