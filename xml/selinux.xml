<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter [
<!ENTITY % entities SYSTEM "entity-decl.ent">
%entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha-selinux">
 <title>&selnx; の設定</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
  </dm:docmanager>
 </info>
 <para>本章では、 &productname; 上で &selnx; を使用する際の、設定と管理の方法について説明しています。下記のトピックをカバーしています:</para>
 <itemizedlist mark="bullet" spacing="normal">
  <listitem>
   <para>なぜ &selnx; を使用するのか</para>
  </listitem>
  <listitem>
   <para>&selnx; とは</para>
  </listitem>
  <listitem>
   <para>&selnx; の設定方法</para>
  </listitem>
  <listitem>
   <para>&selnx; の管理</para>
  </listitem>
 </itemizedlist>
 <sect1 xml:id="sec-selinux-why">
  <title>なぜ &selnx; を使用するのか</title>

  <para>&selnx; は Linux カーネル内でのセキュリティフレームワークを使用する、追加の Linux セキュリティソリューションとして開発されてきました。既存の読み込みと書き込み、実行に対するパーミッション設定で利用可能な機能に加える形で、さらにきめ細かいセキュリティポリシーを適用できるようにし、 Linux 上で利用できる様々なケーパビリティに対して、さらに詳しいアクセス許可設定を実現するためのものです。 &selnx; はカーネルに対して届くすべてのシステムコールを捉え、既定では拒否するように設定されています。これにより、 &selnx; が有効化されている環境では、何も設定されていないと何も動作しないことになります。お使いのシステムが何らかの動作を必要とする場合、管理者はルールを作成してポリシー内に配置する必要があります。</para>

  <para>下記の例では、なぜ &selnx; (もしくはその同等品である &aa;) が必要となるのかについて、説明しています:</para>

  <para><quote>ある朝、私はサーバがクラックされていることに気がついた。サーバは &slsa; ですべての修正 (パッチ) が適用され動作していた。ファイアウオールについても正しく設定が行なわれ、そのサーバでは不要なサービスは全く提供していなかった。より詳しく調査を行なうと、クラッカーはサーバ内の Apache 仮想ホスト内の 1 つに設置された、脆弱性のある PHP スクリプトを通して侵入を行なっていた。クラッカーはその後、 Apache Web サーバで使用されている <systemitem class="username">wwwrun</systemitem> を利用して、シェルへのアクセスを取得していた。この <systemitem class="username">wwwrun</systemitem> での侵入後、 <filename>/var/tmp</filename> および <filename>/tmp</filename> の各ディレクトリ内に複数のスクリプトを作成し、これを様々なサーバへの分散型サービス拒否攻撃のボットネットとして動作させていた。</quote></para>

  <para>ここで注目すべき点は、このクラッキングでは、サーバ側の設定を誤っているわけではない、という点です。すべてのパーミッションの設定が正しいにも関わらず、侵入者はシステム内に入り込むことができてしまっています。この例で悪い点があるとすれば、追加のセキュリティシステムが必要であるにもかかわらず、それを導入していなかった点にあります。このような要件に対応できるのが &selnx; です。 &selnx; とは異なり、完成度が低いものの簡易的なセキュリティとして使用できるのが &aa; となります。</para>

  <para>&aa; はプロセスに対して権限を制限し、ファイル (もしくはその他のオブジェクト) に対して、読み込みや書き込み、実行などの制御を行ないます。もちろんプロセス内部からは、その制限を回避することができません。</para>

  <para>&selnx; では、オブジェクト (ファイルやバイナリ、ネットワークソケット) に対してラベルを設定し、このラベルを権限の境界線を決めるものとして使用します。そのため、複数のプロセスやシステム全体にまたがる制限レベルを設定することができます。</para>

  <para>&selnx; は アメリカ国家安全保障局 (US National Security Agency (NSA)) が開発してきたソフトウエアで、 Red Hat 社も大きく開発に関わっています。 &selnx; の初期バージョンは、 2006 年前後に公開された <trademark>Red Hat Enterprise Linux 4</trademark> で初めて提供されました。当初は基本的なサービスにのみ対応していたものの、後年になって幅広いサービスに対する保護を提供する目的で、様々なポリシーを含む多数のルールがシステムに取り込まれるようになりました。</para>

  <para>&selnx; は Common Criteria や FIPS 140 などの標準規格に従って開発されてきた経緯があります。そのため、これらの標準に従ったソリューションを求める顧客が要求を行なってきたことで、 &selnx; は比較的早く有名な存在になりました。</para>

  <para>&selnx; の代替として、 2005 年に Novell に買収された Immunix 社が &aa; を開発しました。 &aa; は &selnx; と同じセキュリティ原則で作成されていますが、 &selnx; とは全く異なるアプローチで作られています。それは、ウイザード型の作業手順を適用することで、アプリケーションが必要とするリソースを正確に設定できるはずである、という考え方です。 &selnx; よりも &aa; のほうが、サーバの安全を確保するのに適切な点も存在するのですが、残念ながら &aa; は &selnx; と同じ状況には至っていません。</para>

  <para>多くの組織では、 Linux ディストリビューションに対して &selnx; を使用するように求めています。 &suse; もその中の 1 つで、 &productname; 内で &selnx; フレームワークへの対応が求められてきました。もちろんこれは、 &productname; の既定のインストールで、近い将来 &aa; が &selnx; に置き換えられるというわけではありません。</para>

  <sect2 xml:id="sec-selinux-support">
   <title>サポート状態</title>
   <para>&selnx; フレームワークは &productname; でもサポート対象となっています。つまり&productnameshort; では、お使いのサーバ内で &selnx; を使用するのに必要な、すべてのバイナリやライブラリが提供されます。ただし、他の Linux ディストリビューションで用意されているソフトウエアが、 &productnameshort; では用意されていない場合もあります。</para>
   <para>&productname; での &selnx; は、比較的初期の段階にあるものと考えられています。つまり、場合によっては予期しない結果をもたらすこともあります。発生しうるリスクを最小限にするには、既定の &productname; で提供されるバイナリのみを使用するようにしてください。</para>
  </sect2>

  <sect2 xml:id="sec-selinux-component">
   <title>&selnx; のコンポーネント</title>
   <para>&selnx; の設定を始める前に、まずは &selnx; の構成について知っておく必要があります。 &selnx; では、下記の 3 種類から構成されています:</para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>Linux カーネル内にあるセキュリティフレームワーク</para>
    </listitem>
    <listitem>
     <para>&selnx; のライブラリとバイナリ</para>
    </listitem>
    <listitem>
     <para>&selnx; のポリシー</para>
    </listitem>
   </itemizedlist>
   <para>&productname; の既定のカーネルであれば &selnx; に対応していますので、ツールを使用するだけで管理を行なうことができます。そのため、管理者にとって最も重要な作業は、 &selnx; のポリシー管理ということになります。</para>
   <warning xml:id="sec-selinux-reference-policy">
       <title>No Default Policy Included</title>
       <para>
           No default or reference policy is provided in
          &productname;.  &selnx; will not operate without a policy, 
    so you must build and install one. The &selnx; Reference Policy Project
    (<link xlink:href="https://github.com/SELinuxProject/refpolicy/wiki"/>)
    should be helpful in providing examples and detailed information on creating
    your own policies, and this chapter also provides guidance on managing
    your &selnx; policy.
</para>
</warning>
   
   <para>&selnx; のポリシーでは、 Linux サーバ内の様々なオブジェクトに対して、セキュリティラベルを設定します。これらのオブジェクトには、ユーザやポート、プロセスやファイルなどが含まれます。このようなセキュリティラベルを使用することで、サーバ内での許可を判断することになります。ただし、既定の &selnx; ではすべてのものを拒否する仕組みであることから、どうしても必要なアクセスのみを許可する適切なルール構築が重要となります。そのため、ルールはシステム内で使用するすべてのプログラムに対して存在していなければならないことになります。システムの一部に対して制限を撤廃することもできますが、その場合は、制限を撤廃したポートやプログラム、ユーザやディレクトリなどが、 &selnx; で保護されないことになります。このモードでは、重要なサービスのみを &selnx; で保護し、その他のサービスについては何もしないようにすることができます。ただし、システムの安全性という観点では、このような構成は避けるべきものです。</para>
   <para>お使いのシステムに対して適切な保護を実現するには、 &selnx; のポリシーを設定する必要があります。これはすべてのファイルに対してラベルを提供するよう仕立て上げられたポリシーでなければならず、すべてのサービスやユーザに対してセキュリティラベルを設定し、サーバ内でどのファイルやディレクトリにアクセスを許可するのかを設定するものでなければなりません。このようなポリシーの作成には、途方もない労力が必要となります。</para>
   <para>&selnx; は複雑な仕組みであることから、その使用を避けられる理由の 1 つにもなってしまっています。一般的な Linux システムも非常に複雑な仕組みであることから、何らかの考慮漏れを生み出す原因になってしまっていて、システムに侵入できる突破口を残してしまう原因にもなっています。また、あるべき姿で完全に設定した場合であっても、 &selnx; に関わるすべての要素を管理者が網羅するのは非常に難しいものです。複雑性という観点では、 &aa; は全く異なるアプローチになっています。 &aa; では、管理者がその保護を設定する際、何が起こっているのかを理解するのに十分な自動化を提供しています。</para>
   <para>なお、無償で提供されている様々な &selnx; ポリシーは、お使いのサーバでも問題なく動作するとは思いますが、独自にポリシーを構築するのに比べると、保護レベルが落ちることがほとんどであることに注意してください。また、 &suse; ではサードパーティ性のポリシーへのサポートは行なっておりません。</para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-selinux-policy">
  <title>ポリシー</title>

  <para>
   The policy is the key component in &selnx;. Note that no default or reference
   policy is included in &productname;, and you must build and install one that is customized for 
   your needs before proceeding. (See <xref linkend="sec-selinux-reference-policy"/>. )
   </para>
   <para>上述のとおり、 &selnx; で鍵となるコンポーネントはポリシーそのものです。このポリシーは、システムに存在するファイルやディレクトリ、ポートやプロセスに対して、アクセスルールを規定するものです。これを実現するために、これらすべてに対してセキュリティコンテキストを定義しています。 &selnx; のシステムでは、ファイルシステム内でラベルを設定し、ポリシーを構成しています。任意のディレクトリで <command>ls -Z</command> のように入力して実行すると、そのディレクトリ内に存在するファイルに対して、割り当てられているセキュリティコンテキストを表示することができます。 <xref linkend="ex-selnx-con-set" xrefstyle="select:label quotedtitle nopage"/> では、 &selnx; のラベルが設定された &productname; システムで、 <filename>/</filename> に対するセキュリティコンテキストの設定を示しています。</para>

  <example xml:id="ex-selnx-con-set">
   <title><command>ls -Z</command> を使用したセキュリティコンテキスト設定</title>
<screen>ls -Z
system_u:object_r:bin_t bin
system_u:object_r:boot_t boot
system_u:object_r:device_t dev
system_u:object_r:etc_t etc
system_u:object_r:home_root_t home
system_u:object_r:lib_t lib
system_u:object_r:lib_t lib64
system_u:object_r:lost_found_t lost+found
system_u:object_r:mnt_t media
system_u:object_r:mnt_t mnt
system_u:object_r:usr_t opt
system_u:object_r:proc_t proc
system_u:object_r:default_t root
system_u:object_r:bin_t sbin
system_u:object_r:security_t selinux
system_u:object_r:var_t srv
system_u:object_r:sysfs_t sys
system_u:object_r:tmp_t tmp
system_u:object_r:usr_t usr
system_u:object_r:var_t var</screen>
  </example>

  <para>セキュリティコンテキストで最も重要な箇所は、コンテキストタイプの表示です。これはセキュリティコンテキストの一部で、 _t で終わる名前で示されているものです。これは、 &selnx; でどのような種類のオブジェクトアクセスを許可するのかを表わしています。ポリシー内では、どの種類のユーザもしくはどの種類の役割から、この種類のコンテキストにアクセスを許可するのかを設定します。たとえば下記のようなルールがあります:</para>

<screen>allow user_t bin_t:file {read execute gettattr};</screen>

  <para>この例では、コンテキストタイプ <systemitem class="username">user_t</systemitem> が設定されているユーザから、コンテキストタイプ <filename>bin_t</filename> (ターゲット) が設定されたクラス "file" のオブジェクトに対して、アクセスを許可するようなルールになっています。この際、読み込みと実行、および getattr の権限が与えられています。</para>

  <para>使用しようとしている標準ポリシーには、多数のルールが含まれています。より管理をやりやすくするため、ポリシーはモジュールとして分割されることもしばしばあります。このような構造により、システム内の様々なパーツに対して、管理者が保護の ON/OFF を切り替えることができるようになっています。</para>

  <para>お使いのシステムにポリシーをコンパイルする際、モジュール型のポリシーだけでなく、お使いのシステムを保護する際のポリシーを 1 つにまとめた一枚岩のポリシーを使用することもできます。一枚岩のポリシーであると管理が非常に難しくなることから、特段の理由がない限り、モジュール型のポリシーを採用しておくことを強くお勧めします。これにより、管理もやりやすくなります。</para>
 </sect1>
 <sect1 xml:id="sec-selinux-install">
  <title>&selnx; パッケージのインストールと &grub; の変更</title>

  <para>すべての &selnx; コンポーネントをインストールする場合、最も簡単な方法は &yast; を使用することです。下記の手順では、インストール済みの &productname; で、インストールを行なう方法を示しています:</para>

  <procedure>
   <step>
    <para>サーバに対して <systemitem class="username">root</systemitem> でログインし、 &yast; を起動します。</para>
   </step>
   <step>
    <para><menuchoice> <guimenu>ソフトウエア</guimenu> <guimenu>ソフトウエア管理</guimenu> </menuchoice> を選択します。</para>
   </step>
   <step>
    <para><menuchoice> <guimenu>表示</guimenu> <guimenu>パターン</guimenu> </menuchoice> を選択し、 <guimenu>C/C++ 開発</guimenu> の分類を選択して、 C 言語向けのパッケージをインストールするように選択します。</para>
   </step>
   <step>
    <para>さらに <menuchoice> <guimenu>表示</guimenu> <guimenu>検索</guimenu> </menuchoice> を選択し、 <guimenu>名前</guimenu> , <guimenu>キーワード</guimenu> , <guimenu>概要</guimenu> が選択されていることを確認してから、 <literal>selinux</literal> と入力して <guimenu>検索</guimenu> を押します。これにより、パッケージの一覧が表示されます。</para>
   </step>
   <step>
    <para>検出したすべてのパッケージをインストールするよう選択し、 <guimenu>了解</guimenu> を押してパッケージをインストールします。</para>
   </step>
  </procedure>

  <figure xml:id="fig-packages-yast">
   <title>&yast; 内でのすべての &selnx; パッケージの選択</title>
   <mediaobject>
    <imageobject role="pdf">
     <imagedata fileref="selnx_policy_compiler.png" width="85%"/>
    </imageobject>
    <imageobject role="html">
     <imagedata fileref="selnx_policy_compiler.png" width="95%"/>
    </imageobject>
   </mediaobject>
  </figure>

  <para>&selnx; 関連のパッケージをインストールしたら、 &grub; ブートローダの設定変更を行ないます。 &yast; を起動して <menuchoice> <guimenu>システム</guimenu> <guimenu>ブートローダ</guimenu> <guimenu>カーネルのパラメータ</guimenu></menuchoice> を選択し、下記の内容を <guimenu>オプションのカーネルコマンドラインパラメータ</guimenu> に追加します:</para>

<screen>security=selinux selinux=1 enforcing=0</screen>

  <para>それぞれのオプションの意味は下記のとおりです:</para>

  <variablelist>
   <varlistentry>
    <term><literal>security=selinux</literal></term>
    <listitem>
     <para>このオプションを指定することにより、 &aa; ではなく &selnx; を使用することを宣言します。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>selinux=1</literal></term>
    <listitem>
     <para>このオプションを指定することにより、 &selnx; を有効化します。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>enforcing=0</literal></term>
    <listitem>
     <para>このオプションを設定することにより、 permissive (許容) モードに設定します。このモードでは、 &selnx; が完全に動作するものの、ポリシー内に書かれたセキュリティ設定は、実際には強制されなくなります。システムの動作確認を終え、 &selnx; の保護を有効化 したい場合は、このオプションを <literal>enforcing=1</literal> に設定し、 <filename>/etc/selinux/config</filename> 内で <literal>SELINUX=enforcing</literal> を設定してください。</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>&selnx; パッケージをインストールし、 &selnx; を &grub; ブートローダ内のパラメータで有効化したら、あとは設定を反映させるため、再起動を行なってください。</para>
 </sect1>
 <sect1 xml:id="sec-selinux-compilepolicy">
  <title>&selnx; のポリシー</title>

  <para>
   The policy is an essential component of &selnx;. &productname; &productnumber;
   does not include a default or reference policy, and you must build a policy that is
   customized for your installation. For testing and learning, see The &selnx; Reference 
   Policy Project at <link xlink:href="https://github.com/SELinuxProject/refpolicy/wiki"/>.
   You must have a policy, as &selnx; will not operate without one.
  </para>
  <para>ポリシーをインストールしたら、ファイルシステムに対するラベル付けを行ないます。下記のとおり入力して実行してください:</para>

<screen>&prompt.sudo;restorecon -Rp /</screen>

  <para>上記を実行すると、 <command>/sbin/setfiles</command> コマンドを実行して、お使いのシステム内にあるすべてのファイルに対して、ラベルを設定するようになります。このとき、 <filename>/etc/selinux/minimum/contexts/files/file_contexts</filename> という入力ファイルを使用します。 <filename>file_contexts</filename> ファイルには、お使いのファイルシステムにできる限りマッチするよう設定する必要があります。正しく設定しておかないと、お使いのシステムを全く起動することができなくなってしまいます。もしもこのような状況になってしまった場合は、 <command>semanage fcontext</command> コマンドで <filename>file_contexts</filename> 内のレコードを修正し、お使いのサーバ内のファイルシステム構造に対応するよう、設定を行なってください。たとえば下記のようになります:</para>

<screen>&prompt.sudo;semanage fcontext -a -t samba_share_t /etc/example_file</screen>

  <para>上記を実行すると、ファイルタイプの既定値である <literal>etc_t</literal> を<literal>samba_share_t</literal> に変更し、下記の内容を <filename>file_contexts.local</filename> 内に追加することができます:</para>

<screen>/etc/example_file    unconfined_u:object_r:samba_share_t:s0</screen>

  <para>あとは下記のように入力して実行します:</para>

<screen>&prompt.sudo;restorecon -v /etc/example_file</screen>

  <para>これにより、タイプの変更を反映させることができます。</para>

  <para>これを行なう前に、本章の残りの部分を読んでおくことで、どのようにしてコンテキストタイプがファイルやディレクトリに適用されているのかを完全に知ることができます。なお、作業を始める前に、 <filename>file_contexts</filename> ファイルのバックアップを忘れずに採取しておいてください。</para>

  <note>
   <title>ユーザ <systemitem class="username">nobody</systemitem> について</title>
   <para><command>semanage</command> を使用すると、 <systemitem class="username">nobody</systemitem> のホームディレクトリに関するメッセージが出力されることがあります。このような場合は、 <systemitem class="username">nobody</systemitem> に対して設定するシェルを、 <filename>/sbin/nologin</filename> にしてください。あとは <systemitem class="username">nobody</systemitem> の設定を現在のポリシー設定にあわせてください。</para>
  </note>

  <para>もう一度再起動を行なうことで、 &selnx; が正しく動作するようになります。動作状況を確認したい場合は、 <command>sestatus -v</command> を実行してください。これにより、 <xref linkend="ex-selnx-sestatus" xrefstyle="select:label quotedtitle nopage"/> のような出力が現われるはずです。</para>

  <example xml:id="ex-selnx-sestatus">
   <title>&selnx; が動作していることの確認</title>
<screen>&prompt.sudo;sestatus -v
SELinux status:                 enabled
SELinuxfs mount:                /selinux
Current mode:                   permissive
Mode from config file:          permissive
Policy version:                 26
Policy from config file:        minimum

Process contexts:
Current context:                root:staff_r:staff_t
Init context:                   system_u:system_r:init_t
/sbin/mingetty                  system_u:system_r:sysadm_t
/usr/sbin/sshd                  system_u:system_r:sshd_t

File contexts:
Controlling term:               root:object_r:user_devpts_t
/etc/passwd                     system_u:object_r:etc_t
/etc/shadow                     system_u:object_r:shadow_t
/bin/bash                       system_u:object_r:shell_exec_t
/bin/login                      system_u:object_r:login_exec_t
/bin/sh                         system_u:object_r:bin_t -&gt; system_u:object_r:shell_exec_t
/sbin/agetty                    system_u:object_r:getty_exec_t
/sbin/init                      system_u:object_r:init_exec_t
/sbin/mingetty                  system_u:object_r:getty_exec_t
/usr/sbin/sshd                  system_u:object_r:sshd_exec_t
/lib/libc.so.6                  system_u:object_r:lib_t -&gt; system_u:object_r:lib_t
/lib/ld-linux.so.2              system_u:object_r:lib_t -&gt; system_u:object_r:ld_so_t</screen>
  </example>
 </sect1>
 <sect1 xml:id="sec-selinux-configure">
  <title>&selnx; の設定</title>

  <para>この時点では既に &selnx; システムを完全に動作できていますので、後は設定作業ということになります。現時点では &selnx; が動作しているものの、強制 (enforcing) モードにはなっていません。つまり、何をするにしても制限が加わっておらず、強制モードに移行した際に実施される制限がログに記録されるだけです。ログファイルを読むことで、何が阻害されるのかを知ることができるという点で、このモードは有用です。ここでは、最初のテストとして &selnx; を強制モードに移行し、サーバを問題なく使用できるかどうかを確認します。これを行なうには、 &grub; の設定ファイル内で <option>enforcing=1</option> を設定し、 <filename>/etc/selinux/config</filename> 内で <option>SELINUX=enforcing</option> を指定します。設定が終わったらサーバを再起動し、きちんと起動ができるかどうかを確認してください。問題なく動作した場合は、そのままサーバの残りの機能が一通り動作するよう、必要に応じて設定を変更していきます。サーバが起動できない状態になってしまった場合は、 &selnx; の強制モードを解除して、サーバの調整作業を行なってください。</para>

  <!-- <sect2 xml:id="sec-selinux-verify"> -->
  <!--  <title>Verifying the Installation</title> -->
   <para>サーバの調整作業を行なう場合、まずは &selnx; のインストールを確認します。既に <command>sestatus -v</command> というコマンドを使用していますので、ここに表示されている現在のモードとプロセス、ファイルコンテキストをそれぞれ確認します。あとは下記のように実行して、利用可能な可否設定を確認します:</para>
<screen>&prompt.sudo;semanage boolean -l</screen>
   <para>この可否設定の一覧を表示することで、ポリシーへのアクセスも同時に検証することができます。 <xref linkend="ex-selnx-ls-bool"/> には、このコマンドの出力例が示されています:</para>
   <example xml:id="ex-selnx-ls-bool">
    <title>可否設定の一覧表示とポリシーアクセスの確認</title>
<screen>&prompt.sudo;semanage boolean -l
SELinux boolean                          Description
ftp_home_dir                   -&gt; off   ftp_home_dir
mozilla_read_content           -&gt; off   mozilla_read_content
spamassassin_can_network       -&gt; off   spamassassin_can_network
httpd_can_network_relay        -&gt; off   httpd_can_network_relay
openvpn_enable_homedirs        -&gt; off   openvpn_enable_homedirs
gpg_agent_env_file             -&gt; off   gpg_agent_env_file
allow_httpd_awstats_script_anon_write -&gt; off   allow_httpd_awstats_script_anon_write
httpd_can_network_connect_db   -&gt; off   httpd_can_network_connect_db
allow_ftpd_full_access         -&gt; off   allow_ftpd_full_access
samba_domain_controller        -&gt; off   samba_domain_controller
httpd_enable_cgi               -&gt; off   httpd_enable_cgi
virt_use_nfs                   -&gt; off   virt_use_nfs</screen>
    <para>この時点で有用なコマンドがもう 1 つあります。それは下記のとおりです:</para>
<screen>&prompt.sudo;semanage fcontext -l</screen>
    <para>上記は、ポリシーによって提供される既定のファイルコンテキスト設定を表示することができます (詳しくは <xref linkend="ex-selnx-fcon" xrefstyle="select:label quotedtitle nopage"/> をご覧ください) 。</para>
   </example>
   <example xml:id="ex-selnx-fcon">
    <title>ファイルのコンテキスト情報の取得</title>
<screen>&prompt.sudo;semanage fcontext -l
/var/run/usb(/.*)?                                 all files          system_u:object_r:hotplug_var_run_t
/var/run/utmp                                      regular file       system_u:object_r:initrc_var_run_t
/var/run/vbe.*                                     regular file       system_u:object_r:hald_var_run_t
/var/run/vmnat.*                                   socket             system_u:object_r:vmware_var_run_t
/var/run/vmware.*                                  all files          system_u:object_r:vmware_var_run_t
/var/run/watchdog\.pid                             regular file       system_u:object_r:watchdog_var_run_t
/var/run/winbindd(/.*)?                            all files          system_u:object_r:winbind_var_run_t
/var/run/wnn-unix(/.*)                             all files          system_u:object_r:canna_var_run_t
/var/run/wpa_supplicant(/.*)?                      all files          system_u:object_r:NetworkManager_var_run_t
/var/run/wpa_supplicant-global                     socket             system_u:object_r:NetworkManager_var_run_t
/var/run/xdmctl(/.*)?                              all files          system_u:object_r:xdm_var_run_t
/var/run/yiff-[0-9]+\.pid                          regular file       system_u:object_r:soundd_var_run_t</screen>
   </example>
  <!-- </sect2> -->
 </sect1>
 <sect1 xml:id="sec-selinux-manage">
  <title>&selnx; の管理</title>

  <para>ここまでの作業で &selnx; を動作させることができましたので、次は設定作業に移ります。 &selnx; では、プロセスやユーザがどのファイルやディレクトリ、ポートなどにアクセスできるのかを、正確に定義するための追加のルールセットを使用します。ルールセットの設定を行なうにあたって、 &selnx; はそれぞれのファイルやディレクトリ、プロセスやポートに対してコンテキストを設定し、それをセキュリティラベルとして使用します。セキュリティラベルは、それらをどのように扱うべきかを示しているもので、 &selnx; のポリシー側から指定が行なわれます。既定では、ポリシーは全てのアクセスを拒否するように設定されていますので、お使いのシステムが何らかの動作を必要とする場合、管理者はルールを作成してポリシー内に配置する必要があります。</para>

  <sect2 xml:id="sec-selinux-viewcontext">
   <title>セキュリティコンテキストの表示</title>
   <para>上述のとおり、ファイルやディレクトリ、ポートなどに対してラベルを設定することができます。ラベル内では様々なコンテキストを使用します。管理者が日々の作業を実施できるようにするためには、コンテキストタイプについて最も知識を持っておく必要があります。様々なコマンドに用意された <option>-Z</option> オプションを使用することで、現在のコンテキスト設定を表示することができるようになります。 <xref linkend="ex-selnx-def-con" xrefstyle="select:label quotedtitle nopage"/> には、ルートディレクトリ内でのコンテキスト設定の例を示しています。</para>
   <example xml:id="ex-selnx-def-con">
    <title>ルートディレクトリ内でのディレクトリ向け既定コンテキスト</title>
<screen>&prompt.sudo;ls -Z
dr-xr-xr-x. root root system_u:object_r:bin_t:s0       bin
dr-xr-xr-x. root root system_u:object_r:boot_t:s0      boot
drwxr-xr-x. root root system_u:object_r:cgroup_t:s0    cgroup
drwxr-xr-x+ root root unconfined_u:object_r:default_t:s0 data
drwxr-xr-x. root root system_u:object_r:device_t:s0    dev
drwxr-xr-x. root root system_u:object_r:etc_t:s0       etc
drwxr-xr-x. root root system_u:object_r:home_root_t:s0 home
dr-xr-xr-x. root root system_u:object_r:lib_t:s0       lib
dr-xr-xr-x. root root system_u:object_r:lib_t:s0       lib64
drwx------. root root system_u:object_r:lost_found_t:s0 lost+found
drwxr-xr-x. root root system_u:object_r:mnt_t:s0       media
drwxr-xr-x. root root system_u:object_r:autofs_t:s0    misc
drwxr-xr-x. root root system_u:object_r:mnt_t:s0       mnt
drwxr-xr-x. root root unconfined_u:object_r:default_t:s0 mnt2
drwxr-xr-x. root root unconfined_u:object_r:default_t:s0 mounts
drwxr-xr-x. root root system_u:object_r:autofs_t:s0    net
drwxr-xr-x. root root system_u:object_r:usr_t:s0       opt
dr-xr-xr-x. root root system_u:object_r:proc_t:s0      proc
drwxr-xr-x. root root unconfined_u:object_r:default_t:s0 repo
dr-xr-x---. root root system_u:object_r:admin_home_t:s0 root
dr-xr-xr-x. root root system_u:object_r:bin_t:s0       sbin
drwxr-xr-x. root root system_u:object_r:security_t:s0  selinux
drwxr-xr-x. root root system_u:object_r:var_t:s0       srv
-rw-r--r--. root root unconfined_u:object_r:swapfile_t:s0 swapfile
drwxr-xr-x. root root system_u:object_r:sysfs_t:s0     sys
drwxrwxrwt. root root system_u:object_r:tmp_t:s0       tmp
-rw-r--r--. root root unconfined_u:object_r:etc_runtime_t:s0 tmp2.tar
-rw-r--r--. root root unconfined_u:object_r:etc_runtime_t:s0 tmp.tar
drwxr-xr-x. root root system_u:object_r:usr_t:s0       usr
drwxr-xr-x. root root system_u:object_r:var_t:s0       var</screen>
   </example>
   <para>上述の一覧に書かれているとおり、全てのディレクトリに対してコンテキストが設定されていることがわかります。ここにはユーザと役割、タイプがそれぞれ示されています。残る s0 はマルチレベルセキュリティ環境でのセキュリティレベルを示すもので、ここでは説明していません。このような環境では s0 が設定されていることを確認してください。コンテキストの種類は、そのディレクトリ内でどのような種類の動作を許可するのかを表わしています。たとえば <filename>/root</filename> ディレクトリには <filename>admin_home_t</filename> というコンテキストタイプが割り当てられ、 <filename>/home</filename> ディレクトリには <filename>admin_home_t</filename> というコンテキストタイプが割り当てられています。 &selnx; のポリシーでは、これらのコンテキストタイプに対して様々な種類のアクセスが定義されています。</para>
   <para>セキュリティラベルはファイルに対して割り当てられるだけでなく、ポートやプロセスなどにも割り当てられます。 <xref linkend="ex-selnx-set-proc" xrefstyle="select:label quotedtitle nopage"/> では、サーバ内のプロセスに対するコンテキスト設定の表示例を示しています。</para>
   <example xml:id="ex-selnx-set-proc">
    <title><command>ps Zaux</command> によるプロセス向け &selnx; 設定の表示</title>
<screen>&prompt.sudo;ps Zaux
LABEL                           USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
system_u:system_r:init_t        root         1  0.0  0.0  10640   808 ?        Ss   05:31   0:00 init [5]
system_u:system_r:kernel_t      root         2  0.0  0.0      0     0 ?        S    05:31   0:00 [kthreadd]
system_u:system_r:kernel_t      root         3  0.0  0.0      0     0 ?        S    05:31   0:00 [ksoftirqd/0]
system_u:system_r:kernel_t      root         6  0.0  0.0      0     0 ?        S    05:31   0:00 [migration/0]
system_u:system_r:kernel_t      root         7  0.0  0.0      0     0 ?        S    05:31   0:00 [watchdog/0]
system_u:system_r:sysadm_t      root      2344  0.0  0.0  27640   852 ?        Ss   05:32   0:00 /usr/sbin/mcelog --daemon --config-file /etc/mcelog/mcelog.conf
system_u:system_r:sshd_t        root      3245  0.0  0.0  69300  1492 ?        Ss   05:32   0:00 /usr/sbin/sshd -o PidFile=/var/run/sshd.init.pid
system_u:system_r:cupsd_t       root      3265  0.0  0.0  68176  2852 ?        Ss   05:32   0:00 /usr/sbin/cupsd
system_u:system_r:nscd_t        root      3267  0.0  0.0 772876  1380 ?        Ssl  05:32   0:00 /usr/sbin/nscd
system_u:system_r:postfix_master_t root   3334  0.0  0.0  38320  2424 ?        Ss   05:32   0:00 /usr/lib/postfix/master
system_u:system_r:postfix_qmgr_t postfix  3358  0.0  0.0  40216  2252 ?        S    05:32   0:00 qmgr -l -t fifo -u
system_u:system_r:crond_t       root      3415  0.0  0.0  14900   800 ?        Ss   05:32   0:00 /usr/sbin/cron
system_u:system_r:fsdaemon_t    root      3437  0.0  0.0  16468  1040 ?        S    05:32   0:00 /usr/sbin/smartd
system_u:system_r:sysadm_t      root      3441  0.0  0.0  66916  2152 ?        Ss   05:32   0:00 login -- root
system_u:system_r:sysadm_t      root      3442  0.0  0.0   4596   800 tty2     Ss+  05:32   0:00 /sbin/mingetty tty2</screen>
   </example>
  </sect2>

  <sect2 xml:id="sec-selinux-selectmode">
   <title>&selnx; モードの選択</title>
   <para>&selnx; では、 3 種類のモードを使用します:</para>
   <variablelist>
    <varlistentry>
     <term>強制 (Enforcing):</term>
     <listitem>
      <para>こちらが既定のモードです。 &selnx; では、ポリシー内のルールに従ってサーバを保護します。合わせて &selnx; では、監査ログ内に動作状況を記録します。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>許容 (Permissive):</term>
     <listitem>
      <para>このモードはトラブルシューティングで有用な仕組みです。許容モードでは、 &selnx; はサーバを保護しませんが、ログファイル内への記録は変わらず行なわれます。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>無効 (Disabled):</term>
     <listitem>
      <para>このモードでは、 &selnx; は完全に無効化され、ログへの記録も行なわれません。ファイルシステム内に設定されたラベルについては、ファイルシステムから削除されることはありません。</para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>&selnx; のモードの設定方法については前述のとおり、システム起動時の &grub; でパラメータを指定して行ないます。</para>
  </sect2>

  <sect2 xml:id="sec-selinux-modifycontext">
   <title>&selnx; のコンテキストタイプの変更</title>
   <para>管理者の作業として重要なものとして、 &selnx; を正しく動作させるため、ファイルにコンテキストタイプを設定する作業があります。</para>
   <para>ファイルが特定のディレクトリ内に作成されると、既定では親のディレクトリのコンテキストタイプを継承します。ですが、ファイルが一方のディレクトリから他方のディレクトリに移動されると、以前の場所でのコンテキストタイプをそのまま適用し続けます。</para>
   <para>ファイルに対してコンテキストタイプを設定するには、 <command>semanage fcontext</command> コマンドを使用します。このコマンドでは、新しいコンテキストタイプをポリシー内に書き込むまでは行なうものの、実際のコンテキストタイプを即時に反映することは行ないません。ポリシー内のコンテキストタイプを実際に反映させるには、設定後に <command>restorecon</command> コマンドを実行します。</para>
   <para><command>semanage fcontext</command> を利用してみる前に、まずは実際にどのようなコンテキストが必要なのかを確認します。具体的には下記のように実行します:</para>
<screen>&prompt.sudo;semanage fcontext -l</screen>
   <para>上記のように実行することで、ポリシー内に設定されている全てのコンテキストを表示することができます。ですが、出力は比較的長いものであるため、実際に必要なコンテキストを知るには少し面倒ではあります (<xref linkend="ex-selnx-semanage" xrefstyle="select:label quotedtitle nopage"/> をご覧ください) 。</para>
   <example xml:id="ex-selnx-semanage">
    <title>既定のファイルコンテキストの表示</title>
<screen>&prompt.sudo;semanage fcontext -l | less
&selnx; fcontext                                   type               Context

/                                                  directory          system_u:object_r:root_t:s0
/.*                                                all files          system_u:object_r:default_t:s0
/[^/]+                                             regular file       system_u:object_r:etc_runtime_t:s0
/\.autofsck                                        regular file       system_u:object_r:etc_runtime_t:s0
/\.autorelabel                                     regular file       system_u:object_r:etc_runtime_t:s0
/\.journal                                         all files          X:&gt;&gt;None&gt;&gt;
/\.suspended                                       regular file       system_u:object_r:etc_runtime_t:s0
/a?quota\.(user|group)                             regular file       system_u:object_r:quota_db_t:s0
/afs                                               directory          system_u:object_r:mnt_t:s0
/bin                                               directory          system_u:object_r:bin_t:s0
/bin/.*                                            all files          system_u:object_r:bin_t:s0</screen>
   </example>
   <para>お使いのサービスでどのようなコンテキスト設定が利用できるのかを確認する方法には、下記の 3 つの方法があります:</para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>サービスをインストールして、使用されている既定のコンテキストを判別する方法。この方法が最も簡単であり、推奨される方法です。</para>
    </listitem>
    <listitem>
     <para>特定のサービスに対してマニュアルページを確認します。サービスによっては <literal>_selinux</literal> で終わる名前のマニュアルページを用意しているものがあり、必要なコンテキスト設定の情報を取得できるものがあります。</para>
     <para>正しいコンテキスト設定を見つけることができたら、 <command>semanage fcontext</command> を利用して設定を適用します。このコマンドでは <option>-t</option> のコンテキストタイプの指定を最初のパラメータとして指定し、その後ろに適用したい先のディレクトリやファイルを指定します。コンテキストを適用したいディレクトリ内に存在する全てに対して、コンテキストを適用したい場合は、ディレクトリ名の箇所に <literal>(/.*)?</literal> を指定します。これは正規表現で、スラッシュに続いて任意の文字が続くものを表わしています。このほかにも、 <command>semanage</command> のマニュアルページ内の examples セクションには、 <command>semanage</command> を使用する際の様々な便利な例が示されています。正規表現に関する詳しい情報については、 <link xlink:href="https://ja.wikipedia.org/wiki/%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%8F%BE"/> をお読みください。</para>
    </listitem>
    <listitem>
     <para>お使いのシステムで利用可能な全てのコンテキストタイプを一覧表示する方法:</para>
<screen>&prompt.sudo;seinfo -t</screen>
     <para>コマンドそれ自身は非常に多くの情報を出力します。そのため、 <command>grep</command> などのコマンドを併用して、必要な情報だけを取得するようにしてください。</para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 xml:id="sec-selinux-applyfilecontext">
   <title>ファイルコンテキストの適用</title>
   <para>&selnx; のコンテキストを正しく適用するため、下記の手順では <command>semanage fcontext</command> と <command>restorecon</command> を使用して、コンテキストを設定する方法を示しています。ここまでの説明でご存じのとおり、既定のドキュメントルート以外を使用した場合、 Web サーバが動作しません。 &selnx; の設定を変更して、正しく動作するようにするまでの手順を示します:</para>
   <procedure>
    <step>
     <para><filename>/web</filename> ディレクトリを作成し、そのディレクトリに移動します:</para>
<screen>&prompt.sudo;mkdir /web  &amp;&amp; cd /web</screen>
    </step>
    <step>
     <para>テキストエディタを利用して、 <filename>/web/index.html</filename> ファイルを作成し、どんなものでもかまいませんのでコンテンツを作成します。</para>
    </step>
    <step>
     <para><filename>/etc/apache2/default-server.conf</filename> ファイルをエディタで開いて、 DocumentRoot の行を <literal>DocumentRoot /web</literal> のように変更します。</para>
    </step>
    <step>
     <para>Apache Web サーバを再起動します:</para>
<screen>&prompt.sudo;systemctl start apache2</screen>
    </step>
    <step>
     <para>ローカルの Web サーバが表示できるかどうか、テストを行ないます:</para>
<screen>&prompt.user;w3m localhost</screen>
     <para><emphasis>Connection refused</emphasis> (接続が拒否されました) のようなメッセージが表示されるかと思います。 <keycap function="enter"/> を押したあと、 <command>q</command> を押して w3m を終了します。</para>
    </step>
    <step>
     <para>Apache Web サーバ既定の <literal>ドキュメントルート</literal> に対して、コンテキストタイプを表示します。このディレクトリは <filename>/srv/www/htdocs</filename> になっています。このディレクトリに対しては、 <filename>httpd_sys_content_t</filename> が設定されているはずです:</para>
<screen>&prompt.sudo;ls -Z /srv/www</screen>
    </step>
    <step>
     <para>ポリシー内に新しいコンテキストを設定します。下記のとおり入力して <keycap function="enter"/> を押します:</para>
<screen>&prompt.sudo;semanage fcontext -a -f "" -t httpd_sys_content_t '/web(/.*) ?'</screen>
    </step>
    <step>
     <para>新しいコンテキストタイプを適用します:</para>
<screen>&prompt.sudo;restorecon /web</screen>
    </step>
    <step>
     <para><filename>/web</filename> ディレクトリ内のファイルのコンテキスト情報を表示します。<filename>/web</filename> ディレクトリには正しく設定されているものの、そのディレクトリ内のファイルには設定されていないはずです:</para>
<screen>&prompt.sudo;ls -Z /web</screen>
    </step>
    <step>
     <para>今度は新しいコンテキストを、 <filename>/web</filename> ディレクトリ以下の全てに対して再帰的に適用します。これでファイルにも新しいコンテキストが適用されるようになります:</para>
<screen>&prompt.sudo;restorecon -R /web</screen>
    </step>
    <step>
     <para>Web サーバを再起動します:</para>
<screen>&prompt.sudo;systemctl restart apache2</screen>
     <para>これで <filename>/web</filename> ディレクトリ内のコンテンツについても、問題なくアクセスできるようになっているはずです。</para>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec-selinux-configurepolicy">
   <title>&selnx; ポリシーの設定</title>
   <para>ポリシーの動作を変更する際、最も簡単なものは可否設定 (boolean) です。可否設定はオンとオフを切り替えることのできる項目で、ポリシー内で変更することのできるものです。利用可能な設定の一覧を取得するには、下記のように入力して実行します:</para>
<screen>&prompt.sudo;semanage boolean -l</screen>
   <para>上記を実行すると、可否設定の長い一覧と共に、それぞれの可否設定に対する短い説明文が表示されます。必要な可否設定を見つけることができたら、あとは <command>setsebool -P</command> を利用して、設定作業を行ないます。このコマンドの後ろには可否設定の名前を指定します。このとき、 <command>setsebool</command> に <option>-P</option> というオプションを指定していることに注目してください。このオプションは、ディスク上にあるポリシーファイル内に設定を書き込むためのもので、システムを再起動しても設定を残すように設定するための唯一の方法でもあります。</para>
   <para>下記の手順では、可否設定の変更例を示しています:</para>
   <procedure>
    <step>
     <para>まずは FTP サーバに関連する可否設定を一覧表示します:</para>
<screen>&prompt.sudo;semanage boolean -l | grep ftp</screen>
    </step>
    <step>
     <para>可否設定をオフにします:</para>
<screen>&prompt.sudo;setsebool allow_ftpd_anon_write off</screen>
     <para>なお、変更を書き込むのにそれほど時間はかかりません。設定を書き込んだら、本当にオフになっているのかを確認します:</para>
<screen>&prompt.sudo;semanage boolean -l|grep ftpd_anon</screen>
    </step>
    <step>
     <para>あとはサーバを再起動します。</para>
    </step>
    <step>
     <para>再起動後、 <literal>allow_ftpd_anon_write</literal> の設定がオンに戻っていることを確認します。これは、ポリシーがファイルには書き込まれなかったためです。</para>
    </step>
    <step>
     <para>再度可否設定を切り替えて、今度はポリシーファイルにも書き込みます:</para>
<screen>&prompt.sudo;setsebool -P allow_ftpd_anon_write</screen>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec-selinux-module">
   <title>&selnx; モジュールの使用</title>
   <para>既定では、 &selnx; はモジュール型のポリシーを使用します。これは、 &selnx; の機能が単一の巨大なポリシーとして作られているのではなく、多数の小さいモジュールとして構成されていることを意味しています。それぞれのモジュールには、それぞれ対応する &selnx; の設定パートがあります。このような &selnx; の仕組みにより、サードパーティのベンダがサービスを提供する場合でも、自身のサービスを &selnx; に対応できるようにすることができます。 &selnx; のモジュールの一覧を取得するには、 <command>semodule -l</command> コマンドを実行します。このコマンドは、 &selnx; で使用されている全てのモジュールと、そのバージョン番号を表示します。</para>
   <para>管理者の権限を使用すると、モジュールを個別にオンもしくはオフにすることができます。これは &selnx; の一部の機能のみを無効化したい場合や、全てのサービスを &selnx; で保護する必要がない場合に便利な仕組みです。特に &productname; では、 &selnx; ポリシーを完全にサポートしているわけではないので、全てのモジュールをいったんオフに設定して、必要なサービスにのみ &selnx; の保護を適用したほうが都合がよいことがあります。 &selnx; のモジュールをオフにしたい場合は、下記のように入力して実行します:</para>
<screen>&prompt.sudo;semodule -d <replaceable>モジュール名</replaceable></screen>
   <para>オンに戻したい場合は、下記のように入力して実行します:</para>
   <screen>&prompt.sudo;semodule -e <replaceable>モジュール名</replaceable></screen>
   <!--
    <remark>jsegitz, 2015-10-30: not true, the source files aren't available</remark>
   <para>
    It will change the current state of the module in the
    <filename>/etc/selinux/minimum/policy/modules.conf</filename> file.
   </para>
   <para>
    To handle policy modules properly, it helps to understand what you are
    dealing with. In the end, a policy module is a compiled policy file that
    you can load using the <command>semodule -e</command> command. You can
    recognize these files by the extension they use:
    *<filename>.pp</filename> (which stands for Policy Package). In some
    cases it can be useful to modify modules to have them do exactly what
    you need them to do. Three different kinds of files are used as input
    files for policy modules and you can find them in subdirectories of the
    <filename>/etc/selinux/minimum/policy/modules</filename> directory:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>
      <filename>*.te</filename> files contain the actual allow rules and
      calls to interfaces (also transition rules). These rules tell the
      policy how to deal with specific subprocesses that are started. You
      will not often change these as an administrator.
     </para>
    </listitem>
    <listitem>
     <para>
      <filename>*.if</filename> files contain interface definitions. As an
      administrator you do not typically change the contents of these files.
     </para>
    </listitem>
    <listitem>
     <para>
      <filename>*.fc</filename> files contain the labeling instructions that
      apply to this policy. As an administrator, you may need to change
      their contents with the <command>semanage</command> to modify the
      default behavior of policies.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    In
    <xref linkend="ex-selnx-li-apachefc" xrefstyle="select:label quotedtitle nopage"/>
    below you can see the first 20 lines of the
    <filename>apache.fc</filename> file. This is the file that contains the
    default file contexts that are used for the Apache server.
   </para>
   <example xml:id="ex-selnx-li-apachefc">
    <title>The First 20 Lines of <filename>apache.fc</filename></title>
<screen>/etc/apache(2)?(/.*)? gen_context(system_u:object_r:httpd_config_t,s0)
/etc/apache-ssl(2)?(/.*)? gen_context(system_u:object_r:httpd_config_t,s0)
/etc/htdig(/.*)? gen_context(system_u:object_r:httpd_sys_content_t,s0)
/etc/httpd -d gen_context(system_u:object_r:httpd_config_t,s0) /etc/httpd/conf.*
gen_context(system_u:object_r:httpd_config_t,s0) /etc/httpd/logs
gen_context(system_u:object_r:httpd_log_t,s0) /etc/httpd/modules
gen_context(system_u:object_r:httpd_modules_t,s0) /etc/vhosts \-\-
gen_context(system_u:object_r:httpd_config_t,s0) /srv/([^/]*/)?www(/.*)?
gen_context(system_u:object_r:httpd_sys_content_t,s0) /srv/gallery2(/.*)?
gen_context(system_u:object_r:httpd_sys_content_t,s0) /usr/bin/htsslpass \-\-
gen_context(system_u:object_r:httpd_helper_exec_t,s0) /usr/lib/apache-ssl/.+ \-\-
gen_context(system_u:object_r:httpd_exec_t,s0) /usr/lib/cgi-bin(/.*)?
gen_context(system_u:object_r:httpd_sys_script_exec_t,s0)
/usr/lib(64)?/apache(/.*)? gen_context(system_u:object_r:httpd_modules_t,s0)
/usr/lib(64)?/apache2/modules(/.*)?
gen_context(system_u:object_r:httpd_modules_t,s0)</screen>
   </example>
   <remark>jsegitz, 2015-10-30: these are not the first 20 lines of the file and it's also syntactically incorrect. Please check the current file</remark>
   <para>
    In the <filename>fc</filename> file, you will be able to recognize
    different elements. First is the name of the directory or file to which
    the file context will apply. As you can see, variables can be used (as
    is the case in the first line that starts with
    <varname>HOME_DIR</varname>),
    <remark>jsegitz, 2015-10-30: the description doesn't match the listing</remark>
    and typically, regular expressions will be used as well. Next, the
    gen_context command tells the policy to which context the files related
    to the policy module should be set. This is the same context setting
    that you can see when using <command>ls -Z</command> on the file or
    directory.
   </para>
   -->
   <para>ポリシーモジュールファイル内の内容を変更するには、まずは変更点を新しいポリシーモジュールファイルにコンパイルする必要があります。これを行なうには、 <systemitem>selinux-policy-devel</systemitem> パッケージをインストールしたあと、 <command>audit2allow</command> コマンドで作成したファイルのあるディレクトリ内で、下記のように入力して実行します:</para>
   <screen>&prompt.user;make -f /usr/share/selinux/devel/Makefile</screen>
   <para><command>make</command> の処理が完了したあとは、 <command>semodule -i</command> を使用することで、モジュールを手作業でシステムに読み込むことができるようになります。</para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-selinux-troubleshoot">
  <title>トラブルシューティング</title>

  <para>既定では、 &selnx; が何らかの理由で動作しない場合、ログメッセージが <filename>/var/log/audit/audit.log</filename> ファイル内に記録されます。ただし、このファイルに書き込みを行なうには、 auditd サービスを動作させて置かなければなりません。 <filename>/var/log/audit</filename> ディレクトリ内に何もファイルが存在しない場合は、下記のように入力して実行し、 auditd サービスを開始してください:</para>

<screen>&prompt.sudo;systemctl start auditd</screen>

  <para>また、システムの起動時に開始するように設定したい場合は、下記のように入力して実行します:</para>

<screen>&prompt.sudo;systemctl enable auditd</screen>

  <para><xref linkend="ex-selnx-li-auditlog" xrefstyle="select:label quotedtitle nopage"/> には、 <filename>/var/log/audit/audit.log</filename> の内容の出力例があります:</para>

  <example xml:id="ex-selnx-li-auditlog">
   <title><filename>/etc/audit/audit.log</filename> の例</title>
<screen>type=DAEMON_START msg=audit(1348173810.874:6248): auditd start, ver=1.7.7 format=raw kernel=3.0.13-0.27-default auid=0 pid=4235 subj=system_u:system_r:auditd_t res=success
type=AVC msg=audit(1348173901.081:292): avc:  denied  { write } for  pid=3426 comm="smartd" name="smartmontools" dev=sda6 ino=581743 scontext=system_u:system_r:fsdaemon_t tcontext=system_u:object_r:var_lib_t tclass=dir
type=AVC msg=audit(1348173901.081:293): avc:  denied  { remove_name } for  pid=3426 comm="smartd" name="smartd.WDC_WD2500BEKT_75PVMT0-WD_WXC1A21E0454.ata.state~" dev=sda6 ino=582390 scontext=system_u:system_r:fsdaemon_t tcontext=system_u:object_r:var_lib_t tclass=dir
type=AVC msg=audit(1348173901.081:294): avc:  denied  { unlink } for  pid=3426 comm="smartd" name="smartd.WDC_WD2500BEKT_75PVMT0-WD_WXC1A21E0454.ata.state~" dev=sda6 ino=582390 scontext=system_u:system_r:fsdaemon_t tcontext=system_u:object_r:var_lib_t tclass=file
type=AVC msg=audit(1348173901.081:295): avc:  denied  { rename } for  pid=3426 comm="smartd" name="smartd.WDC_WD2500BEKT_75PVMT0-WD_WXC1A21E0454.ata.state" dev=sda6 ino=582373 scontext=system_u:system_r:fsdaemon_t tcontext=system_u:object_r:var_lib_t tclass=file
type=AVC msg=audit(1348173901.081:296): avc:  denied  { add_name } for  pid=3426 comm="smartd" name="smartd.WDC_WD2500BEKT_75PVMT0-WD_WXC1A21E0454.ata.state~" scontext=system_u:system_r:fsdaemon_t tcontext=system_u:object_r:var_lib_t tclass=dir
type=AVC msg=audit(1348173901.081:297): avc:  denied  { create } for  pid=3426 comm="smartd" name="smartd.WDC_WD2500BEKT_75PVMT0-WD_WXC1A21E0454.ata.state" scontext=system_u:system_r:fsdaemon_t tcontext=system_u:object_r:var_lib_t tclass=file
type=AVC msg=audit(1348173901.081:298): avc:  denied  { write open } for  pid=3426 comm="smartd" name="smartd.WDC_WD2500BEKT_75PVMT0-WD_WXC1A21E0454.ata.state" dev=sda6 ino=582390 scontext=system_u:system_r:fsdaemon_t tcontext=system_u:object_r:var_lib_t tclass=file
type=AVC msg=audit(1348173901.081:299): avc:  denied  { getattr } for  pid=3426 comm="smartd" path="/var/lib/smartmontools/smartd.WDC_WD2500BEKT_75PVMT0-WD_WXC1A21E0454.ata.state" dev=sda6 ino=582390 scontext=system_u:system_r:fsdaemon_t tcontext=system_u:object_r:var_lib_t tclass=file
type=AVC msg=audit(1348173901.309:300): avc:  denied  { append } for  pid=1316</screen>
  </example>

  <para>はじめて <filename>audit.log</filename> をお読みになる方にとっては、少しわかりにくいと感じることでしょう。しかしながら、読み方がわかればそれほど難しくはありません。各行はそれぞれセクションに分割することができます。たとえば末尾の行の意味は下記のようになります:</para>

  <variablelist>
   <varlistentry>
    <term><literal>type=AVC</literal> :</term>
    <listitem>
     <para>それぞれの &selnx; 関連の監査ログ行には、 <literal>type=AVC</literal> という種類判別用の記述が書き込まれます。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>msg=audit(1348173901.309:300)</literal> :</term>
    <listitem>
     <para>これはタイムスタンプを意味しています。ただし、エポック秒と呼ばれる、 1970 年 1 月 1 日からの経過秒数で書かれています。整数部分については、 <command>date -d</command> コマンドで日時に変換することができます:</para>
<screen>&prompt.user;date -d @1348173901
2012年  9月 21日 金曜日 05:45:01 JST</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>avc: denied { append }</literal> :</term>
    <listitem>
     <para>拒否された処理の内容を示しています。この場合、システムはデータをファイルに追記する処理が拒否されたことを表わしています。監査ログファイル内では、ファイルを開いたり属性を取得したりなど、様々な処理が記録されることになります。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>for pid=1316</literal> :</term>
    <listitem>
     <para>その処理を実施したコマンドもしくはプロセスのプロセス ID です。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>comm="rsyslogd"</literal> :</term>
    <listitem>
     <para>その PID に結びつけられたコマンドを表わしています。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>name="smartmontools"</literal> :</term>
    <listitem>
     <para>処理を実行しようとしたアプリケーションの名前を表わしています。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>dev=sda6 ino=582296</literal> :</term>
    <listitem>
     <para>対象となるファイルが存在するブロックデバイス名と inode 番号です。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>scontext=system_u:system_r:syslogd_t</literal> :</term>
    <listitem>
     <para>ソースコンテキストと呼ばれ、処理を実行しようとした側のコンテキストを表わしています。</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>tclass=file</literal> :</term>
    <listitem>
     <para>処理内容の分類名を表わしています。</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>audit.log 内の各イベントの意味を自分自身で解釈する以外の方法もあります。それは、 <command>audit2allow</command> というコマンドです。このコマンドは、わかりにくい <filename>/var/log/audit/audit.log</filename> 内のメッセージを分析するための支援を行なうソフトウエアです。下記に示す 3 種類の形態が用意されています。 1 つめは <command>audit2allow -w -a</command> のような実行形態で、より読みやすい形式で監査情報を表示することができます。 <command>audit2allow -w -a</command> は、既定では audit.log ファイルを読み込みます。 audit.log ファイル内の特定のメッセージのみを分析したい場合は、一時ファイルにコピーして下記のように入力して実行してください:</para>

<screen>&prompt.sudo;audit2allow -w -i <replaceable>ファイル名</replaceable></screen>

  <example>
   <title>監査メッセージの分析</title>
<screen>&prompt.sudo;audit2allow -w -i testfile
type=AVC msg=audit(1348173901.309:300): avc:  denied  { append } for  pid=1316
comm="rsyslogd" name="acpid" dev=sda6 ino=582296
scontext=system_u:system_r:syslogd_t tcontext=system_u:object_r:apmd_log_t tclass=file</screen>
  </example>

  <variablelist>
   <varlistentry>
    <term>これは下記の理由によって発生しています:</term>
    <listitem>
     <para>タイプ強制 (Type Enforcement; TE) の許可ルールが存在しないためです。</para>
     <para>このアクセスを許可するような読み込みモジュールを生成するには、下記のように入力して実行します:</para>
<screen>&prompt.sudo;audit2allow</screen>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>アクセスを拒否したルールを見つけたい場合は、 <command>audit2allow -a</command> と入力して実行し、 <filename>audit.log</filename> ファイル内に記録された全てのメッセージから、対応する強制ルールを表示することができるほか、 <command>audit2allow -i <replaceable>ファイル名</replaceable></command> のように入力して実行することで、指定したファイル内に保存されているメッセージに対する強制ルールを表示することもできます。</para>

  <example>
   <title>アクセス拒否内容の表示</title>
<screen>&prompt.sudo;audit2allow -i testfile
#============= syslogd_t ==============
allow syslogd_t apmd_log_t:file append;</screen>
  </example>

  <para><literal>mymodule</literal> という名前の &selnx; モジュールを作成し、以前は拒否されていたアクセスを許可するように設定したい場合は、下記のように入力して実行します:</para>

<screen>&prompt.sudo;audit2allow -a -R -M mymodule</screen>

  <para>audit.log に記録されている全てのイベントに対して、同様のことを行ないたい場合は、パラメータに <option>-a -M</option> を追加します。また、特定のファイル内のメッセージに対してのみ実施したい場合は、下記のように <option>-i -M</option> を追加します:</para>

  <example>
   <title>以前に拒否されたアクションを許可するためのポリシー作成</title>
<screen>&prompt.sudo;audit2allow -i testfile -M example
******************** IMPORTANT ***********************
To make this policy package active, execute:

semodule -i example.pp</screen>
  </example>

  <para><command>audit2allow</command> コマンドの出力にもあるとおり、この後に <command>semodule -i</command> コマンドの後ろにモジュール名指定して、実行します。このとき、モジュール名は <command>audit2allow</command> で指定した名前となります (上記の例では <filename>example.pp</filename> です) 。</para>
 </sect1>
</chapter>
